/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/.pnpm/tslib@2.5.0/node_modules/tslib/tslib.js
var require_tslib = __commonJS({
  "node_modules/.pnpm/tslib@2.5.0/node_modules/tslib/tslib.js"(exports, module2) {
    var __extends2;
    var __assign2;
    var __rest2;
    var __decorate2;
    var __param2;
    var __esDecorate2;
    var __runInitializers2;
    var __propKey2;
    var __setFunctionName2;
    var __metadata2;
    var __awaiter2;
    var __generator2;
    var __exportStar2;
    var __values2;
    var __read2;
    var __spread2;
    var __spreadArrays2;
    var __spreadArray2;
    var __await2;
    var __asyncGenerator2;
    var __asyncDelegator2;
    var __asyncValues2;
    var __makeTemplateObject2;
    var __importStar2;
    var __importDefault2;
    var __classPrivateFieldGet2;
    var __classPrivateFieldSet2;
    var __classPrivateFieldIn2;
    var __createBinding2;
    (function(factory) {
      var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function(exports2) {
          factory(createExporter(root, createExporter(exports2)));
        });
      } else if (typeof module2 === "object" && typeof module2.exports === "object") {
        factory(createExporter(root, createExporter(module2.exports)));
      } else {
        factory(createExporter(root));
      }
      function createExporter(exports2, previous) {
        if (exports2 !== root) {
          if (typeof Object.create === "function") {
            Object.defineProperty(exports2, "__esModule", { value: true });
          } else {
            exports2.__esModule = true;
          }
        }
        return function(id, v) {
          return exports2[id] = previous ? previous(id, v) : v;
        };
      }
    })(function(exporter) {
      var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
        d.__proto__ = b;
      } || function(d, b) {
        for (var p in b)
          if (Object.prototype.hasOwnProperty.call(b, p))
            d[p] = b[p];
      };
      __extends2 = function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
      __assign2 = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      __rest2 = function(s, e) {
        var t = {};
        for (var p in s)
          if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
          for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
          }
        return t;
      };
      __decorate2 = function(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
          r = Reflect.decorate(decorators, target, key, desc);
        else
          for (var i = decorators.length - 1; i >= 0; i--)
            if (d = decorators[i])
              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
      };
      __param2 = function(paramIndex, decorator) {
        return function(target, key) {
          decorator(target, key, paramIndex);
        };
      };
      __esDecorate2 = function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
        function accept(f) {
          if (f !== void 0 && typeof f !== "function")
            throw new TypeError("Function expected");
          return f;
        }
        var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
        var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
        var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
        var _, done = false;
        for (var i = decorators.length - 1; i >= 0; i--) {
          var context = {};
          for (var p in contextIn)
            context[p] = p === "access" ? {} : contextIn[p];
          for (var p in contextIn.access)
            context.access[p] = contextIn.access[p];
          context.addInitializer = function(f) {
            if (done)
              throw new TypeError("Cannot add initializers after decoration has completed");
            extraInitializers.push(accept(f || null));
          };
          var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
          if (kind === "accessor") {
            if (result === void 0)
              continue;
            if (result === null || typeof result !== "object")
              throw new TypeError("Object expected");
            if (_ = accept(result.get))
              descriptor.get = _;
            if (_ = accept(result.set))
              descriptor.set = _;
            if (_ = accept(result.init))
              initializers.push(_);
          } else if (_ = accept(result)) {
            if (kind === "field")
              initializers.push(_);
            else
              descriptor[key] = _;
          }
        }
        if (target)
          Object.defineProperty(target, contextIn.name, descriptor);
        done = true;
      };
      __runInitializers2 = function(thisArg, initializers, value) {
        var useValue = arguments.length > 2;
        for (var i = 0; i < initializers.length; i++) {
          value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
        }
        return useValue ? value : void 0;
      };
      __propKey2 = function(x) {
        return typeof x === "symbol" ? x : "".concat(x);
      };
      __setFunctionName2 = function(f, name, prefix) {
        if (typeof name === "symbol")
          name = name.description ? "[".concat(name.description, "]") : "";
        return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
      };
      __metadata2 = function(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
          return Reflect.metadata(metadataKey, metadataValue);
      };
      __awaiter2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      __generator2 = function(thisArg, body) {
        var _ = { label: 0, sent: function() {
          if (t[0] & 1)
            throw t[1];
          return t[1];
        }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
          return this;
        }), g;
        function verb(n) {
          return function(v) {
            return step([n, v]);
          };
        }
        function step(op) {
          if (f)
            throw new TypeError("Generator is already executing.");
          while (g && (g = 0, op[0] && (_ = 0)), _)
            try {
              if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                return t;
              if (y = 0, t)
                op = [op[0] & 2, t.value];
              switch (op[0]) {
                case 0:
                case 1:
                  t = op;
                  break;
                case 4:
                  _.label++;
                  return { value: op[1], done: false };
                case 5:
                  _.label++;
                  y = op[1];
                  op = [0];
                  continue;
                case 7:
                  op = _.ops.pop();
                  _.trys.pop();
                  continue;
                default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                    _ = 0;
                    continue;
                  }
                  if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                    _.label = op[1];
                    break;
                  }
                  if (op[0] === 6 && _.label < t[1]) {
                    _.label = t[1];
                    t = op;
                    break;
                  }
                  if (t && _.label < t[2]) {
                    _.label = t[2];
                    _.ops.push(op);
                    break;
                  }
                  if (t[2])
                    _.ops.pop();
                  _.trys.pop();
                  continue;
              }
              op = body.call(thisArg, _);
            } catch (e) {
              op = [6, e];
              y = 0;
            } finally {
              f = t = 0;
            }
          if (op[0] & 5)
            throw op[1];
          return { value: op[0] ? op[1] : void 0, done: true };
        }
      };
      __exportStar2 = function(m, o) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
            __createBinding2(o, m, p);
      };
      __createBinding2 = Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      };
      __values2 = function(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
          return m.call(o);
        if (o && typeof o.length === "number")
          return {
            next: function() {
              if (o && i >= o.length)
                o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      __read2 = function(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
          return o;
        var i = m.call(o), r, ar = [], e;
        try {
          while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
            ar.push(r.value);
        } catch (error) {
          e = { error };
        } finally {
          try {
            if (r && !r.done && (m = i["return"]))
              m.call(i);
          } finally {
            if (e)
              throw e.error;
          }
        }
        return ar;
      };
      __spread2 = function() {
        for (var ar = [], i = 0; i < arguments.length; i++)
          ar = ar.concat(__read2(arguments[i]));
        return ar;
      };
      __spreadArrays2 = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
          s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
          for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
        return r;
      };
      __spreadArray2 = function(to, from, pack) {
        if (pack || arguments.length === 2)
          for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
              if (!ar)
                ar = Array.prototype.slice.call(from, 0, i);
              ar[i] = from[i];
            }
          }
        return to.concat(ar || Array.prototype.slice.call(from));
      };
      __await2 = function(v) {
        return this instanceof __await2 ? (this.v = v, this) : new __await2(v);
      };
      __asyncGenerator2 = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await2 ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      __asyncDelegator2 = function(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function(e) {
          throw e;
        }), verb("return"), i[Symbol.iterator] = function() {
          return this;
        }, i;
        function verb(n, f) {
          i[n] = o[n] ? function(v) {
            return (p = !p) ? { value: __await2(o[n](v)), done: false } : f ? f(v) : v;
          } : f;
        }
      };
      __asyncValues2 = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values2 === "function" ? __values2(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __makeTemplateObject2 = function(cooked, raw) {
        if (Object.defineProperty) {
          Object.defineProperty(cooked, "raw", { value: raw });
        } else {
          cooked.raw = raw;
        }
        return cooked;
      };
      var __setModuleDefault = Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      };
      __importStar2 = function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding2(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      __importDefault2 = function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      __classPrivateFieldGet2 = function(receiver, state, kind, f) {
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
      };
      __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
        if (kind === "m")
          throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
          throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
          throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
      };
      __classPrivateFieldIn2 = function(state, receiver) {
        if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function")
          throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof state === "function" ? receiver === state : state.has(receiver);
      };
      exporter("__extends", __extends2);
      exporter("__assign", __assign2);
      exporter("__rest", __rest2);
      exporter("__decorate", __decorate2);
      exporter("__param", __param2);
      exporter("__esDecorate", __esDecorate2);
      exporter("__runInitializers", __runInitializers2);
      exporter("__propKey", __propKey2);
      exporter("__setFunctionName", __setFunctionName2);
      exporter("__metadata", __metadata2);
      exporter("__awaiter", __awaiter2);
      exporter("__generator", __generator2);
      exporter("__exportStar", __exportStar2);
      exporter("__createBinding", __createBinding2);
      exporter("__values", __values2);
      exporter("__read", __read2);
      exporter("__spread", __spread2);
      exporter("__spreadArrays", __spreadArrays2);
      exporter("__spreadArray", __spreadArray2);
      exporter("__await", __await2);
      exporter("__asyncGenerator", __asyncGenerator2);
      exporter("__asyncDelegator", __asyncDelegator2);
      exporter("__asyncValues", __asyncValues2);
      exporter("__makeTemplateObject", __makeTemplateObject2);
      exporter("__importStar", __importStar2);
      exporter("__importDefault", __importDefault2);
      exporter("__classPrivateFieldGet", __classPrivateFieldGet2);
      exporter("__classPrivateFieldSet", __classPrivateFieldSet2);
      exporter("__classPrivateFieldIn", __classPrivateFieldIn2);
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => QuickAdd
});
module.exports = __toCommonJS(main_exports);
var import_obsidian29 = require("obsidian");

// src/quickAddSettingsTab.ts
var import_obsidian25 = require("obsidian");

// node_modules/.pnpm/svelte@3.55.1/node_modules/svelte/internal/index.mjs
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn2) {
  return fn2();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function create_slot(definition, ctx, $$scope, fn2) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn2);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn2) {
  return definition[1] && fn2 ? assign($$scope.ctx.slice(), definition[1](fn2(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn2) {
  if (definition[2] && fn2) {
    const lets = definition[2](fn2(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function set_svg_attributes(node, attributes) {
  for (const key in attributes) {
    attr(node, key, attributes[key]);
  }
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function select_option(select, value) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  select.selectedIndex = -1;
}
function select_value(select) {
  const selected_option = select.querySelector(":checked") || select.options[0];
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn2) {
  get_current_component().$$.on_mount.push(fn2);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(type, detail, { cancelable });
      callbacks.slice().forEach((fn2) => {
        fn2.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn2) => fn2.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn2) {
  render_callbacks.push(fn2);
}
function add_flush_callback(fn2) {
  flush_callbacks.push(fn2);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block5, next3, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block5(key, child_ctx);
      block.c();
    } else if (dynamic) {
      block.p(child_ctx, dirty);
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next3);
    lookup.set(block.key, block);
    next3 = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next3 = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  return new_blocks;
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance18, create_fragment18, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance18 ? instance18(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment18 ? create_fragment18($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/.pnpm/tslib@2.5.0/node_modules/tslib/modules/index.js
var import_tslib = __toESM(require_tslib(), 1);
var {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __exportStar,
  __createBinding,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn
} = import_tslib.default;

// node_modules/.pnpm/@fortawesome+free-solid-svg-icons@6.2.1/node_modules/@fortawesome/free-solid-svg-icons/index.mjs
var faBars = {
  prefix: "fas",
  iconName: "bars",
  icon: [448, 512, ["navicon"], "f0c9", "M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"]
};
var faTrash = {
  prefix: "fas",
  iconName: "trash",
  icon: [448, 512, [], "f1f8", "M135.2 17.7L128 32H32C14.3 32 0 46.3 0 64S14.3 96 32 96H416c17.7 0 32-14.3 32-32s-14.3-32-32-32H320l-7.2-14.3C307.4 6.8 296.3 0 284.2 0H163.8c-12.1 0-23.2 6.8-28.6 17.7zM416 128H32L53.2 467c1.6 25.3 22.6 45 47.9 45H346.9c25.3 0 46.3-19.7 47.9-45L416 128z"]
};
var faGear = {
  prefix: "fas",
  iconName: "gear",
  icon: [512, 512, [9881, "cog"], "f013", "M495.9 166.6c3.2 8.7 .5 18.4-6.4 24.6l-43.3 39.4c1.1 8.3 1.7 16.8 1.7 25.4s-.6 17.1-1.7 25.4l43.3 39.4c6.9 6.2 9.6 15.9 6.4 24.6c-4.4 11.9-9.7 23.3-15.8 34.3l-4.7 8.1c-6.6 11-14 21.4-22.1 31.2c-5.9 7.2-15.7 9.6-24.5 6.8l-55.7-17.7c-13.4 10.3-28.2 18.9-44 25.4l-12.5 57.1c-2 9.1-9 16.3-18.2 17.8c-13.8 2.3-28 3.5-42.5 3.5s-28.7-1.2-42.5-3.5c-9.2-1.5-16.2-8.7-18.2-17.8l-12.5-57.1c-15.8-6.5-30.6-15.1-44-25.4L83.1 425.9c-8.8 2.8-18.6 .3-24.5-6.8c-8.1-9.8-15.5-20.2-22.1-31.2l-4.7-8.1c-6.1-11-11.4-22.4-15.8-34.3c-3.2-8.7-.5-18.4 6.4-24.6l43.3-39.4C64.6 273.1 64 264.6 64 256s.6-17.1 1.7-25.4L22.4 191.2c-6.9-6.2-9.6-15.9-6.4-24.6c4.4-11.9 9.7-23.3 15.8-34.3l4.7-8.1c6.6-11 14-21.4 22.1-31.2c5.9-7.2 15.7-9.6 24.5-6.8l55.7 17.7c13.4-10.3 28.2-18.9 44-25.4l12.5-57.1c2-9.1 9-16.3 18.2-17.8C227.3 1.2 241.5 0 256 0s28.7 1.2 42.5 3.5c9.2 1.5 16.2 8.7 18.2 17.8l12.5 57.1c15.8 6.5 30.6 15.1 44 25.4l55.7-17.7c8.8-2.8 18.6-.3 24.5 6.8c8.1 9.8 15.5 20.2 22.1 31.2l4.7 8.1c6.1 11 11.4 22.4 15.8 34.3zM256 336c44.2 0 80-35.8 80-80s-35.8-80-80-80s-80 35.8-80 80s35.8 80 80 80z"]
};
var faCog = faGear;
var faBolt = {
  prefix: "fas",
  iconName: "bolt",
  icon: [448, 512, [9889, "zap"], "f0e7", "M349.4 44.6c5.9-13.7 1.5-29.7-10.6-38.5s-28.6-8-39.9 1.8l-256 224c-10 8.8-13.6 22.9-8.9 35.3S50.7 288 64 288H175.5L98.6 467.4c-5.9 13.7-1.5 29.7 10.6 38.5s28.6 8 39.9-1.8l256-224c10-8.8 13.6-22.9 8.9-35.3s-16.6-20.7-30-20.7H272.5L349.4 44.6z"]
};
var faChevronDown = {
  prefix: "fas",
  iconName: "chevron-down",
  icon: [512, 512, [], "f078", "M233.4 406.6c12.5 12.5 32.8 12.5 45.3 0l192-192c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0L256 338.7 86.6 169.4c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l192 192z"]
};
var faClone = {
  prefix: "fas",
  iconName: "clone",
  icon: [512, 512, [], "f24d", "M0 448c0 35.3 28.7 64 64 64H288c35.3 0 64-28.7 64-64V384H224c-53 0-96-43-96-96V160H64c-35.3 0-64 28.7-64 64V448zm224-96H448c35.3 0 64-28.7 64-64V64c0-35.3-28.7-64-64-64H224c-35.3 0-64 28.7-64 64V288c0 35.3 28.7 64 64 64z"]
};

// node_modules/.pnpm/svelte-awesome@3.0.0_svelte@3.55.1/node_modules/svelte-awesome/components/svg/Path.svelte
function create_fragment(ctx) {
  let path;
  let path_id_value;
  let path_levels = [
    {
      id: path_id_value = "path-" + ctx[0]
    },
    ctx[1]
  ];
  let path_data = {};
  for (let i = 0; i < path_levels.length; i += 1) {
    path_data = assign(path_data, path_levels[i]);
  }
  return {
    c() {
      path = svg_element("path");
      set_svg_attributes(path, path_data);
    },
    m(target, anchor) {
      insert(target, path, anchor);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(path, path_data = get_spread_update(path_levels, [
        dirty & 1 && path_id_value !== (path_id_value = "path-" + ctx2[0]) && { id: path_id_value },
        dirty & 2 && ctx2[1]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(path);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { id } = $$props;
  let { data = {} } = $$props;
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
  };
  return [id, data];
}
var Path = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { id: 0, data: 1 });
  }
};
var Path_default = Path;

// node_modules/.pnpm/svelte-awesome@3.0.0_svelte@3.55.1/node_modules/svelte-awesome/components/svg/Polygon.svelte
function create_fragment2(ctx) {
  let polygon;
  let polygon_id_value;
  let polygon_levels = [
    {
      id: polygon_id_value = "polygon-" + ctx[0]
    },
    ctx[1]
  ];
  let polygon_data = {};
  for (let i = 0; i < polygon_levels.length; i += 1) {
    polygon_data = assign(polygon_data, polygon_levels[i]);
  }
  return {
    c() {
      polygon = svg_element("polygon");
      set_svg_attributes(polygon, polygon_data);
    },
    m(target, anchor) {
      insert(target, polygon, anchor);
    },
    p(ctx2, [dirty]) {
      set_svg_attributes(polygon, polygon_data = get_spread_update(polygon_levels, [
        dirty & 1 && polygon_id_value !== (polygon_id_value = "polygon-" + ctx2[0]) && { id: polygon_id_value },
        dirty & 2 && ctx2[1]
      ]));
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(polygon);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { id } = $$props;
  let { data = {} } = $$props;
  $$self.$$set = ($$props2) => {
    if ("id" in $$props2)
      $$invalidate(0, id = $$props2.id);
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
  };
  return [id, data];
}
var Polygon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { id: 0, data: 1 });
  }
};
var Polygon_default = Polygon;

// node_modules/.pnpm/svelte-awesome@3.0.0_svelte@3.55.1/node_modules/svelte-awesome/components/svg/Raw.svelte
function create_fragment3(ctx) {
  let g;
  return {
    c() {
      g = svg_element("g");
    },
    m(target, anchor) {
      insert(target, g, anchor);
      g.innerHTML = ctx[0];
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        g.innerHTML = ctx2[0];
      ;
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(g);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let cursor = 870711;
  function getId() {
    cursor += 1;
    return `fa-${cursor.toString(16)}`;
  }
  let raw;
  let { data } = $$props;
  function getRaw(data2) {
    if (!data2 || !data2.raw) {
      return null;
    }
    let rawData = data2.raw;
    const ids = {};
    rawData = rawData.replace(/\s(?:xml:)?id=["']?([^"')\s]+)/g, (match, id) => {
      const uniqueId = getId();
      ids[id] = uniqueId;
      return ` id="${uniqueId}"`;
    });
    rawData = rawData.replace(/#(?:([^'")\s]+)|xpointer\(id\((['"]?)([^')]+)\2\)\))/g, (match, rawId, _, pointerId) => {
      const id = rawId || pointerId;
      if (!id || !ids[id]) {
        return match;
      }
      return `#${ids[id]}`;
    });
    return rawData;
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(1, data = $$props2.data);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 2) {
      $:
        $$invalidate(0, raw = getRaw(data));
    }
  };
  return [raw, data];
}
var Raw = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { data: 1 });
  }
};
var Raw_default = Raw;

// node_modules/.pnpm/svelte-awesome@3.0.0_svelte@3.55.1/node_modules/svelte-awesome/components/svg/Svg.svelte
function add_css(target) {
  append_styles(target, "svelte-1dof0an", ".fa-icon.svelte-1dof0an{display:inline-block;fill:currentColor}.fa-flip-horizontal.svelte-1dof0an{transform:scale(-1, 1)}.fa-flip-vertical.svelte-1dof0an{transform:scale(1, -1)}.fa-spin.svelte-1dof0an{animation:svelte-1dof0an-fa-spin 1s 0s infinite linear}.fa-inverse.svelte-1dof0an{color:#fff}.fa-pulse.svelte-1dof0an{animation:svelte-1dof0an-fa-spin 1s infinite steps(8)}@keyframes svelte-1dof0an-fa-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}");
}
function create_fragment4(ctx) {
  let svg;
  let svg_class_value;
  let svg_role_value;
  let current;
  const default_slot_template = ctx[13].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[12], null);
  return {
    c() {
      svg = svg_element("svg");
      if (default_slot)
        default_slot.c();
      attr(svg, "version", "1.1");
      attr(svg, "class", svg_class_value = "fa-icon " + ctx[0] + " svelte-1dof0an");
      attr(svg, "x", ctx[8]);
      attr(svg, "y", ctx[9]);
      attr(svg, "width", ctx[1]);
      attr(svg, "height", ctx[2]);
      attr(svg, "aria-label", ctx[11]);
      attr(svg, "role", svg_role_value = ctx[11] ? "img" : "presentation");
      attr(svg, "viewBox", ctx[3]);
      attr(svg, "style", ctx[10]);
      toggle_class(svg, "fa-spin", ctx[4]);
      toggle_class(svg, "fa-pulse", ctx[6]);
      toggle_class(svg, "fa-inverse", ctx[5]);
      toggle_class(svg, "fa-flip-horizontal", ctx[7] === "horizontal");
      toggle_class(svg, "fa-flip-vertical", ctx[7] === "vertical");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      if (default_slot) {
        default_slot.m(svg, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[12],
            !current ? get_all_dirty_from_scope(ctx2[12]) : get_slot_changes(default_slot_template, ctx2[12], dirty, null),
            null
          );
        }
      }
      if (!current || dirty & 1 && svg_class_value !== (svg_class_value = "fa-icon " + ctx2[0] + " svelte-1dof0an")) {
        attr(svg, "class", svg_class_value);
      }
      if (!current || dirty & 256) {
        attr(svg, "x", ctx2[8]);
      }
      if (!current || dirty & 512) {
        attr(svg, "y", ctx2[9]);
      }
      if (!current || dirty & 2) {
        attr(svg, "width", ctx2[1]);
      }
      if (!current || dirty & 4) {
        attr(svg, "height", ctx2[2]);
      }
      if (!current || dirty & 2048) {
        attr(svg, "aria-label", ctx2[11]);
      }
      if (!current || dirty & 2048 && svg_role_value !== (svg_role_value = ctx2[11] ? "img" : "presentation")) {
        attr(svg, "role", svg_role_value);
      }
      if (!current || dirty & 8) {
        attr(svg, "viewBox", ctx2[3]);
      }
      if (!current || dirty & 1024) {
        attr(svg, "style", ctx2[10]);
      }
      if (!current || dirty & 17) {
        toggle_class(svg, "fa-spin", ctx2[4]);
      }
      if (!current || dirty & 65) {
        toggle_class(svg, "fa-pulse", ctx2[6]);
      }
      if (!current || dirty & 33) {
        toggle_class(svg, "fa-inverse", ctx2[5]);
      }
      if (!current || dirty & 129) {
        toggle_class(svg, "fa-flip-horizontal", ctx2[7] === "horizontal");
      }
      if (!current || dirty & 129) {
        toggle_class(svg, "fa-flip-vertical", ctx2[7] === "vertical");
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(svg);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { class: className } = $$props;
  let { width } = $$props;
  let { height } = $$props;
  let { box } = $$props;
  let { spin = false } = $$props;
  let { inverse = false } = $$props;
  let { pulse = false } = $$props;
  let { flip: flip2 = null } = $$props;
  let { x = void 0 } = $$props;
  let { y = void 0 } = $$props;
  let { style = void 0 } = $$props;
  let { label = void 0 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(0, className = $$props2.class);
    if ("width" in $$props2)
      $$invalidate(1, width = $$props2.width);
    if ("height" in $$props2)
      $$invalidate(2, height = $$props2.height);
    if ("box" in $$props2)
      $$invalidate(3, box = $$props2.box);
    if ("spin" in $$props2)
      $$invalidate(4, spin = $$props2.spin);
    if ("inverse" in $$props2)
      $$invalidate(5, inverse = $$props2.inverse);
    if ("pulse" in $$props2)
      $$invalidate(6, pulse = $$props2.pulse);
    if ("flip" in $$props2)
      $$invalidate(7, flip2 = $$props2.flip);
    if ("x" in $$props2)
      $$invalidate(8, x = $$props2.x);
    if ("y" in $$props2)
      $$invalidate(9, y = $$props2.y);
    if ("style" in $$props2)
      $$invalidate(10, style = $$props2.style);
    if ("label" in $$props2)
      $$invalidate(11, label = $$props2.label);
    if ("$$scope" in $$props2)
      $$invalidate(12, $$scope = $$props2.$$scope);
  };
  return [
    className,
    width,
    height,
    box,
    spin,
    inverse,
    pulse,
    flip2,
    x,
    y,
    style,
    label,
    $$scope,
    slots
  ];
}
var Svg = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        class: 0,
        width: 1,
        height: 2,
        box: 3,
        spin: 4,
        inverse: 5,
        pulse: 6,
        flip: 7,
        x: 8,
        y: 9,
        style: 10,
        label: 11
      },
      add_css
    );
  }
};
var Svg_default = Svg;

// node_modules/.pnpm/svelte-awesome@3.0.0_svelte@3.55.1/node_modules/svelte-awesome/components/Icon.svelte
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[24] = list[i];
  child_ctx[26] = i;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i];
  child_ctx[26] = i;
  return child_ctx;
}
function create_if_block(ctx) {
  let t0;
  let t1;
  let if_block2_anchor;
  let current;
  let if_block0 = ctx[6].paths && create_if_block_3(ctx);
  let if_block1 = ctx[6].polygons && create_if_block_2(ctx);
  let if_block2 = ctx[6].raw && create_if_block_1(ctx);
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      if_block2_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, if_block2_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[6].paths) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_3(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[6].polygons) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (ctx2[6].raw) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (if_block0)
        if_block0.d(detaching);
      if (detaching)
        detach(t0);
      if (if_block1)
        if_block1.d(detaching);
      if (detaching)
        detach(t1);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(if_block2_anchor);
    }
  };
}
function create_if_block_3(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ctx[6].paths;
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 64) {
        each_value_1 = ctx2[6].paths;
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block_1(ctx) {
  let path;
  let current;
  path = new Path_default({
    props: {
      id: ctx[26],
      data: ctx[27]
    }
  });
  return {
    c() {
      create_component(path.$$.fragment);
    },
    m(target, anchor) {
      mount_component(path, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const path_changes = {};
      if (dirty & 64)
        path_changes.data = ctx2[27];
      path.$set(path_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(path.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(path.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(path, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ctx[6].polygons;
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 64) {
        each_value = ctx2[6].polygons;
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block(ctx) {
  let polygon;
  let current;
  polygon = new Polygon_default({
    props: {
      id: ctx[26],
      data: ctx[24]
    }
  });
  return {
    c() {
      create_component(polygon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(polygon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const polygon_changes = {};
      if (dirty & 64)
        polygon_changes.data = ctx2[24];
      polygon.$set(polygon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(polygon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(polygon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(polygon, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let raw;
  let updating_data;
  let current;
  function raw_data_binding(value) {
    ctx[15](value);
  }
  let raw_props = {};
  if (ctx[6] !== void 0) {
    raw_props.data = ctx[6];
  }
  raw = new Raw_default({ props: raw_props });
  binding_callbacks.push(() => bind(raw, "data", raw_data_binding));
  return {
    c() {
      create_component(raw.$$.fragment);
    },
    m(target, anchor) {
      mount_component(raw, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const raw_changes = {};
      if (!updating_data && dirty & 64) {
        updating_data = true;
        raw_changes.data = ctx2[6];
        add_flush_callback(() => updating_data = false);
      }
      raw.$set(raw_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(raw.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(raw.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(raw, detaching);
    }
  };
}
function fallback_block(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[6] && create_if_block(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (ctx2[6]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_default_slot(ctx) {
  let current;
  const default_slot_template = ctx[14].default;
  const default_slot = create_slot(default_slot_template, ctx, ctx[16], null);
  const default_slot_or_fallback = default_slot || fallback_block(ctx);
  return {
    c() {
      if (default_slot_or_fallback)
        default_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (default_slot_or_fallback) {
        default_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & 65536)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            ctx2[16],
            !current ? get_all_dirty_from_scope(ctx2[16]) : get_slot_changes(default_slot_template, ctx2[16], dirty, null),
            null
          );
        }
      } else {
        if (default_slot_or_fallback && default_slot_or_fallback.p && (!current || dirty & 64)) {
          default_slot_or_fallback.p(ctx2, !current ? -1 : dirty);
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (default_slot_or_fallback)
        default_slot_or_fallback.d(detaching);
    }
  };
}
function create_fragment5(ctx) {
  let svg;
  let current;
  svg = new Svg_default({
    props: {
      label: ctx[5],
      width: ctx[7],
      height: ctx[8],
      box: ctx[10],
      style: ctx[9],
      spin: ctx[1],
      flip: ctx[4],
      inverse: ctx[2],
      pulse: ctx[3],
      class: ctx[0],
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(svg.$$.fragment);
    },
    m(target, anchor) {
      mount_component(svg, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const svg_changes = {};
      if (dirty & 32)
        svg_changes.label = ctx2[5];
      if (dirty & 128)
        svg_changes.width = ctx2[7];
      if (dirty & 256)
        svg_changes.height = ctx2[8];
      if (dirty & 1024)
        svg_changes.box = ctx2[10];
      if (dirty & 512)
        svg_changes.style = ctx2[9];
      if (dirty & 2)
        svg_changes.spin = ctx2[1];
      if (dirty & 16)
        svg_changes.flip = ctx2[4];
      if (dirty & 4)
        svg_changes.inverse = ctx2[2];
      if (dirty & 8)
        svg_changes.pulse = ctx2[3];
      if (dirty & 1)
        svg_changes.class = ctx2[0];
      if (dirty & 65600) {
        svg_changes.$$scope = { dirty, ctx: ctx2 };
      }
      svg.$set(svg_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(svg.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(svg.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(svg, detaching);
    }
  };
}
var childrenHeight = 0;
var childrenWidth = 0;
var outerScale = 1;
function normaliseData(data) {
  if ("iconName" in data && "icon" in data) {
    let normalisedData = {};
    let faIcon = data.icon;
    let name = data.iconName;
    let width = faIcon[0];
    let height = faIcon[1];
    let paths = faIcon[4];
    let iconData = { width, height, paths: [{ d: paths }] };
    normalisedData[name] = iconData;
    return normalisedData;
  }
  return data;
}
function instance5($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { class: className = "" } = $$props;
  let { data } = $$props;
  let { scale = 1 } = $$props;
  let { spin = false } = $$props;
  let { inverse = false } = $$props;
  let { pulse = false } = $$props;
  let { flip: flip2 = null } = $$props;
  let { label = null } = $$props;
  let self2 = null;
  let { style = null } = $$props;
  let width;
  let height;
  let combinedStyle;
  let box;
  function init2() {
    if (typeof data === "undefined") {
      return;
    }
    const normalisedData = normaliseData(data);
    const [name] = Object.keys(normalisedData);
    const icon = normalisedData[name];
    if (!icon.paths) {
      icon.paths = [];
    }
    if (icon.d) {
      icon.paths.push({ d: icon.d });
    }
    if (!icon.polygons) {
      icon.polygons = [];
    }
    if (icon.points) {
      icon.polygons.push({ points: icon.points });
    }
    $$invalidate(6, self2 = icon);
  }
  function normalisedScale() {
    let numScale = 1;
    if (typeof scale !== "undefined") {
      numScale = Number(scale);
    }
    if (isNaN(numScale) || numScale <= 0) {
      console.warn('Invalid prop: prop "scale" should be a number over 0.');
      return outerScale;
    }
    return numScale * outerScale;
  }
  function calculateBox() {
    if (self2) {
      return `0 0 ${self2.width} ${self2.height}`;
    }
    return `0 0 ${width} ${height}`;
  }
  function calculateRatio() {
    if (!self2) {
      return 1;
    }
    return Math.max(self2.width, self2.height) / 16;
  }
  function calculateWidth() {
    if (childrenWidth) {
      return childrenWidth;
    }
    if (self2) {
      return self2.width / calculateRatio() * normalisedScale();
    }
    return 0;
  }
  function calculateHeight() {
    if (childrenHeight) {
      return childrenHeight;
    }
    if (self2) {
      return self2.height / calculateRatio() * normalisedScale();
    }
    return 0;
  }
  function calculateStyle() {
    let combined = "";
    if (style !== null) {
      combined += style;
    }
    let size = normalisedScale();
    if (size === 1) {
      if (combined.length === 0) {
        return void 0;
      }
      return combined;
    }
    if (combined !== "" && !combined.endsWith(";")) {
      combined += "; ";
    }
    return `${combined}font-size: ${size}em`;
  }
  function raw_data_binding(value) {
    self2 = value;
    $$invalidate(6, self2);
  }
  $$self.$$set = ($$props2) => {
    if ("class" in $$props2)
      $$invalidate(0, className = $$props2.class);
    if ("data" in $$props2)
      $$invalidate(11, data = $$props2.data);
    if ("scale" in $$props2)
      $$invalidate(12, scale = $$props2.scale);
    if ("spin" in $$props2)
      $$invalidate(1, spin = $$props2.spin);
    if ("inverse" in $$props2)
      $$invalidate(2, inverse = $$props2.inverse);
    if ("pulse" in $$props2)
      $$invalidate(3, pulse = $$props2.pulse);
    if ("flip" in $$props2)
      $$invalidate(4, flip2 = $$props2.flip);
    if ("label" in $$props2)
      $$invalidate(5, label = $$props2.label);
    if ("style" in $$props2)
      $$invalidate(13, style = $$props2.style);
    if ("$$scope" in $$props2)
      $$invalidate(16, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 14336) {
      $: {
        data;
        style;
        scale;
        init2();
        $$invalidate(7, width = calculateWidth());
        $$invalidate(8, height = calculateHeight());
        $$invalidate(9, combinedStyle = calculateStyle());
        $$invalidate(10, box = calculateBox());
      }
    }
  };
  return [
    className,
    spin,
    inverse,
    pulse,
    flip2,
    label,
    self2,
    width,
    height,
    combinedStyle,
    box,
    data,
    scale,
    style,
    slots,
    raw_data_binding,
    $$scope
  ];
}
var Icon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance5, create_fragment5, safe_not_equal, {
      class: 0,
      data: 11,
      scale: 12,
      spin: 1,
      inverse: 2,
      pulse: 3,
      flip: 4,
      label: 5,
      style: 13
    });
  }
};
var Icon_default = Icon;

// src/gui/choiceList/ChoiceItemRightButtons.svelte
function add_css2(target) {
  append_styles(target, "svelte-a47k80", ".rightButtonsContainer.svelte-a47k80{display:flex;align-items:center;gap:8px}.clickable.svelte-a47k80:hover{cursor:pointer}.alignIconInDivInMiddle.svelte-a47k80{display:flex;align-items:center}");
}
function create_if_block_12(ctx) {
  let div;
  let icon;
  let div_aria_label_value;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({ props: { data: faCog } });
  return {
    c() {
      div = element("div");
      create_component(icon.$$.fragment);
      attr(div, "class", "alignIconInDivInMiddle clickable svelte-a47k80");
      attr(div, "aria-label", div_aria_label_value = `Configure${ctx[4] ? " " + ctx[4] : ""}`);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(icon, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(div, "click", ctx[6]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & 16 && div_aria_label_value !== (div_aria_label_value = `Configure${ctx2[4] ? " " + ctx2[4] : ""}`)) {
        attr(div, "aria-label", div_aria_label_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block2(ctx) {
  let div;
  let icon;
  let div_aria_label_value;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({ props: { data: faClone } });
  return {
    c() {
      var _a;
      div = element("div");
      create_component(icon.$$.fragment);
      attr(div, "aria-label", div_aria_label_value = `Duplicate ${(_a = ctx[4]) != null ? _a : ""}`);
      attr(div, "class", "alignIconInDivInMiddle clickable svelte-a47k80");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(icon, div, null);
      current = true;
      if (!mounted) {
        dispose = listen(div, "click", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a;
      if (!current || dirty & 16 && div_aria_label_value !== (div_aria_label_value = `Duplicate ${(_a = ctx2[4]) != null ? _a : ""}`)) {
        attr(div, "aria-label", div_aria_label_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment6(ctx) {
  let div3;
  let div0;
  let icon0;
  let div0_aria_label_value;
  let div0_style_value;
  let t0;
  let t1;
  let t2;
  let div1;
  let icon1;
  let div1_aria_label_value;
  let t3;
  let div2;
  let icon2;
  let div2_tabindex_value;
  let div2_style_value;
  let current;
  let mounted;
  let dispose;
  icon0 = new Icon_default({ props: { data: faBolt } });
  let if_block0 = ctx[1] && create_if_block_12(ctx);
  let if_block1 = ctx[2] && create_if_block2(ctx);
  icon1 = new Icon_default({ props: { data: faTrash } });
  icon2 = new Icon_default({ props: { data: faBars } });
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      create_component(icon0.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div1 = element("div");
      create_component(icon1.$$.fragment);
      t3 = space();
      div2 = element("div");
      create_component(icon2.$$.fragment);
      attr(div0, "class", "alignIconInDivInMiddle clickable svelte-a47k80");
      attr(div0, "aria-label", div0_aria_label_value = `${ctx[3] ? "Remove" : "Add"} command${ctx[4] ? " for " + ctx[4] : ""}`);
      attr(div0, "style", div0_style_value = ctx[3] ? "color: #FDD023;" : "");
      attr(div1, "aria-label", div1_aria_label_value = `Delete${ctx[4] ? " " + ctx[4] : ""}`);
      attr(div1, "class", "alignIconInDivInMiddle clickable svelte-a47k80");
      attr(div2, "tabindex", div2_tabindex_value = ctx[0] ? 0 : -1);
      attr(div2, "aria-label", "Drag-handle");
      attr(div2, "style", div2_style_value = (ctx[0] ? "cursor: grab" : "cursor: grabbing") + ";");
      attr(div2, "class", "alignIconInDivInMiddle svelte-a47k80");
      attr(div3, "class", "rightButtonsContainer svelte-a47k80");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      mount_component(icon0, div0, null);
      append(div3, t0);
      if (if_block0)
        if_block0.m(div3, null);
      append(div3, t1);
      if (if_block1)
        if_block1.m(div3, null);
      append(div3, t2);
      append(div3, div1);
      mount_component(icon1, div1, null);
      append(div3, t3);
      append(div3, div2);
      mount_component(icon2, div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "click", ctx[7]),
          listen(div1, "click", ctx[5]),
          listen(div2, "mousedown", ctx[9]),
          listen(div2, "touchstart", ctx[10])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & 24 && div0_aria_label_value !== (div0_aria_label_value = `${ctx2[3] ? "Remove" : "Add"} command${ctx2[4] ? " for " + ctx2[4] : ""}`)) {
        attr(div0, "aria-label", div0_aria_label_value);
      }
      if (!current || dirty & 8 && div0_style_value !== (div0_style_value = ctx2[3] ? "color: #FDD023;" : "")) {
        attr(div0, "style", div0_style_value);
      }
      if (ctx2[1]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & 2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div3, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (ctx2[2]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & 4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div3, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & 16 && div1_aria_label_value !== (div1_aria_label_value = `Delete${ctx2[4] ? " " + ctx2[4] : ""}`)) {
        attr(div1, "aria-label", div1_aria_label_value);
      }
      if (!current || dirty & 1 && div2_tabindex_value !== (div2_tabindex_value = ctx2[0] ? 0 : -1)) {
        attr(div2, "tabindex", div2_tabindex_value);
      }
      if (!current || dirty & 1 && div2_style_value !== (div2_style_value = (ctx2[0] ? "cursor: grab" : "cursor: grabbing") + ";")) {
        attr(div2, "style", div2_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(icon1.$$.fragment, local);
      transition_in(icon2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(icon1.$$.fragment, local);
      transition_out(icon2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div3);
      destroy_component(icon0);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_component(icon1);
      destroy_component(icon2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let { dragDisabled } = $$props;
  let { showConfigureButton = true } = $$props;
  let { showDuplicateButton = true } = $$props;
  let { commandEnabled = false } = $$props;
  let { choiceName = "" } = $$props;
  const dispatcher = createEventDispatcher();
  function emitDeleteChoice() {
    dispatcher("deleteChoice");
  }
  function emitConfigureChoice() {
    dispatcher("configureChoice");
  }
  function emitToggleCommand() {
    dispatcher("toggleCommand");
  }
  function emitDuplicateChoice() {
    dispatcher("duplicateChoice");
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("dragDisabled" in $$props2)
      $$invalidate(0, dragDisabled = $$props2.dragDisabled);
    if ("showConfigureButton" in $$props2)
      $$invalidate(1, showConfigureButton = $$props2.showConfigureButton);
    if ("showDuplicateButton" in $$props2)
      $$invalidate(2, showDuplicateButton = $$props2.showDuplicateButton);
    if ("commandEnabled" in $$props2)
      $$invalidate(3, commandEnabled = $$props2.commandEnabled);
    if ("choiceName" in $$props2)
      $$invalidate(4, choiceName = $$props2.choiceName);
  };
  return [
    dragDisabled,
    showConfigureButton,
    showDuplicateButton,
    commandEnabled,
    choiceName,
    emitDeleteChoice,
    emitConfigureChoice,
    emitToggleCommand,
    emitDuplicateChoice,
    mousedown_handler,
    touchstart_handler
  ];
}
var ChoiceItemRightButtons = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        dragDisabled: 0,
        showConfigureButton: 1,
        showDuplicateButton: 2,
        commandEnabled: 3,
        choiceName: 4
      },
      add_css2
    );
  }
};
var ChoiceItemRightButtons_default = ChoiceItemRightButtons;

// src/gui/choiceList/ChoiceListItem.svelte
function add_css3(target) {
  append_styles(target, "svelte-1vcfikc", ".choiceListItem.svelte-1vcfikc{display:flex;font-size:16px;align-items:center;margin:12px 0 0 0;transition:1000ms ease-in-out}.choiceListItemName.svelte-1vcfikc{flex:1 0 0}");
}
function create_fragment7(ctx) {
  let div;
  let span;
  let t0_value = ctx[0].name + "";
  let t0;
  let t1;
  let rightbuttons;
  let updating_choiceName;
  let updating_commandEnabled;
  let updating_showConfigureButton;
  let updating_dragDisabled;
  let current;
  function rightbuttons_choiceName_binding(value) {
    ctx[7](value);
  }
  function rightbuttons_commandEnabled_binding(value) {
    ctx[8](value);
  }
  function rightbuttons_showConfigureButton_binding(value) {
    ctx[9](value);
  }
  function rightbuttons_dragDisabled_binding(value) {
    ctx[10](value);
  }
  let rightbuttons_props = { showDuplicateButton: true };
  if (ctx[0].name !== void 0) {
    rightbuttons_props.choiceName = ctx[0].name;
  }
  if (ctx[0].command !== void 0) {
    rightbuttons_props.commandEnabled = ctx[0].command;
  }
  if (ctx[2] !== void 0) {
    rightbuttons_props.showConfigureButton = ctx[2];
  }
  if (ctx[1] !== void 0) {
    rightbuttons_props.dragDisabled = ctx[1];
  }
  rightbuttons = new ChoiceItemRightButtons_default({ props: rightbuttons_props });
  binding_callbacks.push(() => bind(rightbuttons, "choiceName", rightbuttons_choiceName_binding));
  binding_callbacks.push(() => bind(rightbuttons, "commandEnabled", rightbuttons_commandEnabled_binding));
  binding_callbacks.push(() => bind(rightbuttons, "showConfigureButton", rightbuttons_showConfigureButton_binding));
  binding_callbacks.push(() => bind(rightbuttons, "dragDisabled", rightbuttons_dragDisabled_binding));
  rightbuttons.$on("mousedown", ctx[11]);
  rightbuttons.$on("touchstart", ctx[12]);
  rightbuttons.$on("deleteChoice", ctx[3]);
  rightbuttons.$on("configureChoice", ctx[4]);
  rightbuttons.$on("toggleCommand", ctx[5]);
  rightbuttons.$on("duplicateChoice", ctx[6]);
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      create_component(rightbuttons.$$.fragment);
      attr(span, "class", "choiceListItemName svelte-1vcfikc");
      attr(div, "class", "choiceListItem svelte-1vcfikc");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      append(span, t0);
      append(div, t1);
      mount_component(rightbuttons, div, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx2[0].name + ""))
        set_data(t0, t0_value);
      const rightbuttons_changes = {};
      if (!updating_choiceName && dirty & 1) {
        updating_choiceName = true;
        rightbuttons_changes.choiceName = ctx2[0].name;
        add_flush_callback(() => updating_choiceName = false);
      }
      if (!updating_commandEnabled && dirty & 1) {
        updating_commandEnabled = true;
        rightbuttons_changes.commandEnabled = ctx2[0].command;
        add_flush_callback(() => updating_commandEnabled = false);
      }
      if (!updating_showConfigureButton && dirty & 4) {
        updating_showConfigureButton = true;
        rightbuttons_changes.showConfigureButton = ctx2[2];
        add_flush_callback(() => updating_showConfigureButton = false);
      }
      if (!updating_dragDisabled && dirty & 2) {
        updating_dragDisabled = true;
        rightbuttons_changes.dragDisabled = ctx2[1];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      rightbuttons.$set(rightbuttons_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(rightbuttons.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(rightbuttons.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(rightbuttons);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { choice } = $$props;
  let { dragDisabled } = $$props;
  let showConfigureButton = true;
  const dispatcher = createEventDispatcher();
  function deleteChoice() {
    dispatcher("deleteChoice", { choice });
  }
  function configureChoice() {
    dispatcher("configureChoice", { choice });
  }
  function toggleCommandForChoice() {
    dispatcher("toggleCommand", { choice });
  }
  function duplicateChoice() {
    dispatcher("duplicateChoice", { choice });
  }
  function rightbuttons_choiceName_binding(value) {
    if ($$self.$$.not_equal(choice.name, value)) {
      choice.name = value;
      $$invalidate(0, choice);
    }
  }
  function rightbuttons_commandEnabled_binding(value) {
    if ($$self.$$.not_equal(choice.command, value)) {
      choice.command = value;
      $$invalidate(0, choice);
    }
  }
  function rightbuttons_showConfigureButton_binding(value) {
    showConfigureButton = value;
    $$invalidate(2, showConfigureButton);
  }
  function rightbuttons_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(1, dragDisabled);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("choice" in $$props2)
      $$invalidate(0, choice = $$props2.choice);
    if ("dragDisabled" in $$props2)
      $$invalidate(1, dragDisabled = $$props2.dragDisabled);
  };
  return [
    choice,
    dragDisabled,
    showConfigureButton,
    deleteChoice,
    configureChoice,
    toggleCommandForChoice,
    duplicateChoice,
    rightbuttons_choiceName_binding,
    rightbuttons_commandEnabled_binding,
    rightbuttons_showConfigureButton_binding,
    rightbuttons_dragDisabled_binding,
    mousedown_handler,
    touchstart_handler
  ];
}
var ChoiceListItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, { choice: 0, dragDisabled: 1 }, add_css3);
  }
};
var ChoiceListItem_default = ChoiceListItem;

// src/gui/choiceList/MultiChoiceListItem.svelte
function add_css4(target) {
  append_styles(target, "svelte-na99np", ".multiChoiceListItem.svelte-na99np{display:flex;font-size:16px;align-items:center;margin:12px 0 0 0}.clickable.svelte-na99np:hover{cursor:pointer}.multiChoiceListItemName.svelte-na99np{flex:1 0 0;margin-left:5px}.nestedChoiceList.svelte-na99np{padding-left:25px}");
}
function create_if_block3(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !ctx[0].collapsed && create_if_block_13(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (!ctx2[0].collapsed) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_if_block_13(ctx) {
  let div;
  let choicelist;
  let updating_multiChoice;
  let updating_choices;
  let current;
  function choicelist_multiChoice_binding(value) {
    ctx[15](value);
  }
  function choicelist_choices_binding(value) {
    ctx[16](value);
  }
  let choicelist_props = {};
  if (ctx[0] !== void 0) {
    choicelist_props.multiChoice = ctx[0];
  }
  if (ctx[0].choices !== void 0) {
    choicelist_props.choices = ctx[0].choices;
  }
  choicelist = new ChoiceList_default({ props: choicelist_props });
  binding_callbacks.push(() => bind(choicelist, "multiChoice", choicelist_multiChoice_binding));
  binding_callbacks.push(() => bind(choicelist, "choices", choicelist_choices_binding));
  choicelist.$on("deleteChoice", ctx[17]);
  choicelist.$on("configureChoice", ctx[18]);
  choicelist.$on("toggleCommand", ctx[19]);
  choicelist.$on("duplicateChoice", ctx[20]);
  return {
    c() {
      div = element("div");
      create_component(choicelist.$$.fragment);
      attr(div, "class", "nestedChoiceList svelte-na99np");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(choicelist, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const choicelist_changes = {};
      if (!updating_multiChoice && dirty & 1) {
        updating_multiChoice = true;
        choicelist_changes.multiChoice = ctx2[0];
        add_flush_callback(() => updating_multiChoice = false);
      }
      if (!updating_choices && dirty & 1) {
        updating_choices = true;
        choicelist_changes.choices = ctx2[0].choices;
        add_flush_callback(() => updating_choices = false);
      }
      choicelist.$set(choicelist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(choicelist.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(choicelist.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(choicelist);
    }
  };
}
function create_fragment8(ctx) {
  let div2;
  let div1;
  let div0;
  let icon;
  let t0;
  let span;
  let t1_value = ctx[0].name + "";
  let t1;
  let t2;
  let rightbuttons;
  let updating_showConfigureButton;
  let updating_dragDisabled;
  let updating_choiceName;
  let updating_commandEnabled;
  let t3;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({
    props: {
      data: faChevronDown,
      style: `transform:rotate(${ctx[0].collapsed ? -180 : 0}deg)`
    }
  });
  function rightbuttons_showConfigureButton_binding(value) {
    ctx[9](value);
  }
  function rightbuttons_dragDisabled_binding(value) {
    ctx[10](value);
  }
  function rightbuttons_choiceName_binding(value) {
    ctx[11](value);
  }
  function rightbuttons_commandEnabled_binding(value) {
    ctx[12](value);
  }
  let rightbuttons_props = { showDuplicateButton: true };
  if (ctx[3] !== void 0) {
    rightbuttons_props.showConfigureButton = ctx[3];
  }
  if (ctx[1] !== void 0) {
    rightbuttons_props.dragDisabled = ctx[1];
  }
  if (ctx[0].name !== void 0) {
    rightbuttons_props.choiceName = ctx[0].name;
  }
  if (ctx[0].command !== void 0) {
    rightbuttons_props.commandEnabled = ctx[0].command;
  }
  rightbuttons = new ChoiceItemRightButtons_default({ props: rightbuttons_props });
  binding_callbacks.push(() => bind(rightbuttons, "showConfigureButton", rightbuttons_showConfigureButton_binding));
  binding_callbacks.push(() => bind(rightbuttons, "dragDisabled", rightbuttons_dragDisabled_binding));
  binding_callbacks.push(() => bind(rightbuttons, "choiceName", rightbuttons_choiceName_binding));
  binding_callbacks.push(() => bind(rightbuttons, "commandEnabled", rightbuttons_commandEnabled_binding));
  rightbuttons.$on("mousedown", ctx[13]);
  rightbuttons.$on("touchstart", ctx[14]);
  rightbuttons.$on("deleteChoice", ctx[4]);
  rightbuttons.$on("configureChoice", ctx[5]);
  rightbuttons.$on("toggleCommand", ctx[6]);
  rightbuttons.$on("duplicateChoice", ctx[7]);
  let if_block = (!ctx[2] || ctx[2] && ctx[0].id !== ctx[2]) && create_if_block3(ctx);
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      create_component(icon.$$.fragment);
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      create_component(rightbuttons.$$.fragment);
      t3 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "multiChoiceListItemName clickable svelte-na99np");
      attr(div1, "class", "multiChoiceListItem svelte-na99np");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      mount_component(icon, div0, null);
      append(div0, t0);
      append(div0, span);
      append(span, t1);
      append(div1, t2);
      mount_component(rightbuttons, div1, null);
      append(div2, t3);
      if (if_block)
        if_block.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = listen(div0, "click", ctx[8]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const icon_changes = {};
      if (dirty & 1)
        icon_changes.style = `transform:rotate(${ctx2[0].collapsed ? -180 : 0}deg)`;
      icon.$set(icon_changes);
      if ((!current || dirty & 1) && t1_value !== (t1_value = ctx2[0].name + ""))
        set_data(t1, t1_value);
      const rightbuttons_changes = {};
      if (!updating_showConfigureButton && dirty & 8) {
        updating_showConfigureButton = true;
        rightbuttons_changes.showConfigureButton = ctx2[3];
        add_flush_callback(() => updating_showConfigureButton = false);
      }
      if (!updating_dragDisabled && dirty & 2) {
        updating_dragDisabled = true;
        rightbuttons_changes.dragDisabled = ctx2[1];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      if (!updating_choiceName && dirty & 1) {
        updating_choiceName = true;
        rightbuttons_changes.choiceName = ctx2[0].name;
        add_flush_callback(() => updating_choiceName = false);
      }
      if (!updating_commandEnabled && dirty & 1) {
        updating_commandEnabled = true;
        rightbuttons_changes.commandEnabled = ctx2[0].command;
        add_flush_callback(() => updating_commandEnabled = false);
      }
      rightbuttons.$set(rightbuttons_changes);
      if (!ctx2[2] || ctx2[2] && ctx2[0].id !== ctx2[2]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      transition_in(rightbuttons.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      transition_out(rightbuttons.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div2);
      destroy_component(icon);
      destroy_component(rightbuttons);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { choice } = $$props;
  let { collapseId } = $$props;
  let { dragDisabled } = $$props;
  let showConfigureButton = true;
  const dispatcher = createEventDispatcher();
  function deleteChoice(e) {
    dispatcher("deleteChoice", { choice });
  }
  function configureChoice() {
    dispatcher("configureChoice", { choice });
  }
  function toggleCommandForChoice() {
    dispatcher("toggleCommand", { choice });
  }
  function duplicateChoice() {
    dispatcher("duplicateChoice", { choice });
  }
  const click_handler = () => $$invalidate(0, choice.collapsed = !choice.collapsed, choice);
  function rightbuttons_showConfigureButton_binding(value) {
    showConfigureButton = value;
    $$invalidate(3, showConfigureButton);
  }
  function rightbuttons_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(1, dragDisabled);
  }
  function rightbuttons_choiceName_binding(value) {
    if ($$self.$$.not_equal(choice.name, value)) {
      choice.name = value;
      $$invalidate(0, choice);
    }
  }
  function rightbuttons_commandEnabled_binding(value) {
    if ($$self.$$.not_equal(choice.command, value)) {
      choice.command = value;
      $$invalidate(0, choice);
    }
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function touchstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function choicelist_multiChoice_binding(value) {
    choice = value;
    $$invalidate(0, choice);
  }
  function choicelist_choices_binding(value) {
    if ($$self.$$.not_equal(choice.choices, value)) {
      choice.choices = value;
      $$invalidate(0, choice);
    }
  }
  function deleteChoice_handler(event) {
    bubble.call(this, $$self, event);
  }
  function configureChoice_handler(event) {
    bubble.call(this, $$self, event);
  }
  function toggleCommand_handler(event) {
    bubble.call(this, $$self, event);
  }
  function duplicateChoice_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("choice" in $$props2)
      $$invalidate(0, choice = $$props2.choice);
    if ("collapseId" in $$props2)
      $$invalidate(2, collapseId = $$props2.collapseId);
    if ("dragDisabled" in $$props2)
      $$invalidate(1, dragDisabled = $$props2.dragDisabled);
  };
  return [
    choice,
    dragDisabled,
    collapseId,
    showConfigureButton,
    deleteChoice,
    configureChoice,
    toggleCommandForChoice,
    duplicateChoice,
    click_handler,
    rightbuttons_showConfigureButton_binding,
    rightbuttons_dragDisabled_binding,
    rightbuttons_choiceName_binding,
    rightbuttons_commandEnabled_binding,
    mousedown_handler,
    touchstart_handler,
    choicelist_multiChoice_binding,
    choicelist_choices_binding,
    deleteChoice_handler,
    configureChoice_handler,
    toggleCommand_handler,
    duplicateChoice_handler
  ];
}
var MultiChoiceListItem = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance8,
      create_fragment8,
      safe_not_equal,
      {
        choice: 0,
        collapseId: 2,
        dragDisabled: 1
      },
      add_css4
    );
  }
};
var MultiChoiceListItem_default = MultiChoiceListItem;

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.55.1/node_modules/svelte-dnd-action/src/helpers/dispatcher.js
var FINALIZE_EVENT_NAME = "finalize";
var CONSIDER_EVENT_NAME = "consider";
function dispatchFinalizeEvent(el, items, info) {
  el.dispatchEvent(
    new CustomEvent(FINALIZE_EVENT_NAME, {
      detail: { items, info }
    })
  );
}
function dispatchConsiderEvent(el, items, info) {
  el.dispatchEvent(
    new CustomEvent(CONSIDER_EVENT_NAME, {
      detail: { items, info }
    })
  );
}
var DRAGGED_ENTERED_EVENT_NAME = "draggedEntered";
var DRAGGED_LEFT_EVENT_NAME = "draggedLeft";
var DRAGGED_OVER_INDEX_EVENT_NAME = "draggedOverIndex";
var DRAGGED_LEFT_DOCUMENT_EVENT_NAME = "draggedLeftDocument";
var DRAGGED_LEFT_TYPES = {
  LEFT_FOR_ANOTHER: "leftForAnother",
  OUTSIDE_OF_ANY: "outsideOfAny"
};
function dispatchDraggedElementEnteredContainer(containerEl, indexObj, draggedEl2) {
  containerEl.dispatchEvent(
    new CustomEvent(DRAGGED_ENTERED_EVENT_NAME, {
      detail: { indexObj, draggedEl: draggedEl2 }
    })
  );
}
function dispatchDraggedElementLeftContainerForAnother(containerEl, draggedEl2, theOtherDz) {
  containerEl.dispatchEvent(
    new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {
      detail: { draggedEl: draggedEl2, type: DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER, theOtherDz }
    })
  );
}
function dispatchDraggedElementLeftContainerForNone(containerEl, draggedEl2) {
  containerEl.dispatchEvent(
    new CustomEvent(DRAGGED_LEFT_EVENT_NAME, {
      detail: { draggedEl: draggedEl2, type: DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY }
    })
  );
}
function dispatchDraggedElementIsOverIndex(containerEl, indexObj, draggedEl2) {
  containerEl.dispatchEvent(
    new CustomEvent(DRAGGED_OVER_INDEX_EVENT_NAME, {
      detail: { indexObj, draggedEl: draggedEl2 }
    })
  );
}
function dispatchDraggedLeftDocument(draggedEl2) {
  window.dispatchEvent(
    new CustomEvent(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, {
      detail: { draggedEl: draggedEl2 }
    })
  );
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.55.1/node_modules/svelte-dnd-action/src/constants.js
var TRIGGERS = {
  DRAG_STARTED: "dragStarted",
  DRAGGED_ENTERED: DRAGGED_ENTERED_EVENT_NAME,
  DRAGGED_ENTERED_ANOTHER: "dragEnteredAnother",
  DRAGGED_OVER_INDEX: DRAGGED_OVER_INDEX_EVENT_NAME,
  DRAGGED_LEFT: DRAGGED_LEFT_EVENT_NAME,
  DRAGGED_LEFT_ALL: "draggedLeftAll",
  DROPPED_INTO_ZONE: "droppedIntoZone",
  DROPPED_INTO_ANOTHER: "droppedIntoAnother",
  DROPPED_OUTSIDE_OF_ANY: "droppedOutsideOfAny",
  DRAG_STOPPED: "dragStopped"
};
var SOURCES = {
  POINTER: "pointer",
  KEYBOARD: "keyboard"
};
var SHADOW_ITEM_MARKER_PROPERTY_NAME = "isDndShadowItem";
var SHADOW_ELEMENT_ATTRIBUTE_NAME = "data-is-dnd-shadow-item";
var SHADOW_PLACEHOLDER_ITEM_ID = "id:dnd-shadow-placeholder-0000";
var DRAGGED_ELEMENT_ID = "dnd-action-dragged-el";
var ITEM_ID_KEY = "id";
var activeDndZoneCount = 0;
function incrementActiveDropZoneCount() {
  activeDndZoneCount++;
}
function decrementActiveDropZoneCount() {
  if (activeDndZoneCount === 0) {
    throw new Error("Bug! trying to decrement when there are no dropzones");
  }
  activeDndZoneCount--;
}
var isOnServer = typeof window === "undefined";
var printDebug = () => {
};

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.55.1/node_modules/svelte-dnd-action/src/helpers/intersection.js
function getBoundingRectNoTransforms(el) {
  let ta;
  const rect = el.getBoundingClientRect();
  const style = getComputedStyle(el);
  const tx = style.transform;
  if (tx) {
    let sx, sy, dx, dy;
    if (tx.startsWith("matrix3d(")) {
      ta = tx.slice(9, -1).split(/, /);
      sx = +ta[0];
      sy = +ta[5];
      dx = +ta[12];
      dy = +ta[13];
    } else if (tx.startsWith("matrix(")) {
      ta = tx.slice(7, -1).split(/, /);
      sx = +ta[0];
      sy = +ta[3];
      dx = +ta[4];
      dy = +ta[5];
    } else {
      return rect;
    }
    const to = style.transformOrigin;
    const x = rect.x - dx - (1 - sx) * parseFloat(to);
    const y = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(" ") + 1));
    const w = sx ? rect.width / sx : el.offsetWidth;
    const h = sy ? rect.height / sy : el.offsetHeight;
    return {
      x,
      y,
      width: w,
      height: h,
      top: y,
      right: x + w,
      bottom: y + h,
      left: x
    };
  } else {
    return rect;
  }
}
function getAbsoluteRectNoTransforms(el) {
  const rect = getBoundingRectNoTransforms(el);
  return {
    top: rect.top + window.scrollY,
    bottom: rect.bottom + window.scrollY,
    left: rect.left + window.scrollX,
    right: rect.right + window.scrollX
  };
}
function getAbsoluteRect(el) {
  const rect = el.getBoundingClientRect();
  return {
    top: rect.top + window.scrollY,
    bottom: rect.bottom + window.scrollY,
    left: rect.left + window.scrollX,
    right: rect.right + window.scrollX
  };
}
function findCenter(rect) {
  return {
    x: (rect.left + rect.right) / 2,
    y: (rect.top + rect.bottom) / 2
  };
}
function calcDistance(pointA, pointB) {
  return Math.sqrt(Math.pow(pointA.x - pointB.x, 2) + Math.pow(pointA.y - pointB.y, 2));
}
function isPointInsideRect(point, rect) {
  return point.y <= rect.bottom && point.y >= rect.top && point.x >= rect.left && point.x <= rect.right;
}
function findCenterOfElement(el) {
  return findCenter(getAbsoluteRect(el));
}
function isCenterOfAInsideB(elA, elB) {
  const centerOfA = findCenterOfElement(elA);
  const rectOfB = getAbsoluteRectNoTransforms(elB);
  return isPointInsideRect(centerOfA, rectOfB);
}
function calcDistanceBetweenCenters(elA, elB) {
  const centerOfA = findCenterOfElement(elA);
  const centerOfB = findCenterOfElement(elB);
  return calcDistance(centerOfA, centerOfB);
}
function isElementOffDocument(el) {
  const rect = getAbsoluteRect(el);
  return rect.right < 0 || rect.left > document.documentElement.scrollWidth || rect.bottom < 0 || rect.top > document.documentElement.scrollHeight;
}
function calcInnerDistancesBetweenPointAndSidesOfElement(point, el) {
  const rect = getAbsoluteRect(el);
  if (!isPointInsideRect(point, rect)) {
    return null;
  }
  return {
    top: point.y - rect.top,
    bottom: rect.bottom - point.y,
    left: point.x - rect.left,
    right: Math.min(rect.right, document.documentElement.clientWidth) - point.x
  };
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.55.1/node_modules/svelte-dnd-action/src/helpers/listUtil.js
var dzToShadowIndexToRect;
function resetIndexesCache() {
  printDebug(() => "resetting indexes cache");
  dzToShadowIndexToRect = /* @__PURE__ */ new Map();
}
resetIndexesCache();
function resetIndexesCacheForDz(dz) {
  printDebug(() => "resetting indexes cache for dz");
  dzToShadowIndexToRect.delete(dz);
}
function cacheShadowRect(dz) {
  const shadowElIndex = Array.from(dz.children).findIndex((child) => child.getAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME));
  if (shadowElIndex >= 0) {
    if (!dzToShadowIndexToRect.has(dz)) {
      dzToShadowIndexToRect.set(dz, /* @__PURE__ */ new Map());
    }
    dzToShadowIndexToRect.get(dz).set(shadowElIndex, getAbsoluteRectNoTransforms(dz.children[shadowElIndex]));
    return shadowElIndex;
  }
  return void 0;
}
function findWouldBeIndex(floatingAboveEl, collectionBelowEl) {
  if (!isCenterOfAInsideB(floatingAboveEl, collectionBelowEl)) {
    return null;
  }
  const children2 = collectionBelowEl.children;
  if (children2.length === 0) {
    return { index: 0, isProximityBased: true };
  }
  const shadowElIndex = cacheShadowRect(collectionBelowEl);
  for (let i = 0; i < children2.length; i++) {
    if (isCenterOfAInsideB(floatingAboveEl, children2[i])) {
      const cachedShadowRect = dzToShadowIndexToRect.has(collectionBelowEl) && dzToShadowIndexToRect.get(collectionBelowEl).get(i);
      if (cachedShadowRect) {
        if (!isPointInsideRect(findCenterOfElement(floatingAboveEl), cachedShadowRect)) {
          return { index: shadowElIndex, isProximityBased: false };
        }
      }
      return { index: i, isProximityBased: false };
    }
  }
  let minDistanceSoFar = Number.MAX_VALUE;
  let indexOfMin = void 0;
  for (let i = 0; i < children2.length; i++) {
    const distance = calcDistanceBetweenCenters(floatingAboveEl, children2[i]);
    if (distance < minDistanceSoFar) {
      minDistanceSoFar = distance;
      indexOfMin = i;
    }
  }
  return { index: indexOfMin, isProximityBased: true };
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.55.1/node_modules/svelte-dnd-action/src/helpers/scroller.js
var SCROLL_ZONE_PX = 25;
function makeScroller() {
  let scrollingInfo;
  function resetScrolling3() {
    scrollingInfo = { directionObj: void 0, stepPx: 0 };
  }
  resetScrolling3();
  function scrollContainer(containerEl) {
    const { directionObj, stepPx } = scrollingInfo;
    if (directionObj) {
      containerEl.scrollBy(directionObj.x * stepPx, directionObj.y * stepPx);
      window.requestAnimationFrame(() => scrollContainer(containerEl));
    }
  }
  function calcScrollStepPx(distancePx) {
    return SCROLL_ZONE_PX - distancePx;
  }
  function scrollIfNeeded3(pointer, elementToScroll) {
    if (!elementToScroll) {
      return false;
    }
    const distances = calcInnerDistancesBetweenPointAndSidesOfElement(pointer, elementToScroll);
    if (distances === null) {
      resetScrolling3();
      return false;
    }
    const isAlreadyScrolling = !!scrollingInfo.directionObj;
    let [scrollingVertically, scrollingHorizontally] = [false, false];
    if (elementToScroll.scrollHeight > elementToScroll.clientHeight) {
      if (distances.bottom < SCROLL_ZONE_PX) {
        scrollingVertically = true;
        scrollingInfo.directionObj = { x: 0, y: 1 };
        scrollingInfo.stepPx = calcScrollStepPx(distances.bottom);
      } else if (distances.top < SCROLL_ZONE_PX) {
        scrollingVertically = true;
        scrollingInfo.directionObj = { x: 0, y: -1 };
        scrollingInfo.stepPx = calcScrollStepPx(distances.top);
      }
      if (!isAlreadyScrolling && scrollingVertically) {
        scrollContainer(elementToScroll);
        return true;
      }
    }
    if (elementToScroll.scrollWidth > elementToScroll.clientWidth) {
      if (distances.right < SCROLL_ZONE_PX) {
        scrollingHorizontally = true;
        scrollingInfo.directionObj = { x: 1, y: 0 };
        scrollingInfo.stepPx = calcScrollStepPx(distances.right);
      } else if (distances.left < SCROLL_ZONE_PX) {
        scrollingHorizontally = true;
        scrollingInfo.directionObj = { x: -1, y: 0 };
        scrollingInfo.stepPx = calcScrollStepPx(distances.left);
      }
      if (!isAlreadyScrolling && scrollingHorizontally) {
        scrollContainer(elementToScroll);
        return true;
      }
    }
    resetScrolling3();
    return false;
  }
  return {
    scrollIfNeeded: scrollIfNeeded3,
    resetScrolling: resetScrolling3
  };
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.55.1/node_modules/svelte-dnd-action/src/helpers/util.js
function toString(object) {
  return JSON.stringify(object, null, 2);
}
function getDepth(node) {
  if (!node) {
    throw new Error("cannot get depth of a falsy node");
  }
  return _getDepth(node, 0);
}
function _getDepth(node, countSoFar = 0) {
  if (!node.parentElement) {
    return countSoFar - 1;
  }
  return _getDepth(node.parentElement, countSoFar + 1);
}
function areObjectsShallowEqual(objA, objB) {
  if (Object.keys(objA).length !== Object.keys(objB).length) {
    return false;
  }
  for (const keyA in objA) {
    if (!{}.hasOwnProperty.call(objB, keyA) || objB[keyA] !== objA[keyA]) {
      return false;
    }
  }
  return true;
}
function areArraysShallowEqualSameOrder(arrA, arrB) {
  if (arrA.length !== arrB.length) {
    return false;
  }
  for (let i = 0; i < arrA.length; i++) {
    if (arrA[i] !== arrB[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.55.1/node_modules/svelte-dnd-action/src/helpers/observer.js
var INTERVAL_MS = 200;
var TOLERANCE_PX = 10;
var { scrollIfNeeded, resetScrolling } = makeScroller();
var next;
function observe(draggedEl2, dropZones, intervalMs = INTERVAL_MS) {
  let lastDropZoneFound;
  let lastIndexFound;
  let lastIsDraggedInADropZone = false;
  let lastCentrePositionOfDragged;
  const dropZonesFromDeepToShallow = Array.from(dropZones).sort((dz1, dz2) => getDepth(dz2) - getDepth(dz1));
  function andNow() {
    const currentCenterOfDragged = findCenterOfElement(draggedEl2);
    const scrolled = scrollIfNeeded(currentCenterOfDragged, lastDropZoneFound);
    if (!scrolled && lastCentrePositionOfDragged && Math.abs(lastCentrePositionOfDragged.x - currentCenterOfDragged.x) < TOLERANCE_PX && Math.abs(lastCentrePositionOfDragged.y - currentCenterOfDragged.y) < TOLERANCE_PX) {
      next = window.setTimeout(andNow, intervalMs);
      return;
    }
    if (isElementOffDocument(draggedEl2)) {
      printDebug(() => "off document");
      dispatchDraggedLeftDocument(draggedEl2);
      return;
    }
    lastCentrePositionOfDragged = currentCenterOfDragged;
    let isDraggedInADropZone = false;
    for (const dz of dropZonesFromDeepToShallow) {
      if (scrolled)
        resetIndexesCacheForDz(lastDropZoneFound);
      const indexObj = findWouldBeIndex(draggedEl2, dz);
      if (indexObj === null) {
        continue;
      }
      const { index } = indexObj;
      isDraggedInADropZone = true;
      if (dz !== lastDropZoneFound) {
        lastDropZoneFound && dispatchDraggedElementLeftContainerForAnother(lastDropZoneFound, draggedEl2, dz);
        dispatchDraggedElementEnteredContainer(dz, indexObj, draggedEl2);
        lastDropZoneFound = dz;
      } else if (index !== lastIndexFound) {
        dispatchDraggedElementIsOverIndex(dz, indexObj, draggedEl2);
        lastIndexFound = index;
      }
      break;
    }
    if (!isDraggedInADropZone && lastIsDraggedInADropZone && lastDropZoneFound) {
      dispatchDraggedElementLeftContainerForNone(lastDropZoneFound, draggedEl2);
      lastDropZoneFound = void 0;
      lastIndexFound = void 0;
      lastIsDraggedInADropZone = false;
    } else {
      lastIsDraggedInADropZone = true;
    }
    next = window.setTimeout(andNow, intervalMs);
  }
  andNow();
}
function unobserve() {
  printDebug(() => "unobserving");
  clearTimeout(next);
  resetScrolling();
  resetIndexesCache();
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.55.1/node_modules/svelte-dnd-action/src/helpers/windowScroller.js
var INTERVAL_MS2 = 300;
var mousePosition;
function updateMousePosition(e) {
  const c = e.touches ? e.touches[0] : e;
  mousePosition = { x: c.clientX, y: c.clientY };
}
var { scrollIfNeeded: scrollIfNeeded2, resetScrolling: resetScrolling2 } = makeScroller();
var next2;
function loop() {
  if (mousePosition) {
    const scrolled = scrollIfNeeded2(mousePosition, document.documentElement);
    if (scrolled)
      resetIndexesCache();
  }
  next2 = window.setTimeout(loop, INTERVAL_MS2);
}
function armWindowScroller() {
  printDebug(() => "arming window scroller");
  window.addEventListener("mousemove", updateMousePosition);
  window.addEventListener("touchmove", updateMousePosition);
  loop();
}
function disarmWindowScroller() {
  printDebug(() => "disarming window scroller");
  window.removeEventListener("mousemove", updateMousePosition);
  window.removeEventListener("touchmove", updateMousePosition);
  mousePosition = void 0;
  window.clearTimeout(next2);
  resetScrolling2();
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.55.1/node_modules/svelte-dnd-action/src/helpers/svelteNodeClone.js
function svelteNodeClone(el) {
  const cloned = el.cloneNode(true);
  const values = [];
  const elIsSelect = el.tagName === "SELECT";
  const selects = elIsSelect ? [el] : [...el.querySelectorAll("select")];
  for (const select of selects) {
    values.push(select.value);
  }
  if (selects.length <= 0) {
    return cloned;
  }
  const clonedSelects = elIsSelect ? [cloned] : [...cloned.querySelectorAll("select")];
  for (let i = 0; i < clonedSelects.length; i++) {
    const select = clonedSelects[i];
    const value = values[i];
    const optionEl = select.querySelector(`option[value="${value}"`);
    if (optionEl) {
      optionEl.setAttribute("selected", true);
    }
  }
  return cloned;
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.55.1/node_modules/svelte-dnd-action/src/helpers/styler.js
var TRANSITION_DURATION_SECONDS = 0.2;
function trs(property) {
  return `${property} ${TRANSITION_DURATION_SECONDS}s ease`;
}
function createDraggedElementFrom(originalElement, positionCenterOnXY) {
  const rect = originalElement.getBoundingClientRect();
  const draggedEl2 = svelteNodeClone(originalElement);
  copyStylesFromTo(originalElement, draggedEl2);
  draggedEl2.id = DRAGGED_ELEMENT_ID;
  draggedEl2.style.position = "fixed";
  let elTopPx = rect.top;
  let elLeftPx = rect.left;
  draggedEl2.style.top = `${elTopPx}px`;
  draggedEl2.style.left = `${elLeftPx}px`;
  if (positionCenterOnXY) {
    const center = findCenter(rect);
    elTopPx -= center.y - positionCenterOnXY.y;
    elLeftPx -= center.x - positionCenterOnXY.x;
    window.setTimeout(() => {
      draggedEl2.style.top = `${elTopPx}px`;
      draggedEl2.style.left = `${elLeftPx}px`;
    }, 0);
  }
  draggedEl2.style.margin = "0";
  draggedEl2.style.boxSizing = "border-box";
  draggedEl2.style.height = `${rect.height}px`;
  draggedEl2.style.width = `${rect.width}px`;
  draggedEl2.style.transition = `${trs("top")}, ${trs("left")}, ${trs("background-color")}, ${trs("opacity")}, ${trs("color")} `;
  window.setTimeout(() => draggedEl2.style.transition += `, ${trs("width")}, ${trs("height")}`, 0);
  draggedEl2.style.zIndex = "9999";
  draggedEl2.style.cursor = "grabbing";
  return draggedEl2;
}
function moveDraggedElementToWasDroppedState(draggedEl2) {
  draggedEl2.style.cursor = "grab";
}
function morphDraggedElementToBeLike(draggedEl2, copyFromEl, currentMouseX, currentMouseY) {
  copyStylesFromTo(copyFromEl, draggedEl2);
  const newRect = copyFromEl.getBoundingClientRect();
  const draggedElRect = draggedEl2.getBoundingClientRect();
  const widthChange = newRect.width - draggedElRect.width;
  const heightChange = newRect.height - draggedElRect.height;
  if (widthChange || heightChange) {
    const relativeDistanceOfMousePointerFromDraggedSides = {
      left: (currentMouseX - draggedElRect.left) / draggedElRect.width,
      top: (currentMouseY - draggedElRect.top) / draggedElRect.height
    };
    draggedEl2.style.height = `${newRect.height}px`;
    draggedEl2.style.width = `${newRect.width}px`;
    draggedEl2.style.left = `${parseFloat(draggedEl2.style.left) - relativeDistanceOfMousePointerFromDraggedSides.left * widthChange}px`;
    draggedEl2.style.top = `${parseFloat(draggedEl2.style.top) - relativeDistanceOfMousePointerFromDraggedSides.top * heightChange}px`;
  }
}
function copyStylesFromTo(copyFromEl, copyToEl) {
  const computedStyle = window.getComputedStyle(copyFromEl);
  Array.from(computedStyle).filter(
    (s) => s.startsWith("background") || s.startsWith("padding") || s.startsWith("font") || s.startsWith("text") || s.startsWith("align") || s.startsWith("justify") || s.startsWith("display") || s.startsWith("flex") || s.startsWith("border") || s === "opacity" || s === "color" || s === "list-style-type"
  ).forEach((s) => copyToEl.style.setProperty(s, computedStyle.getPropertyValue(s), computedStyle.getPropertyPriority(s)));
}
function styleDraggable(draggableEl, dragDisabled) {
  draggableEl.draggable = false;
  draggableEl.ondragstart = () => false;
  if (!dragDisabled) {
    draggableEl.style.userSelect = "none";
    draggableEl.style.WebkitUserSelect = "none";
    draggableEl.style.cursor = "grab";
  } else {
    draggableEl.style.userSelect = "";
    draggableEl.style.WebkitUserSelect = "";
    draggableEl.style.cursor = "";
  }
}
function hideElement(dragTarget) {
  dragTarget.style.display = "none";
  dragTarget.style.position = "fixed";
  dragTarget.style.zIndex = "-5";
}
function decorateShadowEl(shadowEl) {
  shadowEl.style.visibility = "hidden";
  shadowEl.setAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME, "true");
}
function unDecorateShadowElement(shadowEl) {
  shadowEl.style.visibility = "";
  shadowEl.removeAttribute(SHADOW_ELEMENT_ATTRIBUTE_NAME);
}
function styleActiveDropZones(dropZones, getStyles = () => {
}, getClasses = () => []) {
  dropZones.forEach((dz) => {
    const styles = getStyles(dz);
    Object.keys(styles).forEach((style) => {
      dz.style[style] = styles[style];
    });
    getClasses(dz).forEach((c) => dz.classList.add(c));
  });
}
function styleInactiveDropZones(dropZones, getStyles = () => {
}, getClasses = () => []) {
  dropZones.forEach((dz) => {
    const styles = getStyles(dz);
    Object.keys(styles).forEach((style) => {
      dz.style[style] = "";
    });
    getClasses(dz).forEach((c) => dz.classList.contains(c) && dz.classList.remove(c));
  });
}
function preventShrinking(el) {
  const originalMinHeight = el.style.minHeight;
  el.style.minHeight = window.getComputedStyle(el).getPropertyValue("height");
  const originalMinWidth = el.style.minWidth;
  el.style.minWidth = window.getComputedStyle(el).getPropertyValue("width");
  return function undo() {
    el.style.minHeight = originalMinHeight;
    el.style.minWidth = originalMinWidth;
  };
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.55.1/node_modules/svelte-dnd-action/src/pointerAction.js
var DEFAULT_DROP_ZONE_TYPE = "--any--";
var MIN_OBSERVATION_INTERVAL_MS = 100;
var MIN_MOVEMENT_BEFORE_DRAG_START_PX = 3;
var DEFAULT_DROP_TARGET_STYLE = {
  outline: "rgba(255, 255, 102, 0.7) solid 2px"
};
var originalDragTarget;
var draggedEl;
var draggedElData;
var draggedElType;
var originDropZone;
var originIndex;
var shadowElData;
var shadowElDropZone;
var dragStartMousePosition;
var currentMousePosition;
var isWorkingOnPreviousDrag = false;
var finalizingPreviousDrag = false;
var unlockOriginDzMinDimensions;
var isDraggedOutsideOfAnyDz = false;
var scheduledForRemovalAfterDrop = [];
var typeToDropZones = /* @__PURE__ */ new Map();
var dzToConfig = /* @__PURE__ */ new Map();
var elToMouseDownListener = /* @__PURE__ */ new WeakMap();
function registerDropZone(dropZoneEl, type) {
  printDebug(() => "registering drop-zone if absent");
  if (!typeToDropZones.has(type)) {
    typeToDropZones.set(type, /* @__PURE__ */ new Set());
  }
  if (!typeToDropZones.get(type).has(dropZoneEl)) {
    typeToDropZones.get(type).add(dropZoneEl);
    incrementActiveDropZoneCount();
  }
}
function unregisterDropZone(dropZoneEl, type) {
  typeToDropZones.get(type).delete(dropZoneEl);
  decrementActiveDropZoneCount();
  if (typeToDropZones.get(type).size === 0) {
    typeToDropZones.delete(type);
  }
}
function watchDraggedElement() {
  printDebug(() => "watching dragged element");
  armWindowScroller();
  const dropZones = typeToDropZones.get(draggedElType);
  for (const dz of dropZones) {
    dz.addEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);
    dz.addEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);
    dz.addEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);
  }
  window.addEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);
  const observationIntervalMs = Math.max(
    MIN_OBSERVATION_INTERVAL_MS,
    ...Array.from(dropZones.keys()).map((dz) => dzToConfig.get(dz).dropAnimationDurationMs)
  );
  observe(draggedEl, dropZones, observationIntervalMs * 1.07);
}
function unWatchDraggedElement() {
  printDebug(() => "unwatching dragged element");
  disarmWindowScroller();
  const dropZones = typeToDropZones.get(draggedElType);
  for (const dz of dropZones) {
    dz.removeEventListener(DRAGGED_ENTERED_EVENT_NAME, handleDraggedEntered);
    dz.removeEventListener(DRAGGED_LEFT_EVENT_NAME, handleDraggedLeft);
    dz.removeEventListener(DRAGGED_OVER_INDEX_EVENT_NAME, handleDraggedIsOverIndex);
  }
  window.removeEventListener(DRAGGED_LEFT_DOCUMENT_EVENT_NAME, handleDrop);
  unobserve();
}
function findShadowPlaceHolderIdx(items) {
  return items.findIndex((item) => item[ITEM_ID_KEY] === SHADOW_PLACEHOLDER_ITEM_ID);
}
function findShadowElementIdx(items) {
  return items.findIndex((item) => !!item[SHADOW_ITEM_MARKER_PROPERTY_NAME] && item[ITEM_ID_KEY] !== SHADOW_PLACEHOLDER_ITEM_ID);
}
function handleDraggedEntered(e) {
  printDebug(() => ["dragged entered", e.currentTarget, e.detail]);
  let { items, dropFromOthersDisabled } = dzToConfig.get(e.currentTarget);
  if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {
    printDebug(() => "ignoring dragged entered because drop is currently disabled");
    return;
  }
  isDraggedOutsideOfAnyDz = false;
  items = items.filter((item) => item[ITEM_ID_KEY] !== shadowElData[ITEM_ID_KEY]);
  printDebug(() => `dragged entered items ${toString(items)}`);
  if (originDropZone !== e.currentTarget) {
    const originZoneItems = dzToConfig.get(originDropZone).items;
    const newOriginZoneItems = originZoneItems.filter((item) => !item[SHADOW_ITEM_MARKER_PROPERTY_NAME]);
    dispatchConsiderEvent(originDropZone, newOriginZoneItems, {
      trigger: TRIGGERS.DRAGGED_ENTERED_ANOTHER,
      id: draggedElData[ITEM_ID_KEY],
      source: SOURCES.POINTER
    });
  } else {
    const shadowPlaceHolderIdx = findShadowPlaceHolderIdx(items);
    if (shadowPlaceHolderIdx !== -1) {
      printDebug(() => "removing placeholder item from origin dz");
      items.splice(shadowPlaceHolderIdx, 1);
    }
  }
  const { index, isProximityBased } = e.detail.indexObj;
  const shadowElIdx = isProximityBased && index === e.currentTarget.children.length - 1 ? index + 1 : index;
  shadowElDropZone = e.currentTarget;
  items.splice(shadowElIdx, 0, shadowElData);
  dispatchConsiderEvent(e.currentTarget, items, { trigger: TRIGGERS.DRAGGED_ENTERED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER });
}
function handleDraggedLeft(e) {
  if (!isWorkingOnPreviousDrag)
    return;
  printDebug(() => ["dragged left", e.currentTarget, e.detail]);
  const { items, dropFromOthersDisabled } = dzToConfig.get(e.currentTarget);
  if (dropFromOthersDisabled && e.currentTarget !== originDropZone && e.currentTarget !== shadowElDropZone) {
    printDebug(() => "drop is currently disabled");
    return;
  }
  const shadowElIdx = findShadowElementIdx(items);
  const shadowItem = items.splice(shadowElIdx, 1)[0];
  shadowElDropZone = void 0;
  const { type, theOtherDz } = e.detail;
  if (type === DRAGGED_LEFT_TYPES.OUTSIDE_OF_ANY || type === DRAGGED_LEFT_TYPES.LEFT_FOR_ANOTHER && theOtherDz !== originDropZone && dzToConfig.get(theOtherDz).dropFromOthersDisabled) {
    printDebug(() => "dragged left all, putting shadow element back in the origin dz");
    isDraggedOutsideOfAnyDz = true;
    shadowElDropZone = originDropZone;
    const originZoneItems = dzToConfig.get(originDropZone).items;
    originZoneItems.splice(originIndex, 0, shadowItem);
    dispatchConsiderEvent(originDropZone, originZoneItems, {
      trigger: TRIGGERS.DRAGGED_LEFT_ALL,
      id: draggedElData[ITEM_ID_KEY],
      source: SOURCES.POINTER
    });
  }
  dispatchConsiderEvent(e.currentTarget, items, {
    trigger: TRIGGERS.DRAGGED_LEFT,
    id: draggedElData[ITEM_ID_KEY],
    source: SOURCES.POINTER
  });
}
function handleDraggedIsOverIndex(e) {
  printDebug(() => ["dragged is over index", e.currentTarget, e.detail]);
  const { items, dropFromOthersDisabled } = dzToConfig.get(e.currentTarget);
  if (dropFromOthersDisabled && e.currentTarget !== originDropZone) {
    printDebug(() => "drop is currently disabled");
    return;
  }
  isDraggedOutsideOfAnyDz = false;
  const { index } = e.detail.indexObj;
  const shadowElIdx = findShadowElementIdx(items);
  items.splice(shadowElIdx, 1);
  items.splice(index, 0, shadowElData);
  dispatchConsiderEvent(e.currentTarget, items, { trigger: TRIGGERS.DRAGGED_OVER_INDEX, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER });
}
function handleMouseMove(e) {
  e.preventDefault();
  const c = e.touches ? e.touches[0] : e;
  currentMousePosition = { x: c.clientX, y: c.clientY };
  draggedEl.style.transform = `translate3d(${currentMousePosition.x - dragStartMousePosition.x}px, ${currentMousePosition.y - dragStartMousePosition.y}px, 0)`;
}
function handleDrop() {
  printDebug(() => "dropped");
  finalizingPreviousDrag = true;
  window.removeEventListener("mousemove", handleMouseMove);
  window.removeEventListener("touchmove", handleMouseMove);
  window.removeEventListener("mouseup", handleDrop);
  window.removeEventListener("touchend", handleDrop);
  unWatchDraggedElement();
  moveDraggedElementToWasDroppedState(draggedEl);
  if (!shadowElDropZone) {
    printDebug(() => "element was dropped right after it left origin but before entering somewhere else");
    shadowElDropZone = originDropZone;
  }
  printDebug(() => ["dropped in dz", shadowElDropZone]);
  let { items, type } = dzToConfig.get(shadowElDropZone);
  styleInactiveDropZones(
    typeToDropZones.get(type),
    (dz) => dzToConfig.get(dz).dropTargetStyle,
    (dz) => dzToConfig.get(dz).dropTargetClasses
  );
  let shadowElIdx = findShadowElementIdx(items);
  if (shadowElIdx === -1)
    shadowElIdx = originIndex;
  items = items.map((item) => item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? draggedElData : item);
  function finalizeWithinZone() {
    unlockOriginDzMinDimensions();
    dispatchFinalizeEvent(shadowElDropZone, items, {
      trigger: isDraggedOutsideOfAnyDz ? TRIGGERS.DROPPED_OUTSIDE_OF_ANY : TRIGGERS.DROPPED_INTO_ZONE,
      id: draggedElData[ITEM_ID_KEY],
      source: SOURCES.POINTER
    });
    if (shadowElDropZone !== originDropZone) {
      dispatchFinalizeEvent(originDropZone, dzToConfig.get(originDropZone).items, {
        trigger: TRIGGERS.DROPPED_INTO_ANOTHER,
        id: draggedElData[ITEM_ID_KEY],
        source: SOURCES.POINTER
      });
    }
    unDecorateShadowElement(shadowElDropZone.children[shadowElIdx]);
    cleanupPostDrop();
  }
  animateDraggedToFinalPosition(shadowElIdx, finalizeWithinZone);
}
function animateDraggedToFinalPosition(shadowElIdx, callback) {
  const shadowElRect = getBoundingRectNoTransforms(shadowElDropZone.children[shadowElIdx]);
  const newTransform = {
    x: shadowElRect.left - parseFloat(draggedEl.style.left),
    y: shadowElRect.top - parseFloat(draggedEl.style.top)
  };
  const { dropAnimationDurationMs } = dzToConfig.get(shadowElDropZone);
  const transition = `transform ${dropAnimationDurationMs}ms ease`;
  draggedEl.style.transition = draggedEl.style.transition ? draggedEl.style.transition + "," + transition : transition;
  draggedEl.style.transform = `translate3d(${newTransform.x}px, ${newTransform.y}px, 0)`;
  window.setTimeout(callback, dropAnimationDurationMs);
}
function scheduleDZForRemovalAfterDrop(dz, destroy) {
  scheduledForRemovalAfterDrop.push({ dz, destroy });
  window.requestAnimationFrame(() => {
    hideElement(dz);
    document.body.appendChild(dz);
  });
}
function cleanupPostDrop() {
  draggedEl.remove();
  originalDragTarget.remove();
  if (scheduledForRemovalAfterDrop.length) {
    printDebug(() => ["will destroy zones that were removed during drag", scheduledForRemovalAfterDrop]);
    scheduledForRemovalAfterDrop.forEach(({ dz, destroy }) => {
      destroy();
      dz.remove();
    });
    scheduledForRemovalAfterDrop = [];
  }
  draggedEl = void 0;
  originalDragTarget = void 0;
  draggedElData = void 0;
  draggedElType = void 0;
  originDropZone = void 0;
  originIndex = void 0;
  shadowElData = void 0;
  shadowElDropZone = void 0;
  dragStartMousePosition = void 0;
  currentMousePosition = void 0;
  isWorkingOnPreviousDrag = false;
  finalizingPreviousDrag = false;
  unlockOriginDzMinDimensions = void 0;
  isDraggedOutsideOfAnyDz = false;
}
function dndzone(node, options) {
  let initialized = false;
  const config = {
    items: void 0,
    type: void 0,
    flipDurationMs: 0,
    dragDisabled: false,
    morphDisabled: false,
    dropFromOthersDisabled: false,
    dropTargetStyle: DEFAULT_DROP_TARGET_STYLE,
    dropTargetClasses: [],
    transformDraggedElement: () => {
    },
    centreDraggedOnCursor: false
  };
  printDebug(() => [`dndzone good to go options: ${toString(options)}, config: ${toString(config)}`, { node }]);
  let elToIdx = /* @__PURE__ */ new Map();
  function addMaybeListeners() {
    window.addEventListener("mousemove", handleMouseMoveMaybeDragStart, { passive: false });
    window.addEventListener("touchmove", handleMouseMoveMaybeDragStart, { passive: false, capture: false });
    window.addEventListener("mouseup", handleFalseAlarm, { passive: false });
    window.addEventListener("touchend", handleFalseAlarm, { passive: false });
  }
  function removeMaybeListeners() {
    window.removeEventListener("mousemove", handleMouseMoveMaybeDragStart);
    window.removeEventListener("touchmove", handleMouseMoveMaybeDragStart);
    window.removeEventListener("mouseup", handleFalseAlarm);
    window.removeEventListener("touchend", handleFalseAlarm);
  }
  function handleFalseAlarm() {
    removeMaybeListeners();
    originalDragTarget = void 0;
    dragStartMousePosition = void 0;
    currentMousePosition = void 0;
  }
  function handleMouseMoveMaybeDragStart(e) {
    e.preventDefault();
    const c = e.touches ? e.touches[0] : e;
    currentMousePosition = { x: c.clientX, y: c.clientY };
    if (Math.abs(currentMousePosition.x - dragStartMousePosition.x) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX || Math.abs(currentMousePosition.y - dragStartMousePosition.y) >= MIN_MOVEMENT_BEFORE_DRAG_START_PX) {
      removeMaybeListeners();
      handleDragStart();
    }
  }
  function handleMouseDown(e) {
    if (e.target !== e.currentTarget && (e.target.value !== void 0 || e.target.isContentEditable)) {
      printDebug(() => "won't initiate drag on a nested input element");
      return;
    }
    if (e.button) {
      printDebug(() => `ignoring none left click button: ${e.button}`);
      return;
    }
    if (isWorkingOnPreviousDrag) {
      printDebug(() => "cannot start a new drag before finalizing previous one");
      return;
    }
    e.stopPropagation();
    const c = e.touches ? e.touches[0] : e;
    dragStartMousePosition = { x: c.clientX, y: c.clientY };
    currentMousePosition = { ...dragStartMousePosition };
    originalDragTarget = e.currentTarget;
    addMaybeListeners();
  }
  function handleDragStart() {
    printDebug(() => [`drag start config: ${toString(config)}`, originalDragTarget]);
    isWorkingOnPreviousDrag = true;
    const currentIdx = elToIdx.get(originalDragTarget);
    originIndex = currentIdx;
    originDropZone = originalDragTarget.parentElement;
    const rootNode = originDropZone.getRootNode();
    const originDropZoneRoot = rootNode.body || rootNode;
    const { items, type, centreDraggedOnCursor } = config;
    draggedElData = { ...items[currentIdx] };
    draggedElType = type;
    shadowElData = { ...draggedElData, [SHADOW_ITEM_MARKER_PROPERTY_NAME]: true };
    const placeHolderElData = { ...shadowElData, [ITEM_ID_KEY]: SHADOW_PLACEHOLDER_ITEM_ID };
    draggedEl = createDraggedElementFrom(originalDragTarget, centreDraggedOnCursor && currentMousePosition);
    function keepOriginalElementInDom() {
      if (!draggedEl.parentElement) {
        originDropZoneRoot.appendChild(draggedEl);
        draggedEl.focus();
        watchDraggedElement();
        hideElement(originalDragTarget);
        originDropZoneRoot.appendChild(originalDragTarget);
      } else {
        window.requestAnimationFrame(keepOriginalElementInDom);
      }
    }
    window.requestAnimationFrame(keepOriginalElementInDom);
    styleActiveDropZones(
      Array.from(typeToDropZones.get(config.type)).filter((dz) => dz === originDropZone || !dzToConfig.get(dz).dropFromOthersDisabled),
      (dz) => dzToConfig.get(dz).dropTargetStyle,
      (dz) => dzToConfig.get(dz).dropTargetClasses
    );
    items.splice(currentIdx, 1, placeHolderElData);
    unlockOriginDzMinDimensions = preventShrinking(originDropZone);
    dispatchConsiderEvent(originDropZone, items, { trigger: TRIGGERS.DRAG_STARTED, id: draggedElData[ITEM_ID_KEY], source: SOURCES.POINTER });
    window.addEventListener("mousemove", handleMouseMove, { passive: false });
    window.addEventListener("touchmove", handleMouseMove, { passive: false, capture: false });
    window.addEventListener("mouseup", handleDrop, { passive: false });
    window.addEventListener("touchend", handleDrop, { passive: false });
  }
  function configure({
    items = void 0,
    flipDurationMs: dropAnimationDurationMs = 0,
    type: newType = DEFAULT_DROP_ZONE_TYPE,
    dragDisabled = false,
    morphDisabled = false,
    dropFromOthersDisabled = false,
    dropTargetStyle = DEFAULT_DROP_TARGET_STYLE,
    dropTargetClasses = [],
    transformDraggedElement = () => {
    },
    centreDraggedOnCursor = false
  }) {
    config.dropAnimationDurationMs = dropAnimationDurationMs;
    if (config.type && newType !== config.type) {
      unregisterDropZone(node, config.type);
    }
    config.type = newType;
    registerDropZone(node, newType);
    config.items = [...items];
    config.dragDisabled = dragDisabled;
    config.morphDisabled = morphDisabled;
    config.transformDraggedElement = transformDraggedElement;
    config.centreDraggedOnCursor = centreDraggedOnCursor;
    if (initialized && isWorkingOnPreviousDrag && !finalizingPreviousDrag && (!areObjectsShallowEqual(dropTargetStyle, config.dropTargetStyle) || !areArraysShallowEqualSameOrder(dropTargetClasses, config.dropTargetClasses))) {
      styleInactiveDropZones(
        [node],
        () => config.dropTargetStyle,
        () => dropTargetClasses
      );
      styleActiveDropZones(
        [node],
        () => dropTargetStyle,
        () => dropTargetClasses
      );
    }
    config.dropTargetStyle = dropTargetStyle;
    config.dropTargetClasses = [...dropTargetClasses];
    function getConfigProp(dz, propName) {
      return dzToConfig.get(dz) ? dzToConfig.get(dz)[propName] : config[propName];
    }
    if (initialized && isWorkingOnPreviousDrag && config.dropFromOthersDisabled !== dropFromOthersDisabled) {
      if (dropFromOthersDisabled) {
        styleInactiveDropZones(
          [node],
          (dz) => getConfigProp(dz, "dropTargetStyle"),
          (dz) => getConfigProp(dz, "dropTargetClasses")
        );
      } else {
        styleActiveDropZones(
          [node],
          (dz) => getConfigProp(dz, "dropTargetStyle"),
          (dz) => getConfigProp(dz, "dropTargetClasses")
        );
      }
    }
    config.dropFromOthersDisabled = dropFromOthersDisabled;
    dzToConfig.set(node, config);
    const shadowElIdx = findShadowElementIdx(config.items);
    for (let idx = 0; idx < node.children.length; idx++) {
      const draggableEl = node.children[idx];
      styleDraggable(draggableEl, dragDisabled);
      if (idx === shadowElIdx) {
        config.transformDraggedElement(draggedEl, draggedElData, idx);
        if (!morphDisabled) {
          morphDraggedElementToBeLike(draggedEl, draggableEl, currentMousePosition.x, currentMousePosition.y);
        }
        decorateShadowEl(draggableEl);
        continue;
      }
      draggableEl.removeEventListener("mousedown", elToMouseDownListener.get(draggableEl));
      draggableEl.removeEventListener("touchstart", elToMouseDownListener.get(draggableEl));
      if (!dragDisabled) {
        draggableEl.addEventListener("mousedown", handleMouseDown);
        draggableEl.addEventListener("touchstart", handleMouseDown);
        elToMouseDownListener.set(draggableEl, handleMouseDown);
      }
      elToIdx.set(draggableEl, idx);
      if (!initialized) {
        initialized = true;
      }
    }
  }
  configure(options);
  return {
    update: (newOptions) => {
      printDebug(() => `pointer dndzone will update newOptions: ${toString(newOptions)}`);
      configure(newOptions);
    },
    destroy: () => {
      function destroyDz() {
        printDebug(() => "pointer dndzone will destroy");
        unregisterDropZone(node, dzToConfig.get(node).type);
        dzToConfig.delete(node);
      }
      if (isWorkingOnPreviousDrag) {
        printDebug(() => "pointer dndzone will be scheduled for destruction");
        scheduleDZForRemovalAfterDrop(node, destroyDz);
      } else {
        destroyDz();
      }
    }
  };
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.55.1/node_modules/svelte-dnd-action/src/helpers/aria.js
var INSTRUCTION_IDs = {
  DND_ZONE_ACTIVE: "dnd-zone-active",
  DND_ZONE_DRAG_DISABLED: "dnd-zone-drag-disabled"
};
var ID_TO_INSTRUCTION = {
  [INSTRUCTION_IDs.DND_ZONE_ACTIVE]: "Tab to one the items and press space-bar or enter to start dragging it",
  [INSTRUCTION_IDs.DND_ZONE_DRAG_DISABLED]: "This is a disabled drag and drop list"
};
var ALERT_DIV_ID = "dnd-action-aria-alert";
var alertsDiv;
function initAriaOnBrowser() {
  if (alertsDiv) {
    return;
  }
  alertsDiv = document.createElement("div");
  (function initAlertsDiv() {
    alertsDiv.id = ALERT_DIV_ID;
    alertsDiv.style.position = "fixed";
    alertsDiv.style.bottom = "0";
    alertsDiv.style.left = "0";
    alertsDiv.style.zIndex = "-5";
    alertsDiv.style.opacity = "0";
    alertsDiv.style.height = "0";
    alertsDiv.style.width = "0";
    alertsDiv.setAttribute("role", "alert");
  })();
  document.body.prepend(alertsDiv);
  Object.entries(ID_TO_INSTRUCTION).forEach(([id, txt]) => document.body.prepend(instructionToHiddenDiv(id, txt)));
}
function initAria() {
  if (isOnServer)
    return null;
  if (document.readyState === "complete") {
    initAriaOnBrowser();
  } else {
    window.addEventListener("DOMContentLoaded", initAriaOnBrowser);
  }
  return { ...INSTRUCTION_IDs };
}
function destroyAria() {
  if (isOnServer || !alertsDiv)
    return;
  Object.keys(ID_TO_INSTRUCTION).forEach((id) => {
    var _a;
    return (_a = document.getElementById(id)) == null ? void 0 : _a.remove();
  });
  alertsDiv.remove();
  alertsDiv = void 0;
}
function instructionToHiddenDiv(id, txt) {
  const div = document.createElement("div");
  div.id = id;
  div.innerHTML = `<p>${txt}</p>`;
  div.style.display = "none";
  div.style.position = "fixed";
  div.style.zIndex = "-5";
  return div;
}
function alertToScreenReader(txt) {
  if (isOnServer)
    return;
  if (!alertsDiv) {
    initAriaOnBrowser();
  }
  alertsDiv.innerHTML = "";
  const alertText = document.createTextNode(txt);
  alertsDiv.appendChild(alertText);
  alertsDiv.style.display = "none";
  alertsDiv.style.display = "inline";
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.55.1/node_modules/svelte-dnd-action/src/keyboardAction.js
var DEFAULT_DROP_ZONE_TYPE2 = "--any--";
var DEFAULT_DROP_TARGET_STYLE2 = {
  outline: "rgba(255, 255, 102, 0.7) solid 2px"
};
var isDragging = false;
var draggedItemType;
var focusedDz;
var focusedDzLabel = "";
var focusedItem;
var focusedItemId;
var focusedItemLabel = "";
var allDragTargets = /* @__PURE__ */ new WeakSet();
var elToKeyDownListeners = /* @__PURE__ */ new WeakMap();
var elToFocusListeners = /* @__PURE__ */ new WeakMap();
var dzToHandles = /* @__PURE__ */ new Map();
var dzToConfig2 = /* @__PURE__ */ new Map();
var typeToDropZones2 = /* @__PURE__ */ new Map();
var INSTRUCTION_IDs2;
function registerDropZone2(dropZoneEl, type) {
  printDebug(() => "registering drop-zone if absent");
  if (typeToDropZones2.size === 0) {
    printDebug(() => "adding global keydown and click handlers");
    INSTRUCTION_IDs2 = initAria();
    window.addEventListener("keydown", globalKeyDownHandler);
    window.addEventListener("click", globalClickHandler);
  }
  if (!typeToDropZones2.has(type)) {
    typeToDropZones2.set(type, /* @__PURE__ */ new Set());
  }
  if (!typeToDropZones2.get(type).has(dropZoneEl)) {
    typeToDropZones2.get(type).add(dropZoneEl);
    incrementActiveDropZoneCount();
  }
}
function unregisterDropZone2(dropZoneEl, type) {
  printDebug(() => "unregistering drop-zone");
  if (focusedDz === dropZoneEl) {
    handleDrop2();
  }
  typeToDropZones2.get(type).delete(dropZoneEl);
  decrementActiveDropZoneCount();
  if (typeToDropZones2.get(type).size === 0) {
    typeToDropZones2.delete(type);
  }
  if (typeToDropZones2.size === 0) {
    printDebug(() => "removing global keydown and click handlers");
    window.removeEventListener("keydown", globalKeyDownHandler);
    window.removeEventListener("click", globalClickHandler);
    INSTRUCTION_IDs2 = void 0;
    destroyAria();
  }
}
function globalKeyDownHandler(e) {
  if (!isDragging)
    return;
  switch (e.key) {
    case "Escape": {
      handleDrop2();
      break;
    }
  }
}
function globalClickHandler() {
  if (!isDragging)
    return;
  if (!allDragTargets.has(document.activeElement)) {
    printDebug(() => "clicked outside of any draggable");
    handleDrop2();
  }
}
function handleZoneFocus(e) {
  printDebug(() => "zone focus");
  if (!isDragging)
    return;
  const newlyFocusedDz = e.currentTarget;
  if (newlyFocusedDz === focusedDz)
    return;
  focusedDzLabel = newlyFocusedDz.getAttribute("aria-label") || "";
  const { items: originItems } = dzToConfig2.get(focusedDz);
  const originItem = originItems.find((item) => item[ITEM_ID_KEY] === focusedItemId);
  const originIdx = originItems.indexOf(originItem);
  const itemToMove = originItems.splice(originIdx, 1)[0];
  const { items: targetItems, autoAriaDisabled } = dzToConfig2.get(newlyFocusedDz);
  if (newlyFocusedDz.getBoundingClientRect().top < focusedDz.getBoundingClientRect().top || newlyFocusedDz.getBoundingClientRect().left < focusedDz.getBoundingClientRect().left) {
    targetItems.push(itemToMove);
    if (!autoAriaDisabled) {
      alertToScreenReader(`Moved item ${focusedItemLabel} to the end of the list ${focusedDzLabel}`);
    }
  } else {
    targetItems.unshift(itemToMove);
    if (!autoAriaDisabled) {
      alertToScreenReader(`Moved item ${focusedItemLabel} to the beginning of the list ${focusedDzLabel}`);
    }
  }
  const dzFrom = focusedDz;
  dispatchFinalizeEvent(dzFrom, originItems, { trigger: TRIGGERS.DROPPED_INTO_ANOTHER, id: focusedItemId, source: SOURCES.KEYBOARD });
  dispatchFinalizeEvent(newlyFocusedDz, targetItems, { trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD });
  focusedDz = newlyFocusedDz;
}
function triggerAllDzsUpdate() {
  dzToHandles.forEach(({ update: update2 }, dz) => update2(dzToConfig2.get(dz)));
}
function handleDrop2(dispatchConsider = true) {
  printDebug(() => "drop");
  if (!dzToConfig2.get(focusedDz).autoAriaDisabled) {
    alertToScreenReader(`Stopped dragging item ${focusedItemLabel}`);
  }
  if (allDragTargets.has(document.activeElement)) {
    document.activeElement.blur();
  }
  if (dispatchConsider) {
    dispatchConsiderEvent(focusedDz, dzToConfig2.get(focusedDz).items, {
      trigger: TRIGGERS.DRAG_STOPPED,
      id: focusedItemId,
      source: SOURCES.KEYBOARD
    });
  }
  styleInactiveDropZones(
    typeToDropZones2.get(draggedItemType),
    (dz) => dzToConfig2.get(dz).dropTargetStyle,
    (dz) => dzToConfig2.get(dz).dropTargetClasses
  );
  focusedItem = null;
  focusedItemId = null;
  focusedItemLabel = "";
  draggedItemType = null;
  focusedDz = null;
  focusedDzLabel = "";
  isDragging = false;
  triggerAllDzsUpdate();
}
function dndzone2(node, options) {
  const config = {
    items: void 0,
    type: void 0,
    dragDisabled: false,
    zoneTabIndex: 0,
    dropFromOthersDisabled: false,
    dropTargetStyle: DEFAULT_DROP_TARGET_STYLE2,
    dropTargetClasses: [],
    autoAriaDisabled: false
  };
  function swap(arr, i, j) {
    if (arr.length <= 1)
      return;
    arr.splice(j, 1, arr.splice(i, 1, arr[j])[0]);
  }
  function handleKeyDown(e) {
    printDebug(() => ["handling key down", e.key]);
    switch (e.key) {
      case "Enter":
      case " ": {
        if ((e.target.disabled !== void 0 || e.target.href || e.target.isContentEditable) && !allDragTargets.has(e.target)) {
          return;
        }
        e.preventDefault();
        e.stopPropagation();
        if (isDragging) {
          handleDrop2();
        } else {
          handleDragStart(e);
        }
        break;
      }
      case "ArrowDown":
      case "ArrowRight": {
        if (!isDragging)
          return;
        e.preventDefault();
        e.stopPropagation();
        const { items } = dzToConfig2.get(node);
        const children2 = Array.from(node.children);
        const idx = children2.indexOf(e.currentTarget);
        printDebug(() => ["arrow down", idx]);
        if (idx < children2.length - 1) {
          if (!config.autoAriaDisabled) {
            alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx + 2} in the list ${focusedDzLabel}`);
          }
          swap(items, idx, idx + 1);
          dispatchFinalizeEvent(node, items, { trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD });
        }
        break;
      }
      case "ArrowUp":
      case "ArrowLeft": {
        if (!isDragging)
          return;
        e.preventDefault();
        e.stopPropagation();
        const { items } = dzToConfig2.get(node);
        const children2 = Array.from(node.children);
        const idx = children2.indexOf(e.currentTarget);
        printDebug(() => ["arrow up", idx]);
        if (idx > 0) {
          if (!config.autoAriaDisabled) {
            alertToScreenReader(`Moved item ${focusedItemLabel} to position ${idx} in the list ${focusedDzLabel}`);
          }
          swap(items, idx, idx - 1);
          dispatchFinalizeEvent(node, items, { trigger: TRIGGERS.DROPPED_INTO_ZONE, id: focusedItemId, source: SOURCES.KEYBOARD });
        }
        break;
      }
    }
  }
  function handleDragStart(e) {
    printDebug(() => "drag start");
    setCurrentFocusedItem(e.currentTarget);
    focusedDz = node;
    draggedItemType = config.type;
    isDragging = true;
    const dropTargets = Array.from(typeToDropZones2.get(config.type)).filter((dz) => dz === focusedDz || !dzToConfig2.get(dz).dropFromOthersDisabled);
    styleActiveDropZones(
      dropTargets,
      (dz) => dzToConfig2.get(dz).dropTargetStyle,
      (dz) => dzToConfig2.get(dz).dropTargetClasses
    );
    if (!config.autoAriaDisabled) {
      let msg = `Started dragging item ${focusedItemLabel}. Use the arrow keys to move it within its list ${focusedDzLabel}`;
      if (dropTargets.length > 1) {
        msg += `, or tab to another list in order to move the item into it`;
      }
      alertToScreenReader(msg);
    }
    dispatchConsiderEvent(node, dzToConfig2.get(node).items, { trigger: TRIGGERS.DRAG_STARTED, id: focusedItemId, source: SOURCES.KEYBOARD });
    triggerAllDzsUpdate();
  }
  function handleClick(e) {
    if (!isDragging)
      return;
    if (e.currentTarget === focusedItem)
      return;
    e.stopPropagation();
    handleDrop2(false);
    handleDragStart(e);
  }
  function setCurrentFocusedItem(draggableEl) {
    const { items } = dzToConfig2.get(node);
    const children2 = Array.from(node.children);
    const focusedItemIdx = children2.indexOf(draggableEl);
    focusedItem = draggableEl;
    focusedItem.tabIndex = 0;
    focusedItemId = items[focusedItemIdx][ITEM_ID_KEY];
    focusedItemLabel = children2[focusedItemIdx].getAttribute("aria-label") || "";
  }
  function configure({
    items = [],
    type: newType = DEFAULT_DROP_ZONE_TYPE2,
    dragDisabled = false,
    zoneTabIndex = 0,
    dropFromOthersDisabled = false,
    dropTargetStyle = DEFAULT_DROP_TARGET_STYLE2,
    dropTargetClasses = [],
    autoAriaDisabled = false
  }) {
    config.items = [...items];
    config.dragDisabled = dragDisabled;
    config.dropFromOthersDisabled = dropFromOthersDisabled;
    config.zoneTabIndex = zoneTabIndex;
    config.dropTargetStyle = dropTargetStyle;
    config.dropTargetClasses = dropTargetClasses;
    config.autoAriaDisabled = autoAriaDisabled;
    if (config.type && newType !== config.type) {
      unregisterDropZone2(node, config.type);
    }
    config.type = newType;
    registerDropZone2(node, newType);
    if (!autoAriaDisabled) {
      node.setAttribute("aria-disabled", dragDisabled);
      node.setAttribute("role", "list");
      node.setAttribute("aria-describedby", dragDisabled ? INSTRUCTION_IDs2.DND_ZONE_DRAG_DISABLED : INSTRUCTION_IDs2.DND_ZONE_ACTIVE);
    }
    dzToConfig2.set(node, config);
    if (isDragging) {
      node.tabIndex = node === focusedDz || focusedItem.contains(node) || config.dropFromOthersDisabled || focusedDz && config.type !== dzToConfig2.get(focusedDz).type ? -1 : 0;
    } else {
      node.tabIndex = config.zoneTabIndex;
    }
    node.addEventListener("focus", handleZoneFocus);
    for (let i = 0; i < node.children.length; i++) {
      const draggableEl = node.children[i];
      allDragTargets.add(draggableEl);
      draggableEl.tabIndex = isDragging ? -1 : 0;
      if (!autoAriaDisabled) {
        draggableEl.setAttribute("role", "listitem");
      }
      draggableEl.removeEventListener("keydown", elToKeyDownListeners.get(draggableEl));
      draggableEl.removeEventListener("click", elToFocusListeners.get(draggableEl));
      if (!dragDisabled) {
        draggableEl.addEventListener("keydown", handleKeyDown);
        elToKeyDownListeners.set(draggableEl, handleKeyDown);
        draggableEl.addEventListener("click", handleClick);
        elToFocusListeners.set(draggableEl, handleClick);
      }
      if (isDragging && config.items[i][ITEM_ID_KEY] === focusedItemId) {
        printDebug(() => ["focusing on", { i, focusedItemId }]);
        focusedItem = draggableEl;
        focusedItem.tabIndex = 0;
        draggableEl.focus();
      }
    }
  }
  configure(options);
  const handles = {
    update: (newOptions) => {
      printDebug(() => `keyboard dndzone will update newOptions: ${toString(newOptions)}`);
      configure(newOptions);
    },
    destroy: () => {
      printDebug(() => "keyboard dndzone will destroy");
      unregisterDropZone2(node, config.type);
      dzToConfig2.delete(node);
      dzToHandles.delete(node);
    }
  };
  dzToHandles.set(node, handles);
  return handles;
}

// node_modules/.pnpm/svelte-dnd-action@0.9.22_svelte@3.55.1/node_modules/svelte-dnd-action/src/action.js
function dndzone3(node, options) {
  validateOptions(options);
  const pointerZone = dndzone(node, options);
  const keyboardZone = dndzone2(node, options);
  return {
    update: (newOptions) => {
      validateOptions(newOptions);
      pointerZone.update(newOptions);
      keyboardZone.update(newOptions);
    },
    destroy: () => {
      pointerZone.destroy();
      keyboardZone.destroy();
    }
  };
}
function validateOptions(options) {
  const {
    items,
    flipDurationMs,
    type,
    dragDisabled,
    morphDisabled,
    dropFromOthersDisabled,
    zoneTabIndex,
    dropTargetStyle,
    dropTargetClasses,
    transformDraggedElement,
    autoAriaDisabled,
    centreDraggedOnCursor,
    ...rest
  } = options;
  if (Object.keys(rest).length > 0) {
    console.warn(`dndzone will ignore unknown options`, rest);
  }
  if (!items) {
    throw new Error("no 'items' key provided to dndzone");
  }
  const itemWithMissingId = items.find((item) => !{}.hasOwnProperty.call(item, ITEM_ID_KEY));
  if (itemWithMissingId) {
    throw new Error(`missing '${ITEM_ID_KEY}' property for item ${toString(itemWithMissingId)}`);
  }
  if (dropTargetClasses && !Array.isArray(dropTargetClasses)) {
    throw new Error(`dropTargetClasses should be an array but instead it is a ${typeof dropTargetClasses}, ${toString(dropTargetClasses)}`);
  }
  if (zoneTabIndex && !isInt(zoneTabIndex)) {
    throw new Error(`zoneTabIndex should be a number but instead it is a ${typeof zoneTabIndex}, ${toString(zoneTabIndex)}`);
  }
}
function isInt(value) {
  return !isNaN(value) && function(x) {
    return (x | 0) === x;
  }(parseFloat(value));
}

// src/gui/choiceList/ChoiceList.svelte
function add_css5(target) {
  append_styles(target, "svelte-jb273g", ".choiceList.svelte-jb273g{width:auto;border:0 solid black;overflow-y:auto;height:auto}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  child_ctx[24] = list;
  child_ctx[25] = i;
  return child_ctx;
}
function create_else_block(ctx) {
  let multichoicelistitem;
  let updating_dragDisabled;
  let updating_collapseId;
  let updating_choice;
  let current;
  function multichoicelistitem_dragDisabled_binding(value) {
    ctx[14](value);
  }
  function multichoicelistitem_collapseId_binding(value) {
    ctx[15](value);
  }
  function multichoicelistitem_choice_binding(value) {
    ctx[16](value, ctx[23], ctx[24], ctx[25]);
  }
  let multichoicelistitem_props = {};
  if (ctx[3] !== void 0) {
    multichoicelistitem_props.dragDisabled = ctx[3];
  }
  if (ctx[2] !== void 0) {
    multichoicelistitem_props.collapseId = ctx[2];
  }
  if (ctx[23] !== void 0) {
    multichoicelistitem_props.choice = ctx[23];
  }
  multichoicelistitem = new MultiChoiceListItem_default({ props: multichoicelistitem_props });
  binding_callbacks.push(() => bind(multichoicelistitem, "dragDisabled", multichoicelistitem_dragDisabled_binding));
  binding_callbacks.push(() => bind(multichoicelistitem, "collapseId", multichoicelistitem_collapseId_binding));
  binding_callbacks.push(() => bind(multichoicelistitem, "choice", multichoicelistitem_choice_binding));
  multichoicelistitem.$on("mousedown", ctx[6]);
  multichoicelistitem.$on("touchstart", ctx[6]);
  multichoicelistitem.$on("deleteChoice", ctx[17]);
  multichoicelistitem.$on("configureChoice", ctx[18]);
  multichoicelistitem.$on("toggleCommand", ctx[19]);
  multichoicelistitem.$on("duplicateChoice", ctx[20]);
  return {
    c() {
      create_component(multichoicelistitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(multichoicelistitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const multichoicelistitem_changes = {};
      if (!updating_dragDisabled && dirty & 8) {
        updating_dragDisabled = true;
        multichoicelistitem_changes.dragDisabled = ctx[3];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      if (!updating_collapseId && dirty & 4) {
        updating_collapseId = true;
        multichoicelistitem_changes.collapseId = ctx[2];
        add_flush_callback(() => updating_collapseId = false);
      }
      if (!updating_choice && dirty & 3) {
        updating_choice = true;
        multichoicelistitem_changes.choice = ctx[23];
        add_flush_callback(() => updating_choice = false);
      }
      multichoicelistitem.$set(multichoicelistitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(multichoicelistitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(multichoicelistitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(multichoicelistitem, detaching);
    }
  };
}
function create_if_block4(ctx) {
  let choicelistitem;
  let updating_dragDisabled;
  let updating_choice;
  let current;
  function choicelistitem_dragDisabled_binding(value) {
    ctx[8](value);
  }
  function choicelistitem_choice_binding(value) {
    ctx[9](value, ctx[23], ctx[24], ctx[25]);
  }
  let choicelistitem_props = {};
  if (ctx[3] !== void 0) {
    choicelistitem_props.dragDisabled = ctx[3];
  }
  if (ctx[23] !== void 0) {
    choicelistitem_props.choice = ctx[23];
  }
  choicelistitem = new ChoiceListItem_default({ props: choicelistitem_props });
  binding_callbacks.push(() => bind(choicelistitem, "dragDisabled", choicelistitem_dragDisabled_binding));
  binding_callbacks.push(() => bind(choicelistitem, "choice", choicelistitem_choice_binding));
  choicelistitem.$on("mousedown", ctx[6]);
  choicelistitem.$on("touchstart", ctx[6]);
  choicelistitem.$on("deleteChoice", ctx[10]);
  choicelistitem.$on("configureChoice", ctx[11]);
  choicelistitem.$on("toggleCommand", ctx[12]);
  choicelistitem.$on("duplicateChoice", ctx[13]);
  return {
    c() {
      create_component(choicelistitem.$$.fragment);
    },
    m(target, anchor) {
      mount_component(choicelistitem, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const choicelistitem_changes = {};
      if (!updating_dragDisabled && dirty & 8) {
        updating_dragDisabled = true;
        choicelistitem_changes.dragDisabled = ctx[3];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      if (!updating_choice && dirty & 3) {
        updating_choice = true;
        choicelistitem_changes.choice = ctx[23];
        add_flush_callback(() => updating_choice = false);
      }
      choicelistitem.$set(choicelistitem_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(choicelistitem.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(choicelistitem.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(choicelistitem, detaching);
    }
  };
}
function create_each_block2(key_1, ctx) {
  let first;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block4, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[23].type !== "Multi" /* Multi */)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment9(ctx) {
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let div_style_value;
  let dndzone_action;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[0].filter(ctx[7]);
  const get_key = (ctx2) => ctx2[23].id;
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context2(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block2(key, child_ctx));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "choiceList svelte-jb273g");
      attr(div, "style", div_style_value = ctx[0].length === 0 ? "padding-bottom: 0.5rem" : "");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(dndzone_action = dndzone3.call(null, div, {
            items: ctx[0],
            dragDisabled: ctx[3],
            dropTargetStyle: {}
          })),
          listen(div, "consider", ctx[4]),
          listen(div, "finalize", ctx[5])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 79) {
        each_value = ctx2[0].filter(ctx2[7]);
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block2, null, get_each_context2);
        check_outros();
      }
      if (!current || dirty & 1 && div_style_value !== (div_style_value = ctx2[0].length === 0 ? "padding-bottom: 0.5rem" : "")) {
        attr(div, "style", div_style_value);
      }
      if (dndzone_action && is_function(dndzone_action.update) && dirty & 9)
        dndzone_action.update.call(null, {
          items: ctx2[0],
          dragDisabled: ctx2[3],
          dropTargetStyle: {}
        });
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { choices = [] } = $$props;
  let collapseId;
  let dragDisabled = true;
  const dispatcher = createEventDispatcher();
  function emitChoicesReordered() {
    dispatcher("reorderChoices", { choices });
  }
  function handleConsider(e) {
    let { items: newItems, info: { id } } = e.detail;
    $$invalidate(2, collapseId = id);
    $$invalidate(0, choices = newItems);
  }
  function handleSort(e) {
    let { items: newItems, info: { source } } = e.detail;
    $$invalidate(2, collapseId = "");
    $$invalidate(0, choices = newItems);
    if (source === SOURCES.POINTER) {
      $$invalidate(3, dragDisabled = true);
    }
    emitChoicesReordered();
  }
  function startDrag(e) {
    e.preventDefault();
    $$invalidate(3, dragDisabled = false);
  }
  const func = (c) => c.id !== SHADOW_PLACEHOLDER_ITEM_ID;
  function choicelistitem_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(3, dragDisabled);
  }
  function choicelistitem_choice_binding(value, choice, each_value, choice_index) {
    each_value[choice_index] = value;
    $$invalidate(0, choices);
  }
  function deleteChoice_handler(event) {
    bubble.call(this, $$self, event);
  }
  function configureChoice_handler(event) {
    bubble.call(this, $$self, event);
  }
  function toggleCommand_handler(event) {
    bubble.call(this, $$self, event);
  }
  function duplicateChoice_handler(event) {
    bubble.call(this, $$self, event);
  }
  function multichoicelistitem_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(3, dragDisabled);
  }
  function multichoicelistitem_collapseId_binding(value) {
    collapseId = value;
    $$invalidate(2, collapseId);
  }
  function multichoicelistitem_choice_binding(value, choice, each_value, choice_index) {
    each_value[choice_index] = value;
    $$invalidate(0, choices);
  }
  function deleteChoice_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function configureChoice_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function toggleCommand_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function duplicateChoice_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("choices" in $$props2)
      $$invalidate(0, choices = $$props2.choices);
  };
  return [
    choices,
    SHADOW_PLACEHOLDER_ITEM_ID,
    collapseId,
    dragDisabled,
    handleConsider,
    handleSort,
    startDrag,
    func,
    choicelistitem_dragDisabled_binding,
    choicelistitem_choice_binding,
    deleteChoice_handler,
    configureChoice_handler,
    toggleCommand_handler,
    duplicateChoice_handler,
    multichoicelistitem_dragDisabled_binding,
    multichoicelistitem_collapseId_binding,
    multichoicelistitem_choice_binding,
    deleteChoice_handler_1,
    configureChoice_handler_1,
    toggleCommand_handler_1,
    duplicateChoice_handler_1
  ];
}
var ChoiceList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, { choices: 0 }, add_css5);
  }
};
var ChoiceList_default = ChoiceList;

// src/gui/choiceList/AddChoiceBox.svelte
var import_obsidian = require("obsidian");
function add_css6(target) {
  append_styles(target, "svelte-1newuee", ".addChoiceBox.svelte-1newuee{margin-top:1em;display:flex;flex-direction:row;align-items:center;gap:10px;justify-content:center}@media(max-width: 800px){.addChoiceBox.svelte-1newuee{flex-direction:column}}#addChoiceTypeSelector.svelte-1newuee{font-size:16px;padding:3px;border-radius:3px}");
}
function create_fragment10(ctx) {
  let div;
  let input;
  let t0;
  let select;
  let option0;
  let t1_value = "Template" /* Template */ + "";
  let t1;
  let option0_value_value;
  let option1;
  let t2_value = "Capture" /* Capture */ + "";
  let t2;
  let option1_value_value;
  let option2;
  let t3_value = "Macro" /* Macro */ + "";
  let t3;
  let option2_value_value;
  let option3;
  let t4_value = "Multi" /* Multi */ + "";
  let t4;
  let option3_value_value;
  let t5;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      t0 = space();
      select = element("select");
      option0 = element("option");
      t1 = text(t1_value);
      option1 = element("option");
      t2 = text(t2_value);
      option2 = element("option");
      t3 = text(t3_value);
      option3 = element("option");
      t4 = text(t4_value);
      t5 = space();
      button = element("button");
      button.textContent = "Add Choice";
      attr(input, "type", "text");
      attr(input, "placeholder", "Name");
      option0.__value = option0_value_value = "Template" /* Template */;
      option0.value = option0.__value;
      option1.__value = option1_value_value = "Capture" /* Capture */;
      option1.value = option1.__value;
      option2.__value = option2_value_value = "Macro" /* Macro */;
      option2.value = option2.__value;
      option3.__value = option3_value_value = "Multi" /* Multi */;
      option3.value = option3.__value;
      attr(select, "id", "addChoiceTypeSelector");
      attr(select, "class", "svelte-1newuee");
      if (ctx[1] === void 0)
        add_render_callback(() => ctx[4].call(select));
      attr(button, "class", "mod-cta");
      attr(div, "class", "addChoiceBox svelte-1newuee");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, input);
      set_input_value(input, ctx[0]);
      append(div, t0);
      append(div, select);
      append(select, option0);
      append(option0, t1);
      append(select, option1);
      append(option1, t2);
      append(select, option2);
      append(option2, t3);
      append(select, option3);
      append(option3, t4);
      select_option(select, ctx[1]);
      append(div, t5);
      append(div, button);
      if (!mounted) {
        dispose = [
          listen(input, "input", ctx[3]),
          listen(select, "change", ctx[4]),
          listen(button, "click", ctx[2])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 1 && input.value !== ctx2[0]) {
        set_input_value(input, ctx2[0]);
      }
      if (dirty & 2) {
        select_option(select, ctx2[1]);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance10($$self, $$props, $$invalidate) {
  let name;
  let type;
  const dispatch = createEventDispatcher();
  function addChoice() {
    if (!name) {
      new import_obsidian.Notice("Choice name is invalid.");
      return;
    }
    dispatch("addChoice", { name, type });
    $$invalidate(0, name = "");
  }
  function input_input_handler() {
    name = this.value;
    $$invalidate(0, name);
  }
  function select_change_handler() {
    type = select_value(this);
    $$invalidate(1, type);
  }
  return [name, type, addChoice, input_input_handler, select_change_handler];
}
var AddChoiceBox = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance10, create_fragment10, safe_not_equal, {}, add_css6);
  }
};
var AddChoiceBox_default = AddChoiceBox;

// node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset2 = 0) {
  return (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
}

// node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/.pnpm/uuid@9.0.0/node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset2) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset2 = offset2 || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset2 + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// src/types/choices/Choice.ts
var Choice = class {
  constructor(name, type) {
    this.id = v4_default();
    this.name = name;
    this.type = type;
    this.command = false;
  }
};

// src/types/choices/TemplateChoice.ts
var TemplateChoice = class extends Choice {
  constructor(name) {
    super(name, "Template" /* Template */);
    this.templatePath = "";
    this.fileNameFormat = { enabled: false, format: "" };
    this.folder = {
      enabled: false,
      folders: [],
      chooseWhenCreatingNote: false,
      createInSameFolderAsActiveFile: false,
      chooseFromSubfolders: false
    };
    this.appendLink = false;
    this.incrementFileName = false;
    this.openFileInNewTab = {
      enabled: false,
      direction: "vertical" /* vertical */,
      focus: true
    };
    this.openFile = false;
    this.openFileInMode = "default";
  }
  static Load(choice) {
    return choice;
  }
};

// src/types/choices/MacroChoice.ts
var MacroChoice = class extends Choice {
  constructor(name) {
    super(name, "Macro" /* Macro */);
    this.macroId = null;
  }
};

// src/types/choices/CaptureChoice.ts
var CaptureChoice = class extends Choice {
  constructor(name) {
    super(name, "Capture" /* Capture */);
    this.appendLink = false;
    this.captureTo = "";
    this.captureToActiveFile = false;
    this.createFileIfItDoesntExist = {
      enabled: false,
      createWithTemplate: false,
      template: ""
    };
    this.format = { enabled: false, format: "" };
    this.insertAfter = {
      enabled: false,
      after: "",
      insertAtEnd: false,
      createIfNotFound: false,
      createIfNotFoundLocation: "top"
    };
    this.prepend = false;
    this.task = false;
    this.openFileInNewTab = {
      enabled: false,
      direction: "vertical" /* vertical */,
      focus: true
    };
    this.openFile = false;
    this.openFileInMode = "default";
  }
  static Load(choice) {
    return choice;
  }
};

// src/types/choices/MultiChoice.ts
var MultiChoice = class extends Choice {
  constructor(name) {
    super(name, "Multi" /* Multi */);
    this.choices = [];
  }
  addChoice(choice) {
    this.choices.push(choice);
    return this;
  }
  addChoices(choices) {
    this.choices.push(...choices);
    return this;
  }
};

// src/gui/GenericYesNoPrompt/GenericYesNoPrompt.ts
var import_obsidian2 = require("obsidian");
var GenericYesNoPrompt = class extends import_obsidian2.Modal {
  constructor(app2, header, text2) {
    super(app2);
    this.header = header;
    this.text = text2;
    this.didSubmit = false;
    this.waitForClose = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
      this.rejectPromise = reject;
    });
    this.open();
    this.display();
  }
  static Prompt(app2, header, text2) {
    const newPromptModal = new GenericYesNoPrompt(app2, header, text2);
    return newPromptModal.waitForClose;
  }
  display() {
    this.containerEl.addClass("quickAddModal", "qaYesNoPrompt");
    this.contentEl.empty();
    this.titleEl.textContent = this.header;
    this.contentEl.createEl("p", { text: this.text });
    const buttonsDiv = this.contentEl.createDiv({
      cls: "yesNoPromptButtonContainer"
    });
    const noButton = new import_obsidian2.ButtonComponent(buttonsDiv).setButtonText("No").onClick(() => this.submit(false));
    const yesButton = new import_obsidian2.ButtonComponent(buttonsDiv).setButtonText("Yes").onClick(() => this.submit(true)).setWarning();
    yesButton.buttonEl.focus();
  }
  submit(input) {
    this.input = input;
    this.didSubmit = true;
    this.close();
  }
  onClose() {
    super.onClose();
    if (!this.didSubmit)
      this.rejectPromise("No answer given.");
    else
      this.resolvePromise(this.input);
  }
};

// src/gui/choiceList/ChoiceView.svelte
var import_obsidian24 = require("obsidian");

// src/gui/ChoiceBuilder/choiceBuilder.ts
var import_obsidian5 = require("obsidian");

// src/gui/GenericInputPrompt/GenericInputPrompt.ts
var import_obsidian4 = require("obsidian");

// src/gui/suggesters/suggest.ts
var import_obsidian3 = require("obsidian");

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/enums.js
var top = "top";
var bottom = "bottom";
var right = "right";
var left = "left";
var auto = "auto";
var basePlacements = [top, bottom, right, left];
var start = "start";
var end = "end";
var clippingParents = "clippingParents";
var viewport = "viewport";
var popper = "popper";
var reference = "reference";
var variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {
  return acc.concat([placement + "-" + start, placement + "-" + end]);
}, []);
var placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {
  return acc.concat([placement, placement + "-" + start, placement + "-" + end]);
}, []);
var beforeRead = "beforeRead";
var read = "read";
var afterRead = "afterRead";
var beforeMain = "beforeMain";
var main = "main";
var afterMain = "afterMain";
var beforeWrite = "beforeWrite";
var write = "write";
var afterWrite = "afterWrite";
var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js
function getNodeName(element2) {
  return element2 ? (element2.nodeName || "").toLowerCase() : null;
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getWindow.js
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (node.toString() !== "[object Window]") {
    var ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js
function isElement(node) {
  var OwnElement = getWindow(node).Element;
  return node instanceof OwnElement || node instanceof Element;
}
function isHTMLElement(node) {
  var OwnElement = getWindow(node).HTMLElement;
  return node instanceof OwnElement || node instanceof HTMLElement;
}
function isShadowRoot(node) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  var OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/modifiers/applyStyles.js
function applyStyles(_ref) {
  var state = _ref.state;
  Object.keys(state.elements).forEach(function(name) {
    var style = state.styles[name] || {};
    var attributes = state.attributes[name] || {};
    var element2 = state.elements[name];
    if (!isHTMLElement(element2) || !getNodeName(element2)) {
      return;
    }
    Object.assign(element2.style, style);
    Object.keys(attributes).forEach(function(name2) {
      var value = attributes[name2];
      if (value === false) {
        element2.removeAttribute(name2);
      } else {
        element2.setAttribute(name2, value === true ? "" : value);
      }
    });
  });
}
function effect(_ref2) {
  var state = _ref2.state;
  var initialStyles = {
    popper: {
      position: state.options.strategy,
      left: "0",
      top: "0",
      margin: "0"
    },
    arrow: {
      position: "absolute"
    },
    reference: {}
  };
  Object.assign(state.elements.popper.style, initialStyles.popper);
  state.styles = initialStyles;
  if (state.elements.arrow) {
    Object.assign(state.elements.arrow.style, initialStyles.arrow);
  }
  return function() {
    Object.keys(state.elements).forEach(function(name) {
      var element2 = state.elements[name];
      var attributes = state.attributes[name] || {};
      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
      var style = styleProperties.reduce(function(style2, property) {
        style2[property] = "";
        return style2;
      }, {});
      if (!isHTMLElement(element2) || !getNodeName(element2)) {
        return;
      }
      Object.assign(element2.style, style);
      Object.keys(attributes).forEach(function(attribute) {
        element2.removeAttribute(attribute);
      });
    });
  };
}
var applyStyles_default = {
  name: "applyStyles",
  enabled: true,
  phase: "write",
  fn: applyStyles,
  effect,
  requires: ["computeStyles"]
};

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/getBasePlacement.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/math.js
var max = Math.max;
var min = Math.min;
var round = Math.round;

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/userAgent.js
function getUAString() {
  var uaData = navigator.userAgentData;
  if (uaData != null && uaData.brands) {
    return uaData.brands.map(function(item) {
      return item.brand + "/" + item.version;
    }).join(" ");
  }
  return navigator.userAgent;
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js
function isLayoutViewport() {
  return !/^((?!chrome|android).)*safari/i.test(getUAString());
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js
function getBoundingClientRect(element2, includeScale, isFixedStrategy) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element2.getBoundingClientRect();
  var scaleX = 1;
  var scaleY = 1;
  if (includeScale && isHTMLElement(element2)) {
    scaleX = element2.offsetWidth > 0 ? round(clientRect.width) / element2.offsetWidth || 1 : 1;
    scaleY = element2.offsetHeight > 0 ? round(clientRect.height) / element2.offsetHeight || 1 : 1;
  }
  var _ref = isElement(element2) ? getWindow(element2) : window, visualViewport = _ref.visualViewport;
  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
  var width = clientRect.width / scaleX;
  var height = clientRect.height / scaleY;
  return {
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x,
    x,
    y
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js
function getLayoutRect(element2) {
  var clientRect = getBoundingClientRect(element2);
  var width = element2.offsetWidth;
  var height = element2.offsetHeight;
  if (Math.abs(clientRect.width - width) <= 1) {
    width = clientRect.width;
  }
  if (Math.abs(clientRect.height - height) <= 1) {
    height = clientRect.height;
  }
  return {
    x: element2.offsetLeft,
    y: element2.offsetTop,
    width,
    height
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/contains.js
function contains(parent, child) {
  var rootNode = child.getRootNode && child.getRootNode();
  if (parent.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    var next3 = child;
    do {
      if (next3 && parent.isSameNode(next3)) {
        return true;
      }
      next3 = next3.parentNode || next3.host;
    } while (next3);
  }
  return false;
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/isTableElement.js
function isTableElement(element2) {
  return ["table", "td", "th"].indexOf(getNodeName(element2)) >= 0;
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js
function getDocumentElement(element2) {
  return ((isElement(element2) ? element2.ownerDocument : element2.document) || window.document).documentElement;
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js
function getParentNode(element2) {
  if (getNodeName(element2) === "html") {
    return element2;
  }
  return element2.assignedSlot || element2.parentNode || (isShadowRoot(element2) ? element2.host : null) || getDocumentElement(element2);
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js
function getTrueOffsetParent(element2) {
  if (!isHTMLElement(element2) || getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  return element2.offsetParent;
}
function getContainingBlock(element2) {
  var isFirefox = /firefox/i.test(getUAString());
  var isIE = /Trident/i.test(getUAString());
  if (isIE && isHTMLElement(element2)) {
    var elementCss = getComputedStyle2(element2);
    if (elementCss.position === "fixed") {
      return null;
    }
  }
  var currentNode = getParentNode(element2);
  if (isShadowRoot(currentNode)) {
    currentNode = currentNode.host;
  }
  while (isHTMLElement(currentNode) && ["html", "body"].indexOf(getNodeName(currentNode)) < 0) {
    var css = getComputedStyle2(currentNode);
    if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element2) {
  var window2 = getWindow(element2);
  var offsetParent = getTrueOffsetParent(element2);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static")) {
    return window2;
  }
  return offsetParent || getContainingBlock(element2) || window2;
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/within.js
function within(min2, value, max2) {
  return max(min2, min(value, max2));
}
function withinMaxClamp(min2, value, max2) {
  var v = within(min2, value, max2);
  return v > max2 ? max2 : v;
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/getFreshSideObject.js
function getFreshSideObject() {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js
function mergePaddingObject(paddingObject) {
  return Object.assign({}, getFreshSideObject(), paddingObject);
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/expandToHashMap.js
function expandToHashMap(value, keys) {
  return keys.reduce(function(hashMap, key) {
    hashMap[key] = value;
    return hashMap;
  }, {});
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/modifiers/arrow.js
var toPaddingObject = function toPaddingObject2(padding, state) {
  padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
    placement: state.placement
  })) : padding;
  return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
};
function arrow(_ref) {
  var _state$modifiersData$;
  var state = _ref.state, name = _ref.name, options = _ref.options;
  var arrowElement = state.elements.arrow;
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var basePlacement = getBasePlacement(state.placement);
  var axis = getMainAxisFromPlacement(basePlacement);
  var isVertical = [left, right].indexOf(basePlacement) >= 0;
  var len = isVertical ? "height" : "width";
  if (!arrowElement || !popperOffsets2) {
    return;
  }
  var paddingObject = toPaddingObject(options.padding, state);
  var arrowRect = getLayoutRect(arrowElement);
  var minProp = axis === "y" ? top : left;
  var maxProp = axis === "y" ? bottom : right;
  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];
  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];
  var arrowOffsetParent = getOffsetParent(arrowElement);
  var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
  var centerToReference = endDiff / 2 - startDiff / 2;
  var min2 = paddingObject[minProp];
  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];
  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
  var offset2 = within(min2, center, max2);
  var axisProp = axis;
  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);
}
function effect2(_ref2) {
  var state = _ref2.state, options = _ref2.options;
  var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
  if (arrowElement == null) {
    return;
  }
  if (typeof arrowElement === "string") {
    arrowElement = state.elements.popper.querySelector(arrowElement);
    if (!arrowElement) {
      return;
    }
  }
  if (true) {
    if (!isHTMLElement(arrowElement)) {
      console.error(['Popper: "arrow" element must be an HTMLElement (not an SVGElement).', "To use an SVG arrow, wrap it in an HTMLElement that will be used as", "the arrow."].join(" "));
    }
  }
  if (!contains(state.elements.popper, arrowElement)) {
    if (true) {
      console.error(['Popper: "arrow" modifier\'s `element` must be a child of the popper', "element."].join(" "));
    }
    return;
  }
  state.elements.arrow = arrowElement;
}
var arrow_default = {
  name: "arrow",
  enabled: true,
  phase: "main",
  fn: arrow,
  effect: effect2,
  requires: ["popperOffsets"],
  requiresIfExists: ["preventOverflow"]
};

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/getVariation.js
function getVariation(placement) {
  return placement.split("-")[1];
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/modifiers/computeStyles.js
var unsetSides = {
  top: "auto",
  right: "auto",
  bottom: "auto",
  left: "auto"
};
function roundOffsetsByDPR(_ref) {
  var x = _ref.x, y = _ref.y;
  var win = window;
  var dpr = win.devicePixelRatio || 1;
  return {
    x: round(x * dpr) / dpr || 0,
    y: round(y * dpr) / dpr || 0
  };
}
function mapToStyles(_ref2) {
  var _Object$assign2;
  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
  var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref3.x;
  y = _ref3.y;
  var hasX = offsets.hasOwnProperty("x");
  var hasY = offsets.hasOwnProperty("y");
  var sideX = left;
  var sideY = top;
  var win = window;
  if (adaptive) {
    var offsetParent = getOffsetParent(popper2);
    var heightProp = "clientHeight";
    var widthProp = "clientWidth";
    if (offsetParent === getWindow(popper2)) {
      offsetParent = getDocumentElement(popper2);
      if (getComputedStyle2(offsetParent).position !== "static" && position === "absolute") {
        heightProp = "scrollHeight";
        widthProp = "scrollWidth";
      }
    }
    offsetParent = offsetParent;
    if (placement === top || (placement === left || placement === right) && variation === end) {
      sideY = bottom;
      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
      y -= offsetY - popperRect.height;
      y *= gpuAcceleration ? 1 : -1;
    }
    if (placement === left || (placement === top || placement === bottom) && variation === end) {
      sideX = right;
      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
      x -= offsetX - popperRect.width;
      x *= gpuAcceleration ? 1 : -1;
    }
  }
  var commonStyles = Object.assign({
    position
  }, adaptive && unsetSides);
  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
    x,
    y
  }) : {
    x,
    y
  };
  x = _ref4.x;
  y = _ref4.y;
  if (gpuAcceleration) {
    var _Object$assign;
    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", _Object$assign));
  }
  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
}
function computeStyles(_ref5) {
  var state = _ref5.state, options = _ref5.options;
  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
  if (true) {
    var transitionProperty = getComputedStyle2(state.elements.popper).transitionProperty || "";
    if (adaptive && ["transform", "top", "right", "bottom", "left"].some(function(property) {
      return transitionProperty.indexOf(property) >= 0;
    })) {
      console.warn(["Popper: Detected CSS transitions on at least one of the following", 'CSS properties: "transform", "top", "right", "bottom", "left".', "\n\n", 'Disable the "computeStyles" modifier\'s `adaptive` option to allow', "for smooth transitions, or remove these properties from the CSS", "transition declaration on the popper element if only transitioning", "opacity or background-color for example.", "\n\n", "We recommend using the popper element as a wrapper around an inner", "element that can have any CSS property transitioned for animations."].join(" "));
    }
  }
  var commonStyles = {
    placement: getBasePlacement(state.placement),
    variation: getVariation(state.placement),
    popper: state.elements.popper,
    popperRect: state.rects.popper,
    gpuAcceleration,
    isFixed: state.options.strategy === "fixed"
  };
  if (state.modifiersData.popperOffsets != null) {
    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.popperOffsets,
      position: state.options.strategy,
      adaptive,
      roundOffsets
    })));
  }
  if (state.modifiersData.arrow != null) {
    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
      offsets: state.modifiersData.arrow,
      position: "absolute",
      adaptive: false,
      roundOffsets
    })));
  }
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-placement": state.placement
  });
}
var computeStyles_default = {
  name: "computeStyles",
  enabled: true,
  phase: "beforeWrite",
  fn: computeStyles,
  data: {}
};

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/modifiers/eventListeners.js
var passive = {
  passive: true
};
function effect3(_ref) {
  var state = _ref.state, instance18 = _ref.instance, options = _ref.options;
  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
  var window2 = getWindow(state.elements.popper);
  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
  if (scroll) {
    scrollParents.forEach(function(scrollParent) {
      scrollParent.addEventListener("scroll", instance18.update, passive);
    });
  }
  if (resize) {
    window2.addEventListener("resize", instance18.update, passive);
  }
  return function() {
    if (scroll) {
      scrollParents.forEach(function(scrollParent) {
        scrollParent.removeEventListener("scroll", instance18.update, passive);
      });
    }
    if (resize) {
      window2.removeEventListener("resize", instance18.update, passive);
    }
  };
}
var eventListeners_default = {
  name: "eventListeners",
  enabled: true,
  phase: "write",
  fn: function fn() {
  },
  effect: effect3,
  data: {}
};

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/getOppositePlacement.js
var hash = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(matched) {
    return hash[matched];
  });
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js
var hash2 = {
  start: "end",
  end: "start"
};
function getOppositeVariationPlacement(placement) {
  return placement.replace(/start|end/g, function(matched) {
    return hash2[matched];
  });
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js
function getWindowScroll(node) {
  var win = getWindow(node);
  var scrollLeft = win.pageXOffset;
  var scrollTop = win.pageYOffset;
  return {
    scrollLeft,
    scrollTop
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getWindowScroll(element2).scrollLeft;
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js
function getViewportRect(element2, strategy) {
  var win = getWindow(element2);
  var html = getDocumentElement(element2);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var layoutViewport = isLayoutViewport();
    if (layoutViewport || !layoutViewport && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x + getWindowScrollBarX(element2),
    y
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js
function getDocumentRect(element2) {
  var _element$ownerDocumen;
  var html = getDocumentElement(element2);
  var winScroll = getWindowScroll(element2);
  var body = (_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  var x = -winScroll.scrollLeft + getWindowScrollBarX(element2);
  var y = -winScroll.scrollTop;
  if (getComputedStyle2(body || html).direction === "rtl") {
    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js
function isScrollParent(element2) {
  var _getComputedStyle = getComputedStyle2(element2), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js
function getScrollParent(node) {
  if (["html", "body", "#document"].indexOf(getNodeName(node)) >= 0) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode(node));
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js
function listScrollParents(element2, list) {
  var _element$ownerDocumen;
  if (list === void 0) {
    list = [];
  }
  var scrollParent = getScrollParent(element2);
  var isBody = scrollParent === ((_element$ownerDocumen = element2.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
  var win = getWindow(scrollParent);
  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  var updatedList = list.concat(target);
  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/rectToClientRect.js
function rectToClientRect(rect) {
  return Object.assign({}, rect, {
    left: rect.x,
    top: rect.y,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js
function getInnerBoundingClientRect(element2, strategy) {
  var rect = getBoundingClientRect(element2, false, strategy === "fixed");
  rect.top = rect.top + element2.clientTop;
  rect.left = rect.left + element2.clientLeft;
  rect.bottom = rect.top + element2.clientHeight;
  rect.right = rect.left + element2.clientWidth;
  rect.width = element2.clientWidth;
  rect.height = element2.clientHeight;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
function getClientRectFromMixedType(element2, clippingParent, strategy) {
  return clippingParent === viewport ? rectToClientRect(getViewportRect(element2, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element2)));
}
function getClippingParents(element2) {
  var clippingParents2 = listScrollParents(getParentNode(element2));
  var canEscapeClipping = ["absolute", "fixed"].indexOf(getComputedStyle2(element2).position) >= 0;
  var clipperElement = canEscapeClipping && isHTMLElement(element2) ? getOffsetParent(element2) : element2;
  if (!isElement(clipperElement)) {
    return [];
  }
  return clippingParents2.filter(function(clippingParent) {
    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
  });
}
function getClippingRect(element2, boundary, rootBoundary, strategy) {
  var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element2) : [].concat(boundary);
  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);
  var firstClippingParent = clippingParents2[0];
  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {
    var rect = getClientRectFromMixedType(element2, clippingParent, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromMixedType(element2, firstClippingParent, strategy));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/computeOffsets.js
function computeOffsets(_ref) {
  var reference2 = _ref.reference, element2 = _ref.element, placement = _ref.placement;
  var basePlacement = placement ? getBasePlacement(placement) : null;
  var variation = placement ? getVariation(placement) : null;
  var commonX = reference2.x + reference2.width / 2 - element2.width / 2;
  var commonY = reference2.y + reference2.height / 2 - element2.height / 2;
  var offsets;
  switch (basePlacement) {
    case top:
      offsets = {
        x: commonX,
        y: reference2.y - element2.height
      };
      break;
    case bottom:
      offsets = {
        x: commonX,
        y: reference2.y + reference2.height
      };
      break;
    case right:
      offsets = {
        x: reference2.x + reference2.width,
        y: commonY
      };
      break;
    case left:
      offsets = {
        x: reference2.x - element2.width,
        y: commonY
      };
      break;
    default:
      offsets = {
        x: reference2.x,
        y: reference2.y
      };
  }
  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
  if (mainAxis != null) {
    var len = mainAxis === "y" ? "height" : "width";
    switch (variation) {
      case start:
        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element2[len] / 2);
        break;
      case end:
        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element2[len] / 2);
        break;
      default:
    }
  }
  return offsets;
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/detectOverflow.js
function detectOverflow(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
  var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
  var altContext = elementContext === popper ? reference : popper;
  var popperRect = state.rects.popper;
  var element2 = state.elements[altBoundary ? altContext : elementContext];
  var clippingClientRect = getClippingRect(isElement(element2) ? element2 : element2.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
  var referenceClientRect = getBoundingClientRect(state.elements.reference);
  var popperOffsets2 = computeOffsets({
    reference: referenceClientRect,
    element: popperRect,
    strategy: "absolute",
    placement
  });
  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));
  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
  var overflowOffsets = {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
  var offsetData = state.modifiersData.offset;
  if (elementContext === popper && offsetData) {
    var offset2 = offsetData[placement];
    Object.keys(overflowOffsets).forEach(function(key) {
      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;
      var axis = [top, bottom].indexOf(key) >= 0 ? "y" : "x";
      overflowOffsets[key] += offset2[axis] * multiply;
    });
  }
  return overflowOffsets;
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js
function computeAutoPlacement(state, options) {
  if (options === void 0) {
    options = {};
  }
  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;
  var variation = getVariation(placement);
  var placements2 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {
    return getVariation(placement2) === variation;
  }) : basePlacements;
  var allowedPlacements = placements2.filter(function(placement2) {
    return allowedAutoPlacements.indexOf(placement2) >= 0;
  });
  if (allowedPlacements.length === 0) {
    allowedPlacements = placements2;
    if (true) {
      console.error(["Popper: The `allowedAutoPlacements` option did not allow any", "placements. Ensure the `placement` option matches the variation", "of the allowed placements.", 'For example, "auto" cannot be used to allow "bottom-start".', 'Use "auto-start" instead.'].join(" "));
    }
  }
  var overflows = allowedPlacements.reduce(function(acc, placement2) {
    acc[placement2] = detectOverflow(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding
    })[getBasePlacement(placement2)];
    return acc;
  }, {});
  return Object.keys(overflows).sort(function(a, b) {
    return overflows[a] - overflows[b];
  });
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/modifiers/flip.js
function getExpandedFallbackPlacements(placement) {
  if (getBasePlacement(placement) === auto) {
    return [];
  }
  var oppositePlacement = getOppositePlacement(placement);
  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];
}
function flip(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  if (state.modifiersData[name]._skip) {
    return;
  }
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
  var preferredPlacement = state.options.placement;
  var basePlacement = getBasePlacement(preferredPlacement);
  var isBasePlacement = basePlacement === preferredPlacement;
  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));
  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {
    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {
      placement: placement2,
      boundary,
      rootBoundary,
      padding,
      flipVariations,
      allowedAutoPlacements
    }) : placement2);
  }, []);
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var checksMap = /* @__PURE__ */ new Map();
  var makeFallbackChecks = true;
  var firstFittingPlacement = placements2[0];
  for (var i = 0; i < placements2.length; i++) {
    var placement = placements2[i];
    var _basePlacement = getBasePlacement(placement);
    var isStartVariation = getVariation(placement) === start;
    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;
    var len = isVertical ? "width" : "height";
    var overflow = detectOverflow(state, {
      placement,
      boundary,
      rootBoundary,
      altBoundary,
      padding
    });
    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;
    if (referenceRect[len] > popperRect[len]) {
      mainVariationSide = getOppositePlacement(mainVariationSide);
    }
    var altVariationSide = getOppositePlacement(mainVariationSide);
    var checks = [];
    if (checkMainAxis) {
      checks.push(overflow[_basePlacement] <= 0);
    }
    if (checkAltAxis) {
      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
    }
    if (checks.every(function(check) {
      return check;
    })) {
      firstFittingPlacement = placement;
      makeFallbackChecks = false;
      break;
    }
    checksMap.set(placement, checks);
  }
  if (makeFallbackChecks) {
    var numberOfChecks = flipVariations ? 3 : 1;
    var _loop = function _loop2(_i2) {
      var fittingPlacement = placements2.find(function(placement2) {
        var checks2 = checksMap.get(placement2);
        if (checks2) {
          return checks2.slice(0, _i2).every(function(check) {
            return check;
          });
        }
      });
      if (fittingPlacement) {
        firstFittingPlacement = fittingPlacement;
        return "break";
      }
    };
    for (var _i = numberOfChecks; _i > 0; _i--) {
      var _ret = _loop(_i);
      if (_ret === "break")
        break;
    }
  }
  if (state.placement !== firstFittingPlacement) {
    state.modifiersData[name]._skip = true;
    state.placement = firstFittingPlacement;
    state.reset = true;
  }
}
var flip_default = {
  name: "flip",
  enabled: true,
  phase: "main",
  fn: flip,
  requiresIfExists: ["offset"],
  data: {
    _skip: false
  }
};

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/modifiers/hide.js
function getSideOffsets(overflow, rect, preventedOffsets) {
  if (preventedOffsets === void 0) {
    preventedOffsets = {
      x: 0,
      y: 0
    };
  }
  return {
    top: overflow.top - rect.height - preventedOffsets.y,
    right: overflow.right - rect.width + preventedOffsets.x,
    bottom: overflow.bottom - rect.height + preventedOffsets.y,
    left: overflow.left - rect.width - preventedOffsets.x
  };
}
function isAnySideFullyClipped(overflow) {
  return [top, right, bottom, left].some(function(side) {
    return overflow[side] >= 0;
  });
}
function hide(_ref) {
  var state = _ref.state, name = _ref.name;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var preventedOffsets = state.modifiersData.preventOverflow;
  var referenceOverflow = detectOverflow(state, {
    elementContext: "reference"
  });
  var popperAltOverflow = detectOverflow(state, {
    altBoundary: true
  });
  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
  state.modifiersData[name] = {
    referenceClippingOffsets,
    popperEscapeOffsets,
    isReferenceHidden,
    hasPopperEscaped
  };
  state.attributes.popper = Object.assign({}, state.attributes.popper, {
    "data-popper-reference-hidden": isReferenceHidden,
    "data-popper-escaped": hasPopperEscaped
  });
}
var hide_default = {
  name: "hide",
  enabled: true,
  phase: "main",
  requiresIfExists: ["preventOverflow"],
  fn: hide
};

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/modifiers/offset.js
function distanceAndSkiddingToXY(placement, rects, offset2) {
  var basePlacement = getBasePlacement(placement);
  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;
  var _ref = typeof offset2 === "function" ? offset2(Object.assign({}, rects, {
    placement
  })) : offset2, skidding = _ref[0], distance = _ref[1];
  skidding = skidding || 0;
  distance = (distance || 0) * invertDistance;
  return [left, right].indexOf(basePlacement) >= 0 ? {
    x: distance,
    y: skidding
  } : {
    x: skidding,
    y: distance
  };
}
function offset(_ref2) {
  var state = _ref2.state, options = _ref2.options, name = _ref2.name;
  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;
  var data = placements.reduce(function(acc, placement) {
    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);
    return acc;
  }, {});
  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
  if (state.modifiersData.popperOffsets != null) {
    state.modifiersData.popperOffsets.x += x;
    state.modifiersData.popperOffsets.y += y;
  }
  state.modifiersData[name] = data;
}
var offset_default = {
  name: "offset",
  enabled: true,
  phase: "main",
  requires: ["popperOffsets"],
  fn: offset
};

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/modifiers/popperOffsets.js
function popperOffsets(_ref) {
  var state = _ref.state, name = _ref.name;
  state.modifiersData[name] = computeOffsets({
    reference: state.rects.reference,
    element: state.rects.popper,
    strategy: "absolute",
    placement: state.placement
  });
}
var popperOffsets_default = {
  name: "popperOffsets",
  enabled: true,
  phase: "read",
  fn: popperOffsets,
  data: {}
};

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/getAltAxis.js
function getAltAxis(axis) {
  return axis === "x" ? "y" : "x";
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js
function preventOverflow(_ref) {
  var state = _ref.state, options = _ref.options, name = _ref.name;
  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
  var overflow = detectOverflow(state, {
    boundary,
    rootBoundary,
    padding,
    altBoundary
  });
  var basePlacement = getBasePlacement(state.placement);
  var variation = getVariation(state.placement);
  var isBasePlacement = !variation;
  var mainAxis = getMainAxisFromPlacement(basePlacement);
  var altAxis = getAltAxis(mainAxis);
  var popperOffsets2 = state.modifiersData.popperOffsets;
  var referenceRect = state.rects.reference;
  var popperRect = state.rects.popper;
  var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
    placement: state.placement
  })) : tetherOffset;
  var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
    mainAxis: tetherOffsetValue,
    altAxis: tetherOffsetValue
  } : Object.assign({
    mainAxis: 0,
    altAxis: 0
  }, tetherOffsetValue);
  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
  var data = {
    x: 0,
    y: 0
  };
  if (!popperOffsets2) {
    return;
  }
  if (checkMainAxis) {
    var _offsetModifierState$;
    var mainSide = mainAxis === "y" ? top : left;
    var altSide = mainAxis === "y" ? bottom : right;
    var len = mainAxis === "y" ? "height" : "width";
    var offset2 = popperOffsets2[mainAxis];
    var min2 = offset2 + overflow[mainSide];
    var max2 = offset2 - overflow[altSide];
    var additive = tether ? -popperRect[len] / 2 : 0;
    var minLen = variation === start ? referenceRect[len] : popperRect[len];
    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
    var arrowElement = state.elements.arrow;
    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
      width: 0,
      height: 0
    };
    var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
    var arrowPaddingMin = arrowPaddingObject[mainSide];
    var arrowPaddingMax = arrowPaddingObject[altSide];
    var arrowLen = within(0, referenceRect[len], arrowRect[len]);
    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
    var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;
    var tetherMax = offset2 + maxOffset - offsetModifierValue;
    var preventedOffset = within(tether ? min(min2, tetherMin) : min2, offset2, tether ? max(max2, tetherMax) : max2);
    popperOffsets2[mainAxis] = preventedOffset;
    data[mainAxis] = preventedOffset - offset2;
  }
  if (checkAltAxis) {
    var _offsetModifierState$2;
    var _mainSide = mainAxis === "x" ? top : left;
    var _altSide = mainAxis === "x" ? bottom : right;
    var _offset = popperOffsets2[altAxis];
    var _len = altAxis === "y" ? "height" : "width";
    var _min = _offset + overflow[_mainSide];
    var _max = _offset - overflow[_altSide];
    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;
    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
    popperOffsets2[altAxis] = _preventedOffset;
    data[altAxis] = _preventedOffset - _offset;
  }
  state.modifiersData[name] = data;
}
var preventOverflow_default = {
  name: "preventOverflow",
  enabled: true,
  phase: "main",
  fn: preventOverflow,
  requiresIfExists: ["offset"]
};

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js
function getHTMLElementScroll(element2) {
  return {
    scrollLeft: element2.scrollLeft,
    scrollTop: element2.scrollTop
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js
function getNodeScroll(node) {
  if (node === getWindow(node) || !isHTMLElement(node)) {
    return getWindowScroll(node);
  } else {
    return getHTMLElementScroll(node);
  }
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js
function isElementScaled(element2) {
  var rect = element2.getBoundingClientRect();
  var scaleX = round(rect.width) / element2.offsetWidth || 1;
  var scaleY = round(rect.height) / element2.offsetHeight || 1;
  return scaleX !== 1 || scaleY !== 1;
}
function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      offsets = getBoundingClientRect(offsetParent, true);
      offsets.x += offsetParent.clientLeft;
      offsets.y += offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll.scrollLeft - offsets.x,
    y: rect.top + scroll.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/orderModifiers.js
function order(modifiers) {
  var map = /* @__PURE__ */ new Map();
  var visited = /* @__PURE__ */ new Set();
  var result = [];
  modifiers.forEach(function(modifier) {
    map.set(modifier.name, modifier);
  });
  function sort(modifier) {
    visited.add(modifier.name);
    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
    requires.forEach(function(dep) {
      if (!visited.has(dep)) {
        var depModifier = map.get(dep);
        if (depModifier) {
          sort(depModifier);
        }
      }
    });
    result.push(modifier);
  }
  modifiers.forEach(function(modifier) {
    if (!visited.has(modifier.name)) {
      sort(modifier);
    }
  });
  return result;
}
function orderModifiers(modifiers) {
  var orderedModifiers = order(modifiers);
  return modifierPhases.reduce(function(acc, phase) {
    return acc.concat(orderedModifiers.filter(function(modifier) {
      return modifier.phase === phase;
    }));
  }, []);
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/debounce.js
function debounce(fn2) {
  var pending;
  return function() {
    if (!pending) {
      pending = new Promise(function(resolve) {
        Promise.resolve().then(function() {
          pending = void 0;
          resolve(fn2());
        });
      });
    }
    return pending;
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/format.js
function format(str) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return [].concat(args).reduce(function(p, c) {
    return p.replace(/%s/, c);
  }, str);
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/validateModifiers.js
var INVALID_MODIFIER_ERROR = 'Popper: modifier "%s" provided an invalid %s property, expected %s but got %s';
var MISSING_DEPENDENCY_ERROR = 'Popper: modifier "%s" requires "%s", but "%s" modifier is not available';
var VALID_PROPERTIES = ["name", "enabled", "phase", "fn", "effect", "requires", "options"];
function validateModifiers(modifiers) {
  modifiers.forEach(function(modifier) {
    [].concat(Object.keys(modifier), VALID_PROPERTIES).filter(function(value, index, self2) {
      return self2.indexOf(value) === index;
    }).forEach(function(key) {
      switch (key) {
        case "name":
          if (typeof modifier.name !== "string") {
            console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '"name"', '"string"', '"' + String(modifier.name) + '"'));
          }
          break;
        case "enabled":
          if (typeof modifier.enabled !== "boolean") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"enabled"', '"boolean"', '"' + String(modifier.enabled) + '"'));
          }
          break;
        case "phase":
          if (modifierPhases.indexOf(modifier.phase) < 0) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"phase"', "either " + modifierPhases.join(", "), '"' + String(modifier.phase) + '"'));
          }
          break;
        case "fn":
          if (typeof modifier.fn !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"fn"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "effect":
          if (modifier.effect != null && typeof modifier.effect !== "function") {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"effect"', '"function"', '"' + String(modifier.fn) + '"'));
          }
          break;
        case "requires":
          if (modifier.requires != null && !Array.isArray(modifier.requires)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requires"', '"array"', '"' + String(modifier.requires) + '"'));
          }
          break;
        case "requiresIfExists":
          if (!Array.isArray(modifier.requiresIfExists)) {
            console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '"requiresIfExists"', '"array"', '"' + String(modifier.requiresIfExists) + '"'));
          }
          break;
        case "options":
        case "data":
          break;
        default:
          console.error('PopperJS: an invalid property has been provided to the "' + modifier.name + '" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {
            return '"' + s + '"';
          }).join(", ") + '; but "' + key + '" was provided.');
      }
      modifier.requires && modifier.requires.forEach(function(requirement) {
        if (modifiers.find(function(mod) {
          return mod.name === requirement;
        }) == null) {
          console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));
        }
      });
    });
  });
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/uniqueBy.js
function uniqueBy(arr, fn2) {
  var identifiers = /* @__PURE__ */ new Set();
  return arr.filter(function(item) {
    var identifier = fn2(item);
    if (!identifiers.has(identifier)) {
      identifiers.add(identifier);
      return true;
    }
  });
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/utils/mergeByName.js
function mergeByName(modifiers) {
  var merged = modifiers.reduce(function(merged2, current) {
    var existing = merged2[current.name];
    merged2[current.name] = existing ? Object.assign({}, existing, current, {
      options: Object.assign({}, existing.options, current.options),
      data: Object.assign({}, existing.data, current.data)
    }) : current;
    return merged2;
  }, {});
  return Object.keys(merged).map(function(key) {
    return merged[key];
  });
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/createPopper.js
var INVALID_ELEMENT_ERROR = "Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.";
var INFINITE_LOOP_ERROR = "Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.";
var DEFAULT_OPTIONS = {
  placement: "bottom",
  modifiers: [],
  strategy: "absolute"
};
function areValidElements() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return !args.some(function(element2) {
    return !(element2 && typeof element2.getBoundingClientRect === "function");
  });
}
function popperGenerator(generatorOptions) {
  if (generatorOptions === void 0) {
    generatorOptions = {};
  }
  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
  return function createPopper2(reference2, popper2, options) {
    if (options === void 0) {
      options = defaultOptions;
    }
    var state = {
      placement: "bottom",
      orderedModifiers: [],
      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
      modifiersData: {},
      elements: {
        reference: reference2,
        popper: popper2
      },
      attributes: {},
      styles: {}
    };
    var effectCleanupFns = [];
    var isDestroyed = false;
    var instance18 = {
      state,
      setOptions: function setOptions(setOptionsAction) {
        var options2 = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
        cleanupModifierEffects();
        state.options = Object.assign({}, defaultOptions, state.options, options2);
        state.scrollParents = {
          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],
          popper: listScrollParents(popper2)
        };
        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));
        state.orderedModifiers = orderedModifiers.filter(function(m) {
          return m.enabled;
        });
        if (true) {
          var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {
            var name = _ref.name;
            return name;
          });
          validateModifiers(modifiers);
          if (getBasePlacement(state.options.placement) === auto) {
            var flipModifier = state.orderedModifiers.find(function(_ref2) {
              var name = _ref2.name;
              return name === "flip";
            });
            if (!flipModifier) {
              console.error(['Popper: "auto" placements require the "flip" modifier be', "present and enabled to work."].join(" "));
            }
          }
          var _getComputedStyle = getComputedStyle2(popper2), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft;
          if ([marginTop, marginRight, marginBottom, marginLeft].some(function(margin) {
            return parseFloat(margin);
          })) {
            console.warn(['Popper: CSS "margin" styles cannot be used to apply padding', "between the popper and its reference element or boundary.", "To replicate margin, use the `offset` modifier, as well as", "the `padding` option in the `preventOverflow` and `flip`", "modifiers."].join(" "));
          }
        }
        runModifierEffects();
        return instance18.update();
      },
      forceUpdate: function forceUpdate() {
        if (isDestroyed) {
          return;
        }
        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;
        if (!areValidElements(reference3, popper3)) {
          if (true) {
            console.error(INVALID_ELEMENT_ERROR);
          }
          return;
        }
        state.rects = {
          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === "fixed"),
          popper: getLayoutRect(popper3)
        };
        state.reset = false;
        state.placement = state.options.placement;
        state.orderedModifiers.forEach(function(modifier) {
          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
        });
        var __debug_loops__ = 0;
        for (var index = 0; index < state.orderedModifiers.length; index++) {
          if (true) {
            __debug_loops__ += 1;
            if (__debug_loops__ > 100) {
              console.error(INFINITE_LOOP_ERROR);
              break;
            }
          }
          if (state.reset === true) {
            state.reset = false;
            index = -1;
            continue;
          }
          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
          if (typeof fn2 === "function") {
            state = fn2({
              state,
              options: _options,
              name,
              instance: instance18
            }) || state;
          }
        }
      },
      update: debounce(function() {
        return new Promise(function(resolve) {
          instance18.forceUpdate();
          resolve(state);
        });
      }),
      destroy: function destroy() {
        cleanupModifierEffects();
        isDestroyed = true;
      }
    };
    if (!areValidElements(reference2, popper2)) {
      if (true) {
        console.error(INVALID_ELEMENT_ERROR);
      }
      return instance18;
    }
    instance18.setOptions(options).then(function(state2) {
      if (!isDestroyed && options.onFirstUpdate) {
        options.onFirstUpdate(state2);
      }
    });
    function runModifierEffects() {
      state.orderedModifiers.forEach(function(_ref3) {
        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect4 = _ref3.effect;
        if (typeof effect4 === "function") {
          var cleanupFn = effect4({
            state,
            name,
            instance: instance18,
            options: options2
          });
          var noopFn = function noopFn2() {
          };
          effectCleanupFns.push(cleanupFn || noopFn);
        }
      });
    }
    function cleanupModifierEffects() {
      effectCleanupFns.forEach(function(fn2) {
        return fn2();
      });
      effectCleanupFns = [];
    }
    return instance18;
  };
}

// node_modules/.pnpm/@popperjs+core@2.11.6/node_modules/@popperjs/core/lib/popper.js
var defaultModifiers = [eventListeners_default, popperOffsets_default, computeStyles_default, applyStyles_default, offset_default, flip_default, preventOverflow_default, arrow_default, hide_default];
var createPopper = /* @__PURE__ */ popperGenerator({
  defaultModifiers
});

// src/gui/suggesters/suggest.ts
var wrapAround = (value, size) => {
  return (value % size + size) % size;
};
var Suggest = class {
  constructor(owner, containerEl, scope) {
    this.owner = owner;
    this.containerEl = containerEl;
    containerEl.on(
      "click",
      ".suggestion-item",
      this.onSuggestionClick.bind(this)
    );
    containerEl.on(
      "mousemove",
      ".suggestion-item",
      this.onSuggestionMouseover.bind(this)
    );
    scope.register([], "ArrowUp", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem - 1, true);
        return false;
      }
    });
    scope.register([], "ArrowDown", (event) => {
      if (!event.isComposing) {
        this.setSelectedItem(this.selectedItem + 1, true);
        return false;
      }
    });
    scope.register([], "Enter", (event) => {
      if (!event.isComposing) {
        this.useSelectedItem(event);
        return false;
      }
    });
  }
  onSuggestionClick(event, el) {
    event.preventDefault();
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
    this.useSelectedItem(event);
  }
  onSuggestionMouseover(_event, el) {
    const item = this.suggestions.indexOf(el);
    this.setSelectedItem(item, false);
  }
  setSuggestions(values) {
    this.containerEl.empty();
    const suggestionEls = [];
    values.forEach((value) => {
      const suggestionEl = this.containerEl.createDiv("suggestion-item");
      this.owner.renderSuggestion(value, suggestionEl);
      suggestionEls.push(suggestionEl);
    });
    this.values = values;
    this.suggestions = suggestionEls;
    this.setSelectedItem(0, false);
  }
  useSelectedItem(event) {
    const currentValue = this.values[this.selectedItem];
    if (currentValue) {
      this.owner.selectSuggestion(currentValue, event);
    }
  }
  setSelectedItem(selectedIndex, scrollIntoView) {
    const normalizedIndex = wrapAround(
      selectedIndex,
      this.suggestions.length
    );
    const prevSelectedSuggestion = this.suggestions[this.selectedItem];
    const selectedSuggestion = this.suggestions[normalizedIndex];
    prevSelectedSuggestion == null ? void 0 : prevSelectedSuggestion.removeClass("is-selected");
    selectedSuggestion == null ? void 0 : selectedSuggestion.addClass("is-selected");
    this.selectedItem = normalizedIndex;
    if (scrollIntoView) {
      selectedSuggestion.scrollIntoView(false);
    }
  }
};
var TextInputSuggest = class {
  constructor(app2, inputEl) {
    this.app = app2;
    this.inputEl = inputEl;
    this.scope = new import_obsidian3.Scope();
    this.suggestEl = createDiv("suggestion-container");
    const suggestion = this.suggestEl.createDiv("suggestion");
    this.suggest = new Suggest(this, suggestion, this.scope);
    this.scope.register([], "Escape", this.close.bind(this));
    this.inputEl.addEventListener("input", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("focus", this.onInputChanged.bind(this));
    this.inputEl.addEventListener("blur", this.close.bind(this));
    this.suggestEl.on(
      "mousedown",
      ".suggestion-container",
      (event) => {
        event.preventDefault();
      }
    );
  }
  onInputChanged() {
    const inputStr = this.inputEl.value;
    const suggestions = this.getSuggestions(inputStr);
    if (!suggestions) {
      this.close();
      return;
    }
    if (suggestions.length > 0) {
      this.suggest.setSuggestions(suggestions);
      this.open(this.app.dom.appContainerEl, this.inputEl);
    } else {
      this.close();
    }
  }
  open(container, inputEl) {
    this.app.keymap.pushScope(this.scope);
    container.appendChild(this.suggestEl);
    this.popper = createPopper(inputEl, this.suggestEl, {
      placement: "bottom-start",
      modifiers: [
        {
          name: "sameWidth",
          enabled: true,
          fn: ({ state, instance: instance18 }) => {
            const targetWidth = `${state.rects.reference.width}px`;
            if (state.styles.popper.width === targetWidth) {
              return;
            }
            state.styles.popper.width = targetWidth;
            instance18.update();
          },
          phase: "beforeWrite",
          requires: ["computeStyles"]
        }
      ]
    });
  }
  close() {
    this.app.keymap.popScope(this.scope);
    this.suggest.setSuggestions([]);
    if (this.popper)
      this.popper.destroy();
    this.suggestEl.detach();
  }
};

// src/constants.ts
var VALUE_SYNTAX = "{{value}}";
var DATE_SYNTAX = "{{date}}";
var NAME_SYNTAX = "{{name}}";
var VARIABLE_SYNTAX = "{{value:<variable name>}}";
var MATH_VALUE_SYNTAX = "{{mvalue}}";
var LINKCURRENT_SYNTAX = "{{linkcurrent}}";
var FILE_NAME_FORMAT_SYNTAX = [
  DATE_SYNTAX,
  "{{date:<dateformat>}}",
  "{{vdate:<variable name>, <date format>}}",
  VALUE_SYNTAX,
  NAME_SYNTAX,
  VARIABLE_SYNTAX
];
var FILE_NUMBER_REGEX = new RegExp(/([0-9]*)\.md$/);
var NUMBER_REGEX = new RegExp(/^-?[0-9]*$/);
var CREATE_IF_NOT_FOUND_TOP = "top";
var CREATE_IF_NOT_FOUND_BOTTOM = "bottom";
var DATE_REGEX = new RegExp(/{{DATE(\+-?[0-9]+)?}}/i);
var DATE_REGEX_FORMATTED = new RegExp(
  /{{DATE:([^}\n\r+]*)(\+-?[0-9]+)?}}/i
);
var NAME_VALUE_REGEX = new RegExp(/{{NAME}}|{{VALUE}}/i);
var VARIABLE_REGEX = new RegExp(/{{VALUE:([^\n\r}]*)}}/i);
var DATE_VARIABLE_REGEX = new RegExp(
  /{{VDATE:([^\n\r},]*),\s*([^\n\r},]*)}}/i
);
var LINK_TO_CURRENT_FILE_REGEX = new RegExp(
  /{{LINKCURRENT}}/i
);
var MARKDOWN_FILE_EXTENSION_REGEX = new RegExp(/\.md$/);
var JAVASCRIPT_FILE_EXTENSION_REGEX = new RegExp(/\.js$/);
var MACRO_REGEX = new RegExp(/{{MACRO:([^\n\r}]*)}}/i);
var TEMPLATE_REGEX = new RegExp(
  /{{TEMPLATE:([^\n\r}]*.md)}}/i
);
var LINEBREAK_REGEX = new RegExp(/\\n/);
var INLINE_JAVASCRIPT_REGEX = new RegExp(
  /`{3,}js quickadd([\s\S]*?)`{3,}/
);
var MATH_VALUE_REGEX = new RegExp(/{{MVALUE}}/i);
var TITLE_REGEX = new RegExp(/{{TITLE}}/i);
var FILE_LINK_REGEX = new RegExp(/\[\[([^\]]*)$/);
var TAG_REGEX = new RegExp(/#([^ ]*)$/);
var DATE_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[D]?[A]?[T]?[E]?[}]?[}]?$/i
);
var DATE_FORMAT_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[D]?[A]?[T]?[E]?[:]?$|{{DATE:[^\n\r}]*}}$/i
);
var NAME_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[N]?[A]?[M]?[E]?[}]?[}]?$/i
);
var VALUE_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[V]?[A]?[L]?[U]?[E]?[}]?[}]?$/i
);
var VARIABLE_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[V]?[A]?[L]?[U]?[E]?[:]?$|{{VALUE:[^\n\r}]*}}$/i
);
var VARIABLE_DATE_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[V]?[D]?[A]?[T]?[E]?[:]?$|{{VDATE:[^\n\r}]*}}$/i
);
var LINKCURRENT_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[L]?[I]?[N]?[K]?[C]?[U]?[R]?[R]?[E]?[N]?[T]?[}]?[}]?$/i
);
var TEMPLATE_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[T]?[E]?[M]?[P]?[L]?[A]?[T]?[E]?[:]?$|{{TEMPLATE:[^\n\r}]*[}]?[}]?$/i
);
var MACRO_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[M]?[A]?[C]?[R]?[O]?[:]?$|{{MACRO:[^\n\r}]*}}$/i
);
var MATH_VALUE_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[M]?[V]?[A]?[L]?[U]?[E]?[}]?[}]?/i
);
var TITLE_SYNTAX_SUGGEST_REGEX = new RegExp(
  /{{[T]?[I]?[T]?[L]?[E]?[}]?[}]?/i
);
var fileExistsAppendToBottom = "Append to the bottom of the file";
var fileExistsAppendToTop = "Append to the top of the file";
var fileExistsOverwriteFile = "Overwrite the file";
var fileExistsDoNothing = "Nothing";
var fileExistsChoices = [
  fileExistsAppendToBottom,
  fileExistsAppendToTop,
  fileExistsOverwriteFile,
  fileExistsDoNothing
];
var WIKI_LINK_REGEX = new RegExp(/\[\[([^\]]*)\]\]/);

// node_modules/.pnpm/fuse.js@6.6.2/node_modules/fuse.js/dist/fuse.esm.js
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString2(value) {
  return value == null ? "" : baseToString(value);
}
function isString(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max2) => `Pattern length exceeds max of ${max2}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString2(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  includeMatches: false,
  findAllMatches: false,
  minMatchCharLength: 1
};
var BasicOptions = {
  isCaseSensitive: false,
  includeScore: false,
  keys: [],
  shouldSort: true,
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  location: 0,
  threshold: 0.6,
  distance: 100
};
var AdvancedOptions = {
  useExtendedSearch: false,
  getFn: get,
  ignoreLocation: false,
  ignoreFieldNorm: false,
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  add(doc) {
    const idx = this.size();
    if (isString(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item, keyId) {
    return item[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start2 = -1;
  let end2 = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match = matchmask[i];
    if (match && start2 === -1) {
      start2 = i;
    } else if (!match && start2 !== -1) {
      end2 = i - 1;
      if (end2 - start2 + 1 >= minMatchCharLength) {
        indices.push([start2, end2]);
      }
      start2 = -1;
    }
  }
  if (matchmask[i - 1] && i - start2 >= minMatchCharLength) {
    indices.push([start2, i - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text2, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text2.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text2.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start2 = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start2; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text2.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start2 = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char = pattern.charAt(i);
    mask[char] = (mask[char] || 0) | 1 << len - i - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end2 = len - remainder;
      while (i < end2) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text2) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text2 = text2.toLowerCase();
    }
    if (this.pattern === text2) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text2.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text2, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text2) {
    const isMatch = text2 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text2) {
    const index = text2.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text2) {
    const isMatch = text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text2) {
    const isMatch = !text2.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text2) {
    const isMatch = text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text2.length - this.pattern.length, text2.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text2) {
    const isMatch = !text2.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text2.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text2) {
    return this._bitapSearch.searchIn(text2);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text2) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text2.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item) => {
    let query = item.trim().split(SPACE_RE).filter((item2) => item2 && !!item2.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text2) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text2 = isCaseSensitive ? text2 : text2.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text2);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse(query, options, { auto: auto2 = true } = {}) {
  const next3 = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next3(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto2) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item) => {
          node.children.push(next3(item));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next3(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match) => {
    if (!isDefined(match.indices) || !match.indices.length) {
      return;
    }
    const { indices, value } = match;
    let obj = {
      indices,
      value
    };
    if (match.key) {
      obj.key = match.key.src;
    }
    if (match.idx > -1) {
      obj.refIndex = match.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format2(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format2(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text2, i: idx, n: norm2 }) => {
      if (!isDefined(text2)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        results.push({
          item: text2,
          idx,
          matches: [{ score, value: text2, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse(query, this.options);
    const evaluate = (node, item, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (isDefined(item)) {
        let expResults = evaluate(expression, item, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item, i: idx }) => {
      if (!isDefined(item)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text2, i: idx, n: norm2 }) => {
        if (!isDefined(text2)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text2);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text2,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text2, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text2);
      if (isMatch) {
        matches.push({ score, key, value: text2, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse;
}
{
  register(ExtendedSearch);
}

// src/gui/suggesters/fileSuggester.ts
var SuggestionMap = class extends Map {
};
function buildFileMap(files, unresolvedLinkNames) {
  const fileMap = new SuggestionMap();
  for (const file of files) {
    fileMap.set(file.path, {
      file,
      type: 0 /* File */
    });
    for (const alias of file.alias) {
      fileMap.set(alias, {
        file,
        type: 1 /* Alias */
      });
    }
  }
  for (const unresolvedLinkName of unresolvedLinkNames) {
    fileMap.set(unresolvedLinkName, {
      type: 2 /* Unresolved */
    });
  }
  return fileMap;
}
function getAliasesForFile(file, app2) {
  var _a, _b, _c, _d;
  const fileMetadata = app2.metadataCache.getFileCache(file);
  const fileMetaAlias = (_d = (_c = (_a = fileMetadata == null ? void 0 : fileMetadata.frontmatter) == null ? void 0 : _a.alias) != null ? _c : (_b = fileMetadata == null ? void 0 : fileMetadata.frontmatter) == null ? void 0 : _b.aliases) != null ? _d : "";
  let aliases = [];
  if (typeof fileMetaAlias === "string" && fileMetaAlias) {
    aliases.push(fileMetaAlias);
  } else if (Array.isArray(fileMetaAlias)) {
    const filteredAliases = fileMetaAlias.filter(
      (v) => v && typeof v === "string"
    );
    if (filteredAliases.length) {
      aliases.push(...filteredAliases);
    }
  }
  return { ...file, alias: aliases };
}
var SilentFileSuggester = class extends TextInputSuggest {
  constructor(app2, inputEl) {
    super(app2, inputEl);
    this.app = app2;
    this.inputEl = inputEl;
    this.lastInput = "";
    const filesAndAliases = app2.vault.getMarkdownFiles().map((file) => getAliasesForFile(file, app2));
    const unresolvedLinkNames = this.getUnresolvedLinkNames(app2);
    const fileAndAliasMap = buildFileMap(
      filesAndAliases,
      unresolvedLinkNames
    );
    this.fileNames = [...fileAndAliasMap.keys()];
    this.fileMap = fileAndAliasMap;
  }
  getSuggestions(inputStr) {
    const cursorPosition = this.inputEl.selectionStart;
    const inputBeforeCursor = inputStr.substr(0, cursorPosition);
    const fileLinkMatch = FILE_LINK_REGEX.exec(inputBeforeCursor);
    if (!fileLinkMatch) {
      return [];
    }
    const fileNameInput = fileLinkMatch[1];
    this.lastInput = fileNameInput;
    const fuse = new Fuse(this.fileNames, {
      findAllMatches: true,
      shouldSort: true,
      isCaseSensitive: false,
      minMatchCharLength: 1,
      threshold: 0.3
    });
    const MAX_ITEMS = 50;
    const search2 = fuse.search(this.lastInput).slice(0, MAX_ITEMS).map((value) => value.item);
    return search2;
  }
  renderSuggestion(item, el) {
    var _a, _b, _c;
    const suggestionItem = this.fileMap.get(item);
    switch (suggestionItem.type) {
      case 0 /* File */:
        el.innerHTML = `
                    <span class="suggestion-main-text">${(_a = suggestionItem == null ? void 0 : suggestionItem.file) == null ? void 0 : _a.basename}</span>
                    <span class="suggestion-sub-text">${(_b = suggestionItem == null ? void 0 : suggestionItem.file) == null ? void 0 : _b.path}</span>
                `;
        break;
      case 1 /* Alias */:
        el.innerHTML = `
                    <span class="suggestion-main-text">${item}</span>
                    <span class="suggestion-sub-text">${(_c = suggestionItem == null ? void 0 : suggestionItem.file) == null ? void 0 : _c.path}</span>
                `;
        break;
      case 2 /* Unresolved */:
        el.innerHTML = `
                    <span class="suggestion-main-text">${item}</span>
                    <span class="suggestion-sub-text">Unresolved link</span>
                `;
        break;
      default:
        el.innerHTML = `
                    <span class="suggestion-main-text">${item}</span>
                    <span class="suggestion-sub-text">Unknown</span>
                `;
        break;
    }
    el.classList.add("qaFileSuggestionItem");
  }
  selectSuggestion(item) {
    const cursorPosition = this.inputEl.selectionStart;
    const lastInputLength = this.lastInput.length;
    const currentInputValue = this.inputEl.value;
    let insertedEndPosition = 0;
    const suggestionItem = this.fileMap.get(item);
    if (suggestionItem.type === 0 /* File */) {
      insertedEndPosition = this.makeLinkObsidianMethod(
        suggestionItem == null ? void 0 : suggestionItem.file,
        currentInputValue,
        cursorPosition,
        lastInputLength
      );
    } else if (suggestionItem.type === 1 /* Alias */) {
      insertedEndPosition = this.makeLinkObsidianMethod(
        suggestionItem == null ? void 0 : suggestionItem.file,
        currentInputValue,
        cursorPosition,
        lastInputLength,
        item
      );
    } else {
      insertedEndPosition = this.makeLinkManually(
        currentInputValue,
        item.replace(/.md$/, ""),
        cursorPosition,
        lastInputLength
      );
    }
    this.inputEl.trigger("input");
    this.close();
    this.inputEl.setSelectionRange(
      insertedEndPosition,
      insertedEndPosition
    );
  }
  makeLinkObsidianMethod(linkFile, currentInputValue, cursorPosition, lastInputLength, alias) {
    const file = this.app.vault.getAbstractFileByPath(
      linkFile.path
    );
    const link = this.app.fileManager.generateMarkdownLink(
      file,
      "",
      "",
      alias != null ? alias : ""
    );
    this.inputEl.value = this.getNewInputValueForFileLink(
      currentInputValue,
      link,
      cursorPosition,
      lastInputLength
    );
    return cursorPosition - lastInputLength + link.length + 2;
  }
  makeLinkManually(currentInputValue, item, cursorPosition, lastInputLength) {
    this.inputEl.value = this.getNewInputValueForFileName(
      currentInputValue,
      item,
      cursorPosition,
      lastInputLength
    );
    return cursorPosition - lastInputLength + item.length + 2;
  }
  getNewInputValueForFileLink(currentInputElValue, selectedItem, cursorPosition, lastInputLength) {
    return `${currentInputElValue.substr(
      0,
      cursorPosition - lastInputLength - 2
    )}${selectedItem}${currentInputElValue.substr(cursorPosition)}`;
  }
  getNewInputValueForFileName(currentInputElValue, selectedItem, cursorPosition, lastInputLength) {
    return `${currentInputElValue.substr(
      0,
      cursorPosition - lastInputLength
    )}${selectedItem}]]${currentInputElValue.substr(cursorPosition)}`;
  }
  getUnresolvedLinkNames(app2) {
    const unresolvedLinks = app2.metadataCache.unresolvedLinks;
    const unresolvedLinkNames = /* @__PURE__ */ new Set();
    for (const sourceFileName in unresolvedLinks) {
      for (const unresolvedLink in unresolvedLinks[sourceFileName]) {
        unresolvedLinkNames.add(unresolvedLink);
      }
    }
    return Array.from(unresolvedLinkNames);
  }
};

// src/gui/suggesters/tagSuggester.ts
var SilentTagSuggester = class extends TextInputSuggest {
  constructor(app2, inputEl) {
    super(app2, inputEl);
    this.app = app2;
    this.inputEl = inputEl;
    this.lastInput = "";
    this.tags = Object.keys(app2.metadataCache.getTags());
  }
  getSuggestions(inputStr) {
    const cursorPosition = this.inputEl.selectionStart;
    const inputBeforeCursor = inputStr.substr(0, cursorPosition);
    const tagMatch = TAG_REGEX.exec(inputBeforeCursor);
    if (!tagMatch) {
      return [];
    }
    const tagInput = tagMatch[1];
    this.lastInput = tagInput;
    const suggestions = this.tags.filter(
      (tag) => tag.toLowerCase().contains(tagInput.toLowerCase())
    );
    const fuse = new Fuse(suggestions, {
      findAllMatches: true,
      threshold: 0.8
    });
    const search2 = fuse.search(this.lastInput).map((value) => value.item);
    return search2;
  }
  renderSuggestion(item, el) {
    el.setText(item);
  }
  selectSuggestion(item) {
    const cursorPosition = this.inputEl.selectionStart;
    const lastInputLength = this.lastInput.length;
    const currentInputValue = this.inputEl.value;
    let insertedEndPosition = 0;
    this.inputEl.value = this.getNewInputValueForTag(
      currentInputValue,
      item,
      cursorPosition,
      lastInputLength
    );
    insertedEndPosition = cursorPosition - lastInputLength + item.length - 1;
    this.inputEl.trigger("input");
    this.close();
    this.inputEl.setSelectionRange(
      insertedEndPosition,
      insertedEndPosition
    );
  }
  getNewInputValueForTag(currentInputElValue, selectedItem, cursorPosition, lastInputLength) {
    return `${currentInputElValue.substr(
      0,
      cursorPosition - lastInputLength - 1
    )}${selectedItem}${currentInputElValue.substr(cursorPosition)}`;
  }
};

// src/gui/GenericInputPrompt/GenericInputPrompt.ts
var GenericInputPrompt = class extends import_obsidian4.Modal {
  constructor(app2, header, placeholder, value) {
    super(app2);
    this.header = header;
    this.didSubmit = false;
    this.submitClickCallback = (evt) => this.submit();
    this.cancelClickCallback = (evt) => this.cancel();
    this.submitEnterCallback = (evt) => {
      if (!evt.isComposing && evt.key === "Enter") {
        evt.preventDefault();
        this.submit();
      }
    };
    this.placeholder = placeholder;
    this.input = value;
    this.waitForClose = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
      this.rejectPromise = reject;
    });
    this.display();
    this.open();
    this.fileSuggester = new SilentFileSuggester(
      app2,
      this.inputComponent.inputEl
    );
    this.tagSuggester = new SilentTagSuggester(
      app2,
      this.inputComponent.inputEl
    );
  }
  static Prompt(app2, header, placeholder, value) {
    const newPromptModal = new GenericInputPrompt(
      app2,
      header,
      placeholder,
      value
    );
    return newPromptModal.waitForClose;
  }
  display() {
    this.containerEl.addClass("quickAddModal", "qaInputPrompt");
    this.contentEl.empty();
    this.titleEl.textContent = this.header;
    const mainContentContainer = this.contentEl.createDiv();
    this.inputComponent = this.createInputField(
      mainContentContainer,
      this.placeholder,
      this.input
    );
    this.createButtonBar(mainContentContainer);
  }
  createInputField(container, placeholder, value) {
    const textComponent = new import_obsidian4.TextComponent(container);
    textComponent.inputEl.style.width = "100%";
    textComponent.setPlaceholder(placeholder != null ? placeholder : "").setValue(value != null ? value : "").onChange((value2) => this.input = value2).inputEl.addEventListener("keydown", this.submitEnterCallback);
    return textComponent;
  }
  createButton(container, text2, callback) {
    const btn = new import_obsidian4.ButtonComponent(container);
    btn.setButtonText(text2).onClick(callback);
    return btn;
  }
  createButtonBar(mainContentContainer) {
    const buttonBarContainer = mainContentContainer.createDiv();
    this.createButton(
      buttonBarContainer,
      "Ok",
      this.submitClickCallback
    ).setCta().buttonEl.style.marginRight = "0";
    this.createButton(
      buttonBarContainer,
      "Cancel",
      this.cancelClickCallback
    );
    buttonBarContainer.style.display = "flex";
    buttonBarContainer.style.flexDirection = "row-reverse";
    buttonBarContainer.style.justifyContent = "flex-start";
    buttonBarContainer.style.marginTop = "1rem";
  }
  submit() {
    this.didSubmit = true;
    this.close();
  }
  cancel() {
    this.close();
  }
  resolveInput() {
    if (!this.didSubmit)
      this.rejectPromise("No input given.");
    else
      this.resolvePromise(this.input);
  }
  removeInputListener() {
    this.inputComponent.inputEl.removeEventListener(
      "keydown",
      this.submitEnterCallback
    );
  }
  onOpen() {
    super.onOpen();
    this.inputComponent.inputEl.focus();
    this.inputComponent.inputEl.select();
  }
  onClose() {
    super.onClose();
    this.resolveInput();
    this.removeInputListener();
  }
};

// src/logger/logManager.ts
var _LogManager = class {
  register(logger) {
    _LogManager.loggers.push(logger);
    return this;
  }
  logError(message) {
    _LogManager.loggers.forEach((logger) => logger.logError(message));
  }
  logWarning(message) {
    _LogManager.loggers.forEach((logger) => logger.logError(message));
  }
  logMessage(message) {
    _LogManager.loggers.forEach((logger) => logger.logMessage(message));
  }
};
var LogManager = _LogManager;
LogManager.loggers = [];
var log = new LogManager();

// src/gui/suggesters/genericTextSuggester.ts
var GenericTextSuggester = class extends TextInputSuggest {
  constructor(app2, inputEl, items) {
    super(app2, inputEl);
    this.app = app2;
    this.inputEl = inputEl;
    this.items = items;
  }
  getSuggestions(inputStr) {
    const inputLowerCase = inputStr.toLowerCase();
    const filtered = this.items.filter((item) => {
      if (item.toLowerCase().contains(inputLowerCase))
        return item;
    });
    if (!filtered)
      this.close();
    if ((filtered == null ? void 0 : filtered.length) > 0)
      return filtered;
    return [];
  }
  selectSuggestion(item) {
    this.inputEl.value = item;
    this.inputEl.trigger("input");
    this.close();
  }
  renderSuggestion(value, el) {
    if (value)
      el.setText(value);
  }
};

// src/gui/ChoiceBuilder/choiceBuilder.ts
var ChoiceBuilder = class extends import_obsidian5.Modal {
  constructor(app2) {
    super(app2);
    this.didSubmit = false;
    this.svelteElements = [];
    this.waitForClose = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
      this.rejectPromise = reject;
    });
    this.containerEl.addClass("quickAddModal");
    this.open();
  }
  reload() {
    this.contentEl.empty();
    this.display();
  }
  addFileSearchInputToSetting(setting, value, onChangeCallback) {
    let component;
    setting.addSearch((searchComponent) => {
      component = searchComponent;
      searchComponent.setValue(value);
      searchComponent.setPlaceholder("File path");
      const markdownFiles = this.app.vault.getMarkdownFiles().map((f) => f.path);
      new GenericTextSuggester(
        this.app,
        searchComponent.inputEl,
        markdownFiles
      );
      searchComponent.onChange(onChangeCallback);
    });
    return component;
  }
  addCenteredChoiceNameHeader(choice) {
    const headerEl = this.contentEl.createEl("h2", {
      cls: "choiceNameHeader"
    });
    headerEl.setText(choice.name);
    headerEl.addEventListener("click", async (ev) => {
      try {
        const newName = await GenericInputPrompt.Prompt(
          this.app,
          choice.name,
          "Choice name",
          choice.name
        );
        if (newName !== choice.name) {
          choice.name = newName;
          headerEl.setText(newName);
        }
      } catch (e) {
        log.logMessage(`No new name given for ${choice.name}`);
      }
    });
  }
  onClose() {
    super.onClose();
    this.resolvePromise(this.choice);
    this.svelteElements.forEach((el) => {
      if (el && el.$destroy)
        el.$destroy();
    });
    if (!this.didSubmit)
      this.rejectPromise("No answer given.");
    else
      this.resolvePromise(this.input);
  }
};

// src/gui/ChoiceBuilder/templateChoiceBuilder.ts
var import_obsidian7 = require("obsidian");

// src/gui/ChoiceBuilder/FolderList.svelte
function add_css7(target) {
  append_styles(target, "svelte-tuapcq", ".quickAddCommandListItem.svelte-tuapcq{display:flex;align-items:center;justify-content:space-between}@media(min-width: 768px){.quickAddFolderListGrid.svelte-tuapcq{display:grid;grid-template-columns:repeat(2, 1fr);column-gap:20px}}.quickAddCommandList.svelte-tuapcq{max-width:50%;margin:12px auto}.clickable.svelte-tuapcq{cursor:pointer}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  child_ctx[6] = i;
  return child_ctx;
}
function create_each_block3(ctx) {
  let div;
  let span0;
  let t0_value = ctx[4] + "";
  let t0;
  let t1;
  let span1;
  let icon;
  let t2;
  let current;
  let mounted;
  let dispose;
  icon = new Icon_default({ props: { data: faTrash } });
  function click_handler() {
    return ctx[3](ctx[4]);
  }
  return {
    c() {
      div = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      create_component(icon.$$.fragment);
      t2 = space();
      attr(span1, "class", "clickable svelte-tuapcq");
      attr(div, "class", "quickAddCommandListItem svelte-tuapcq");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span0);
      append(span0, t0);
      append(div, t1);
      append(div, span1);
      mount_component(icon, span1, null);
      append(div, t2);
      current = true;
      if (!mounted) {
        dispose = listen(span1, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[4] + ""))
        set_data(t0, t0_value);
    },
    i(local) {
      if (current)
        return;
      transition_in(icon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(icon);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment11(ctx) {
  let div;
  let current;
  let each_value = ctx[0];
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "quickAddFolderListGrid quickAddCommandList svelte-tuapcq");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (dirty & 3) {
        each_value = ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance11($$self, $$props, $$invalidate) {
  let { folders } = $$props;
  let { deleteFolder } = $$props;
  const updateFolders = (newFolders) => {
    $$invalidate(0, folders = newFolders);
  };
  const click_handler = (folder) => deleteFolder(folder);
  $$self.$$set = ($$props2) => {
    if ("folders" in $$props2)
      $$invalidate(0, folders = $$props2.folders);
    if ("deleteFolder" in $$props2)
      $$invalidate(1, deleteFolder = $$props2.deleteFolder);
  };
  return [folders, deleteFolder, updateFolders, click_handler];
}
var FolderList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance11,
      create_fragment11,
      safe_not_equal,
      {
        folders: 0,
        deleteFolder: 1,
        updateFolders: 2
      },
      add_css7
    );
  }
  get updateFolders() {
    return this.$$.ctx[2];
  }
};
var FolderList_default = FolderList;

// src/utility.ts
var import_obsidian6 = require("obsidian");
function getTemplater(app2) {
  return app2.plugins.plugins["templater-obsidian"];
}
async function replaceTemplaterTemplatesInCreatedFile(app2, file, force = false) {
  var _a;
  const templater = getTemplater(app2);
  if (templater && (force || !(templater == null ? void 0 : templater.settings["trigger_on_file_creation"]))) {
    const active_file = app2.workspace.getActiveFile();
    if ((_a = templater == null ? void 0 : templater.templater) == null ? void 0 : _a.overwrite_file_commands) {
      await templater.templater.overwrite_file_commands(file);
    }
  }
}
async function templaterParseTemplate(app2, templateContent, targetFile) {
  const templater = getTemplater(app2);
  if (!templater)
    return templateContent;
  return await templater.templater.parse_template(
    { target_file: targetFile, run_mode: 4 },
    templateContent
  );
}
function getCoreTemplatesPath(app2) {
  const internalTemplatePlugin = app2.internalPlugins.plugins.templates;
  if (internalTemplatePlugin) {
    const templateFolderPath = internalTemplatePlugin.instance.options.folder;
    if (templateFolderPath)
      return templateFolderPath;
  }
}
function getTemplaterTemplatesPath(app2) {
  const templater = getTemplater(app2);
  if (templater) {
    const templateFolderPath = templater.settings["template_folder"];
    if (templateFolderPath)
      return templateFolderPath;
  }
}
function getTemplateFiles(app2) {
  let templateFiles = /* @__PURE__ */ new Set();
  const markdownFiles = app2.vault.getMarkdownFiles();
  const coreTemplatesPath = getCoreTemplatesPath(app2);
  const templaterTemplatesPath = getTemplaterTemplatesPath(app2);
  markdownFiles.forEach((file) => {
    if (file.path.contains(coreTemplatesPath) || file.path.contains(templaterTemplatesPath))
      templateFiles.add(file);
  });
  return [...templateFiles];
}
function getTemplatePaths(app2) {
  return getTemplateFiles(app2).map((file) => file.path);
}
function getNaturalLanguageDates(app2) {
  return app2.plugins.plugins["nldates-obsidian"];
}
function getDate(input) {
  let duration;
  if ((input == null ? void 0 : input.offset) !== null && (input == null ? void 0 : input.offset) !== void 0 && typeof input.offset === "number") {
    duration = window.moment.duration(input.offset, "days");
  }
  return (input == null ? void 0 : input.format) ? window.moment().add(duration).format(input.format) : window.moment().add(duration).format("YYYY-MM-DD");
}
function appendToCurrentLine(toAppend, app2) {
  try {
    const activeView = app2.workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
    if (!activeView) {
      log.logError(`unable to append '${toAppend}' to current line.`);
      return;
    }
    activeView.editor.replaceSelection(toAppend);
  } catch (e) {
    log.logError(`unable to append '${toAppend}' to current line.`);
  }
}
function findObsidianCommand(app2, commandId) {
  return app2.commands.findCommand(commandId);
}
function deleteObsidianCommand(app2, commandId) {
  if (findObsidianCommand(app2, commandId)) {
    delete app2.commands.commands[commandId];
    delete app2.commands.editorCommands[commandId];
  }
}
function getAllFolderPathsInVault(app2) {
  return app2.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian6.TFolder).map((folder) => folder.path);
}
function getUserScriptMemberAccess(fullMemberPath) {
  const fullMemberArray = fullMemberPath.split("::");
  return {
    basename: fullMemberArray[0],
    memberAccess: fullMemberArray.slice(1)
  };
}
function waitFor(ms) {
  return new Promise((res) => setTimeout(res, ms));
}
function getLinesInString(input) {
  let lines = [];
  let tempString = input;
  while (tempString.contains("\n")) {
    const lineEndIndex = tempString.indexOf("\n");
    lines.push(tempString.slice(0, lineEndIndex));
    tempString = tempString.slice(lineEndIndex + 1);
  }
  lines.push(tempString);
  return lines;
}
function escapeRegExp(text2) {
  return text2.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
async function openFile(app2, file, optional) {
  let leaf;
  if (optional.openInNewTab && optional.direction) {
    leaf = app2.workspace.getLeaf("split", optional.direction);
  } else {
    leaf = app2.workspace.getLeaf("tab");
  }
  await leaf.openFile(file);
  if (optional == null ? void 0 : optional.focus) {
    app2.workspace.setActiveLeaf(leaf, { focus: optional.focus });
  }
  if (optional == null ? void 0 : optional.mode) {
    const leafViewState = leaf.getViewState();
    leaf.setViewState({
      ...leafViewState,
      state: {
        ...leafViewState.state,
        mode: optional.mode
      }
    });
  }
}
async function getUserScript(command, app2) {
  const file = app2.vault.getAbstractFileByPath(command.path);
  if (!file) {
    log.logError(`failed to load file ${command.path}.`);
    return;
  }
  if (file instanceof import_obsidian6.TFile) {
    let req = (s) => window.require && window.require(s);
    let exp = {};
    let mod = { exports: exp };
    const fileContent = await app2.vault.read(file);
    const fn2 = window.eval(
      `(function(require, module, exports) { ${fileContent} 
})`
    );
    fn2(req, mod, exp);
    const userScript = exp["default"] || mod.exports;
    if (!userScript)
      return;
    let script = userScript;
    const { memberAccess } = getUserScriptMemberAccess(command.name);
    if (memberAccess && memberAccess.length > 0) {
      let member;
      while (member = memberAccess.shift()) {
        script = script[member];
      }
    }
    return script;
  }
}
function excludeKeys(sourceObj, except) {
  const obj = structuredClone(sourceObj);
  for (const key of except) {
    delete obj[key];
  }
  return obj;
}
function getChoiceType(choice) {
  const isTemplate = (choice2) => choice2.type === "Template" /* Template */;
  const isMacro = (choice2) => choice2.type === "Macro" /* Macro */;
  const isCapture = (choice2) => choice2.type === "Capture" /* Capture */;
  const isMulti = (choice2) => choice2.type === "Multi" /* Multi */;
  return isTemplate(choice) || isMacro(choice) || isCapture(choice) || isMulti(choice);
}

// src/formatters/formatter.ts
var Formatter = class {
  constructor() {
    this.variables = /* @__PURE__ */ new Map();
  }
  replacer(str, reg, replaceValue) {
    return str.replace(reg, function() {
      return replaceValue;
    });
  }
  replaceDateInString(input) {
    let output = input;
    while (DATE_REGEX.test(output)) {
      const dateMatch = DATE_REGEX.exec(output);
      let offset2;
      if (dateMatch && dateMatch[1]) {
        const offsetString = dateMatch[1].replace("+", "").trim();
        const offsetIsInt = NUMBER_REGEX.test(offsetString);
        if (offsetIsInt)
          offset2 = parseInt(offsetString);
      }
      output = this.replacer(
        output,
        DATE_REGEX,
        getDate({ offset: offset2 })
      );
    }
    while (DATE_REGEX_FORMATTED.test(output)) {
      const dateMatch = DATE_REGEX_FORMATTED.exec(output);
      if (!dateMatch)
        throw new Error("unable to parse date");
      const format3 = dateMatch[1];
      let offset2;
      if (dateMatch[2]) {
        const offsetString = dateMatch[2].replace("+", "").trim();
        const offsetIsInt = NUMBER_REGEX.test(offsetString);
        if (offsetIsInt)
          offset2 = parseInt(offsetString);
      }
      output = this.replacer(
        output,
        DATE_REGEX_FORMATTED,
        getDate({ format: format3, offset: offset2 })
      );
    }
    return output;
  }
  async replaceValueInString(input) {
    let output = input;
    while (NAME_VALUE_REGEX.test(output)) {
      if (!this.value)
        this.value = await this.promptForValue();
      output = this.replacer(output, NAME_VALUE_REGEX, this.value);
    }
    return output;
  }
  async replaceLinkToCurrentFileInString(input) {
    const currentFilePathLink = this.getCurrentFileLink();
    let output = input;
    while (LINK_TO_CURRENT_FILE_REGEX.test(output))
      output = this.replacer(
        output,
        LINK_TO_CURRENT_FILE_REGEX,
        currentFilePathLink
      );
    return output;
  }
  async replaceVariableInString(input) {
    let output = input;
    while (VARIABLE_REGEX.test(output)) {
      const match = VARIABLE_REGEX.exec(output);
      if (!match)
        throw new Error("unable to parse variable");
      const variableName = match[1];
      if (variableName) {
        if (!this.getVariableValue(variableName)) {
          const suggestedValues = variableName.split(",");
          if (suggestedValues.length === 1)
            this.variables.set(
              variableName,
              await this.promptForVariable(variableName)
            );
          else
            this.variables.set(
              variableName,
              await this.suggestForValue(suggestedValues)
            );
        }
        output = this.replacer(
          output,
          VARIABLE_REGEX,
          this.getVariableValue(variableName)
        );
      } else {
        break;
      }
    }
    return output;
  }
  async replaceMathValueInString(input) {
    let output = input;
    while (MATH_VALUE_REGEX.test(output)) {
      const mathstr = await this.promptForMathValue();
      output = this.replacer(output, MATH_VALUE_REGEX, mathstr);
    }
    return output;
  }
  async replaceMacrosInString(input) {
    let output = input;
    while (MACRO_REGEX.test(output)) {
      const macroName = MACRO_REGEX.exec(output)[1];
      const macroOutput = await this.getMacroValue(macroName);
      output = this.replacer(
        output,
        MACRO_REGEX,
        macroOutput ? macroOutput.toString() : ""
      );
    }
    return output;
  }
  async replaceDateVariableInString(input) {
    let output = input;
    while (DATE_VARIABLE_REGEX.test(output)) {
      const match = DATE_VARIABLE_REGEX.exec(output);
      const variableName = match[1];
      const dateFormat = match[2];
      if (variableName && dateFormat) {
        if (!this.variables.get(variableName)) {
          this.variables.set(
            variableName,
            await this.promptForVariable(variableName)
          );
          const parseAttempt = this.getNaturalLanguageDates().parseDate(
            this.variables.get(variableName)
          );
          if (parseAttempt)
            this.variables.set(
              variableName,
              parseAttempt.moment.format(dateFormat)
            );
          else
            throw new Error(
              `unable to parse date variable ${this.variables.get(
                variableName
              )}`
            );
        }
        output = this.replacer(
          output,
          DATE_VARIABLE_REGEX,
          this.variables.get(variableName)
        );
      } else {
        break;
      }
    }
    return output;
  }
  async replaceTemplateInString(input) {
    let output = input;
    while (TEMPLATE_REGEX.test(output)) {
      const templatePath = TEMPLATE_REGEX.exec(output)[1];
      const templateContent = await this.getTemplateContent(templatePath);
      output = this.replacer(output, TEMPLATE_REGEX, templateContent);
    }
    return output;
  }
  replaceLinebreakInString(input) {
    let output = input;
    let match = LINEBREAK_REGEX.exec(output);
    while (match && input[match.index - 1] !== "\\") {
      output = this.replacer(output, LINEBREAK_REGEX, `
`);
      match = LINEBREAK_REGEX.exec(output);
    }
    const EscapedLinebreakRegex = /\\\\n/;
    while (EscapedLinebreakRegex.test(output)) {
      output = this.replacer(output, EscapedLinebreakRegex, `\\n`);
    }
    return output;
  }
};

// src/formatters/fileNameDisplayFormatter.ts
var FileNameDisplayFormatter = class extends Formatter {
  constructor(app2) {
    super();
    this.app = app2;
  }
  async format(input) {
    let output = input;
    output = await this.replaceMacrosInString(output);
    output = this.replaceDateInString(output);
    output = await this.replaceValueInString(output);
    output = await this.replaceDateVariableInString(output);
    output = await this.replaceVariableInString(output);
    return `File Name: ${output}`;
  }
  promptForValue(header) {
    return `FileName`;
  }
  getVariableValue(variableName) {
    return variableName;
  }
  getCurrentFileLink() {
    var _a, _b;
    return (_b = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) != null ? _b : "";
  }
  getNaturalLanguageDates() {
    return getNaturalLanguageDates(this.app);
  }
  suggestForValue(suggestedValues) {
    return "_suggest_";
  }
  promptForMathValue() {
    return Promise.resolve("_math_");
  }
  getMacroValue(macroName) {
    return `_macro: ${macroName}`;
  }
  async promptForVariable(variableName) {
    return `_${variableName}_`;
  }
  async getTemplateContent(templatePath) {
    return `/${templatePath}/`;
  }
  async getSelectedText() {
    return "_selected_";
  }
};

// src/gui/suggesters/formatSyntaxSuggester.ts
var FormatSyntaxSuggester = class extends TextInputSuggest {
  constructor(app2, inputEl, plugin, suggestForFileNames = false) {
    super(app2, inputEl);
    this.app = app2;
    this.inputEl = inputEl;
    this.plugin = plugin;
    this.suggestForFileNames = suggestForFileNames;
    this.lastInput = "";
    this.macroNames = this.plugin.settings.macros.map(
      (macro) => macro.name
    );
    this.templatePaths = getTemplatePaths(this.app);
  }
  getSuggestions(inputStr) {
    const cursorPosition = this.inputEl.selectionStart;
    const lookbehind = 15;
    const inputBeforeCursor = inputStr.substr(
      cursorPosition - lookbehind,
      lookbehind
    );
    let suggestions = [];
    this.processToken(
      inputBeforeCursor,
      (match, type, suggestion) => {
        this.lastInput = match[0];
        this.lastInputType = type;
        suggestions.push(suggestion);
        if (this.lastInputType === 8 /* Template */) {
          suggestions.push(
            ...this.templatePaths.map(
              (templatePath) => `{{TEMPLATE:${templatePath}}}`
            )
          );
        }
        if (this.lastInputType === 7 /* Macro */) {
          suggestions.push(
            ...this.macroNames.map(
              (macroName) => `{{MACRO:${macroName}}}`
            )
          );
        }
      }
    );
    return suggestions;
  }
  selectSuggestion(item) {
    const cursorPosition = this.inputEl.selectionStart;
    const lastInputLength = this.lastInput.length;
    const currentInputValue = this.inputEl.value;
    let insertedEndPosition = 0;
    const insert2 = (text2, offset2 = 0) => {
      return `${currentInputValue.substr(
        0,
        cursorPosition - lastInputLength + offset2
      )}${text2}${currentInputValue.substr(cursorPosition)}`;
    };
    this.processToken(item, (match, type, suggestion) => {
      if (item.contains(suggestion)) {
        this.inputEl.value = insert2(item);
        this.lastInputType = type;
        insertedEndPosition = cursorPosition - lastInputLength + item.length;
        if (this.lastInputType === 2 /* VariableDate */ || this.lastInputType === 5 /* Variable */ || this.lastInputType === 1 /* DateFormat */) {
          insertedEndPosition -= 2;
        }
      }
    });
    this.inputEl.trigger("input");
    this.close();
    this.inputEl.setSelectionRange(
      insertedEndPosition,
      insertedEndPosition
    );
  }
  renderSuggestion(value, el) {
    if (value)
      el.setText(value);
  }
  processToken(input, callback) {
    const dateFormatMatch = DATE_FORMAT_SYNTAX_SUGGEST_REGEX.exec(input);
    if (dateFormatMatch)
      callback(
        dateFormatMatch,
        1 /* DateFormat */,
        "{{DATE:}}"
      );
    const dateMatch = DATE_SYNTAX_SUGGEST_REGEX.exec(input);
    if (dateMatch)
      callback(dateMatch, 0 /* Date */, DATE_SYNTAX);
    const nameMatch = NAME_SYNTAX_SUGGEST_REGEX.exec(input);
    if (nameMatch)
      callback(nameMatch, 4 /* Name */, NAME_SYNTAX);
    const valueMatch = VALUE_SYNTAX_SUGGEST_REGEX.exec(input);
    if (valueMatch)
      callback(valueMatch, 3 /* Value */, VALUE_SYNTAX);
    const mathValueMatch = MATH_VALUE_SYNTAX_SUGGEST_REGEX.exec(input);
    if (mathValueMatch)
      callback(
        mathValueMatch,
        9 /* MathValue */,
        MATH_VALUE_SYNTAX
      );
    const variableMatch = VARIABLE_SYNTAX_SUGGEST_REGEX.exec(input);
    if (variableMatch)
      callback(variableMatch, 5 /* Variable */, "{{VALUE:}}");
    const variableDateMatch = VARIABLE_DATE_SYNTAX_SUGGEST_REGEX.exec(input);
    if (variableDateMatch)
      callback(
        variableDateMatch,
        2 /* VariableDate */,
        "{{VDATE:}}"
      );
    if (!this.suggestForFileNames) {
      const linkCurrentMatch = LINKCURRENT_SYNTAX_SUGGEST_REGEX.exec(input);
      if (linkCurrentMatch)
        callback(
          linkCurrentMatch,
          6 /* LinkCurrent */,
          LINKCURRENT_SYNTAX
        );
      const templateMatch = TEMPLATE_SYNTAX_SUGGEST_REGEX.exec(input);
      if (templateMatch)
        callback(
          templateMatch,
          8 /* Template */,
          "{{TEMPLATE:"
        );
      const macroMatch = MACRO_SYNTAX_SUGGEST_REGEX.exec(input);
      if (macroMatch)
        callback(macroMatch, 7 /* Macro */, "{{MACRO:");
    }
  }
};

// src/gui/suggesters/exclusiveSuggester.ts
var ExclusiveSuggester = class extends TextInputSuggest {
  constructor(app2, inputEl, suggestItems, currentItems) {
    super(app2, inputEl);
    this.app = app2;
    this.inputEl = inputEl;
    this.suggestItems = suggestItems;
    this.currentItems = currentItems;
  }
  updateCurrentItems(currentItems) {
    this.currentItems = currentItems;
  }
  getSuggestions(inputStr) {
    return this.suggestItems.filter((item) => item.contains(inputStr));
  }
  selectSuggestion(item) {
    this.inputEl.value = item;
    this.inputEl.trigger("input");
    this.close();
  }
  renderSuggestion(value, el) {
    if (value)
      el.setText(value);
  }
};

// src/gui/ChoiceBuilder/templateChoiceBuilder.ts
var TemplateChoiceBuilder = class extends ChoiceBuilder {
  constructor(app2, choice, plugin) {
    super(app2);
    this.plugin = plugin;
    this.choice = choice;
    this.display();
  }
  display() {
    this.containerEl.addClass("templateChoiceBuilder");
    this.addCenteredChoiceNameHeader(this.choice);
    this.addTemplatePathSetting();
    this.addFileNameFormatSetting();
    this.addFolderSetting();
    this.addAppendLinkSetting();
    this.addIncrementFileNameSetting();
    this.addOpenFileSetting();
    if (this.choice.openFile)
      this.addOpenFileInNewTabSetting();
  }
  addTemplatePathSetting() {
    const templatePathSetting = new import_obsidian7.Setting(this.contentEl).setName("Template Path").setDesc("Path to the Template.").addSearch((search2) => {
      const templates = getTemplatePaths(this.app);
      search2.setValue(this.choice.templatePath);
      search2.setPlaceholder("Template path");
      new GenericTextSuggester(this.app, search2.inputEl, templates);
      search2.onChange((value) => {
        this.choice.templatePath = value;
      });
    });
  }
  addFileNameFormatSetting() {
    let textField;
    const enableSetting = new import_obsidian7.Setting(this.contentEl);
    enableSetting.setName("File Name Format").setDesc("Set the file name format.").addToggle((toggleComponent) => {
      toggleComponent.setValue(this.choice.fileNameFormat.enabled).onChange((value) => {
        this.choice.fileNameFormat.enabled = value;
        textField.setDisabled(!value);
      });
    });
    const formatDisplay = this.contentEl.createEl("span");
    const displayFormatter = new FileNameDisplayFormatter(this.app);
    (async () => formatDisplay.textContent = await displayFormatter.format(
      this.choice.fileNameFormat.format
    ))();
    const formatInput = new import_obsidian7.TextComponent(this.contentEl);
    formatInput.setPlaceholder("File name format");
    textField = formatInput;
    formatInput.inputEl.style.width = "100%";
    formatInput.inputEl.style.marginBottom = "8px";
    formatInput.setValue(this.choice.fileNameFormat.format).setDisabled(!this.choice.fileNameFormat.enabled).onChange(async (value) => {
      this.choice.fileNameFormat.format = value;
      formatDisplay.textContent = await displayFormatter.format(
        value
      );
    });
    new FormatSyntaxSuggester(
      this.app,
      textField.inputEl,
      this.plugin,
      true
    );
  }
  addFolderSetting() {
    var _a, _b, _c, _d;
    const folderSetting = new import_obsidian7.Setting(this.contentEl);
    folderSetting.setName("Create in folder").setDesc(
      "Create the file in the specified folder. If multiple folders are specified, you will be prompted for which folder to create the file in."
    ).addToggle((toggle) => {
      toggle.setValue(this.choice.folder.enabled);
      toggle.onChange((value) => {
        this.choice.folder.enabled = value;
        this.reload();
      });
    });
    if (!this.choice.folder.enabled) {
      return;
    }
    if (!((_a = this.choice.folder) == null ? void 0 : _a.createInSameFolderAsActiveFile)) {
      const chooseFolderWhenCreatingNoteContainer = this.contentEl.createDiv(
        "chooseFolderWhenCreatingNoteContainer"
      );
      chooseFolderWhenCreatingNoteContainer.createEl("span", {
        text: "Choose folder when creating a new note"
      });
      const chooseFolderWhenCreatingNote = new import_obsidian7.ToggleComponent(chooseFolderWhenCreatingNoteContainer);
      chooseFolderWhenCreatingNote.setValue((_b = this.choice.folder) == null ? void 0 : _b.chooseWhenCreatingNote).onChange((value) => {
        this.choice.folder.chooseWhenCreatingNote = value;
        this.reload();
      });
      if (!((_c = this.choice.folder) == null ? void 0 : _c.chooseWhenCreatingNote)) {
        this.addFolderSelector();
      }
      const chooseFolderFromSubfolderContainer = this.contentEl.createDiv("chooseFolderFromSubfolderContainer");
      const stn = new import_obsidian7.Setting(chooseFolderFromSubfolderContainer);
      stn.setName("Include subfolders").setDesc("Get prompted to choose from both the selected folders and their subfolders when creating the note.").addToggle(
        (toggle) => {
          var _a2;
          return toggle.setValue((_a2 = this.choice.folder) == null ? void 0 : _a2.chooseFromSubfolders).onChange((value) => {
            this.choice.folder.chooseFromSubfolders = value;
            this.reload();
          });
        }
      );
    }
    if (!((_d = this.choice.folder) == null ? void 0 : _d.chooseWhenCreatingNote)) {
      const createInSameFolderAsActiveFileSetting = new import_obsidian7.Setting(
        this.contentEl
      );
      createInSameFolderAsActiveFileSetting.setName("Create in same folder as active file").setDesc(
        "Creates the file in the same folder as the currently active file. Will not create the file if there is no active file."
      ).addToggle(
        (toggle) => {
          var _a2;
          return toggle.setValue(
            (_a2 = this.choice.folder) == null ? void 0 : _a2.createInSameFolderAsActiveFile
          ).onChange((value) => {
            this.choice.folder.createInSameFolderAsActiveFile = value;
            this.reload();
          });
        }
      );
    }
  }
  addFolderSelector() {
    const folderSelectionContainer = this.contentEl.createDiv("folderSelectionContainer");
    const folderList = folderSelectionContainer.createDiv("folderList");
    const folderListEl = new FolderList_default({
      target: folderList,
      props: {
        folders: this.choice.folder.folders,
        deleteFolder: (folder) => {
          this.choice.folder.folders = this.choice.folder.folders.filter((f) => f !== folder);
          folderListEl.updateFolders(this.choice.folder.folders);
          suggester.updateCurrentItems(this.choice.folder.folders);
        }
      }
    });
    this.svelteElements.push(folderListEl);
    const inputContainer = folderSelectionContainer.createDiv(
      "folderInputContainer"
    );
    const folderInput = new import_obsidian7.TextComponent(inputContainer);
    folderInput.inputEl.style.width = "100%";
    folderInput.setPlaceholder("Folder path");
    const allFolders = getAllFolderPathsInVault(this.app);
    const suggester = new ExclusiveSuggester(
      this.app,
      folderInput.inputEl,
      allFolders,
      this.choice.folder.folders
    );
    const addFolder = () => {
      const input = folderInput.inputEl.value.trim();
      if (this.choice.folder.folders.some((folder) => folder === input)) {
        log.logWarning("cannot add same folder twice.");
        return;
      }
      this.choice.folder.folders.push(input);
      folderListEl.updateFolders(this.choice.folder.folders);
      folderInput.inputEl.value = "";
      suggester.updateCurrentItems(this.choice.folder.folders);
    };
    folderInput.inputEl.addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        addFolder();
      }
    });
    const addButton = new import_obsidian7.ButtonComponent(inputContainer);
    addButton.setCta().setButtonText("Add").onClick((evt) => {
      addFolder();
    });
  }
  addAppendLinkSetting() {
    const appendLinkSetting = new import_obsidian7.Setting(this.contentEl);
    appendLinkSetting.setName("Append link").setDesc("Append link to created file to current file.").addToggle((toggle) => {
      toggle.setValue(this.choice.appendLink);
      toggle.onChange((value) => this.choice.appendLink = value);
    });
  }
  addIncrementFileNameSetting() {
    const incrementFileNameSetting = new import_obsidian7.Setting(this.contentEl);
    incrementFileNameSetting.setName("Increment file name").setDesc("If the file already exists, increment the file name.").addToggle((toggle) => {
      toggle.setValue(this.choice.incrementFileName);
      toggle.onChange(
        (value) => this.choice.incrementFileName = value
      );
    });
  }
  addOpenFileSetting() {
    const noOpenSetting = new import_obsidian7.Setting(this.contentEl);
    noOpenSetting.setName("Open").setDesc("Open the created file.").addToggle((toggle) => {
      toggle.setValue(this.choice.openFile);
      toggle.onChange((value) => {
        this.choice.openFile = value;
        this.reload();
      });
    }).addDropdown((dropdown) => {
      dropdown.selectEl.style.marginLeft = "10px";
      if (!this.choice.openFileInMode)
        this.choice.openFileInMode = "default";
      dropdown.addOption("source", "Source").addOption("preview", "Preview").addOption("default", "Default").setValue(this.choice.openFileInMode).onChange(
        (value) => this.choice.openFileInMode = value
      );
    });
  }
  addOpenFileInNewTabSetting() {
    const newTabSetting = new import_obsidian7.Setting(this.contentEl);
    newTabSetting.setName("New split").setDesc("Split your editor and open file in new split.").addToggle((toggle) => {
      toggle.setValue(this.choice.openFileInNewTab.enabled);
      toggle.onChange(
        (value) => this.choice.openFileInNewTab.enabled = value
      );
    }).addDropdown((dropdown) => {
      dropdown.selectEl.style.marginLeft = "10px";
      dropdown.addOption("vertical" /* vertical */, "Vertical");
      dropdown.addOption("horizontal" /* horizontal */, "Horizontal");
      dropdown.setValue(this.choice.openFileInNewTab.direction);
      dropdown.onChange(
        (value) => this.choice.openFileInNewTab.direction = value
      );
    });
    new import_obsidian7.Setting(this.contentEl).setName("Focus new pane").setDesc("Focus the opened tab immediately after opening").addToggle(
      (toggle) => toggle.setValue(this.choice.openFileInNewTab.focus).onChange(
        (value) => this.choice.openFileInNewTab.focus = value
      )
    );
  }
};

// src/gui/ChoiceBuilder/captureChoiceBuilder.ts
var import_obsidian18 = require("obsidian");

// src/engine/QuickAddEngine.ts
var import_obsidian8 = require("obsidian");
var QuickAddEngine = class {
  constructor(app2) {
    this.app = app2;
  }
  async createFolder(folder) {
    const folderExists = await this.app.vault.adapter.exists(folder);
    if (!folderExists) {
      await this.app.vault.createFolder(folder);
    }
  }
  formatFilePath(folderPath, fileName) {
    const actualFolderPath = folderPath ? `${folderPath}/` : "";
    const formattedFileName = fileName.replace(
      MARKDOWN_FILE_EXTENSION_REGEX,
      ""
    );
    return `${actualFolderPath}${formattedFileName}.md`;
  }
  async fileExists(filePath) {
    return await this.app.vault.adapter.exists(filePath);
  }
  async getFileByPath(filePath) {
    const file = await this.app.vault.getAbstractFileByPath(filePath);
    if (!file) {
      log.logError(`${filePath} not found`);
      throw new Error(`${filePath} not found`);
    }
    if (file instanceof import_obsidian8.TFolder) {
      log.logError(`${filePath} found but it's a folder`);
      throw new Error(`${filePath} found but it's a folder`);
    }
    if (!(file instanceof import_obsidian8.TFile))
      throw new Error(`${filePath} is not a file`);
    return file;
  }
  async createFileWithInput(filePath, fileContent) {
    const dirMatch = filePath.match(/(.*)[\/\\]/);
    let dirName = "";
    if (dirMatch)
      dirName = dirMatch[1];
    if (await this.app.vault.adapter.exists(dirName)) {
      return await this.app.vault.create(filePath, fileContent);
    } else {
      await this.createFolder(dirName);
      return await this.app.vault.create(filePath, fileContent);
    }
  }
};

// src/gui/GenericSuggester/genericSuggester.ts
var import_obsidian9 = require("obsidian");
var GenericSuggester = class extends import_obsidian9.FuzzySuggestModal {
  constructor(app2, displayItems, items) {
    super(app2);
    this.displayItems = displayItems;
    this.items = items;
    this.promise = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
      this.rejectPromise = reject;
    });
    this.open();
  }
  static Suggest(app2, displayItems, items) {
    const newSuggester = new GenericSuggester(app2, displayItems, items);
    return newSuggester.promise;
  }
  getItemText(item) {
    return this.displayItems[this.items.indexOf(item)];
  }
  getItems() {
    return this.items;
  }
  selectSuggestion(value, evt) {
    this.resolved = true;
    super.selectSuggestion(value, evt);
  }
  onChooseItem(item, evt) {
    this.resolved = true;
    this.resolvePromise(item);
  }
  onClose() {
    super.onClose();
    if (!this.resolved)
      this.rejectPromise("no input given.");
  }
};

// src/engine/MacroChoiceEngine.ts
var obsidian = __toESM(require("obsidian"));

// src/gui/GenericCheckboxPrompt/genericCheckboxPrompt.ts
var import_obsidian10 = require("obsidian");
var GenericCheckboxPrompt = class extends import_obsidian10.Modal {
  constructor(app2, items, selectedItems = []) {
    super(app2);
    this.items = items;
    this.selectedItems = selectedItems;
    this._selectedItems = [...selectedItems];
    this.promise = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
      this.rejectPromise = reject;
    });
    this.display();
    this.open();
  }
  static Open(app2, items, selectedItems) {
    const newSuggester = new GenericCheckboxPrompt(
      app2,
      items,
      selectedItems
    );
    return newSuggester.promise;
  }
  display() {
    this.contentEl.empty();
    this.containerEl.addClass("quickAddModal", "checkboxPrompt");
    this.addCheckboxRows();
    this.addSubmitButton();
  }
  onClose() {
    super.onClose();
    if (!this.resolved)
      this.rejectPromise("no input given.");
  }
  addCheckboxRows() {
    const rowContainer = this.contentEl.createDiv(
      "checkboxRowContainer"
    );
    this.items.forEach((item) => this.addCheckboxRow(item, rowContainer));
  }
  addCheckboxRow(item, container) {
    const checkboxRow = container.createDiv("checkboxRow");
    const text2 = checkboxRow.createEl("span", {
      text: item
    });
    const checkbox = new import_obsidian10.ToggleComponent(checkboxRow);
    checkbox.setTooltip(`Toggle ${item}`).setValue(this._selectedItems.contains(item)).onChange((value) => {
      if (value)
        this._selectedItems.push(item);
      else {
        const index = this._selectedItems.findIndex(
          (value2) => item === value2
        );
        this._selectedItems.splice(index, 1);
      }
    });
  }
  addSubmitButton() {
    const submitButtonContainer = this.contentEl.createDiv(
      "submitButtonContainer"
    );
    const submitButton = new import_obsidian10.ButtonComponent(
      submitButtonContainer
    );
    submitButton.setButtonText("Submit").setCta().onClick((evt) => {
      this.resolved = true;
      this.resolvePromise(this._selectedItems);
      this.close();
    });
  }
};

// src/quickAddApi.ts
var import_obsidian12 = require("obsidian");

// src/gui/GenericWideInputPrompt/GenericWideInputPrompt.ts
var import_obsidian11 = require("obsidian");
var GenericWideInputPrompt = class extends import_obsidian11.Modal {
  constructor(app2, header, placeholder, value) {
    super(app2);
    this.header = header;
    this.didSubmit = false;
    this.submitClickCallback = (evt) => this.submit();
    this.cancelClickCallback = (evt) => this.cancel();
    this.submitEnterCallback = (evt) => {
      if ((evt.ctrlKey || evt.metaKey) && evt.key === "Enter") {
        evt.preventDefault();
        this.submit();
      }
    };
    this.placeholder = placeholder;
    this.input = value;
    this.waitForClose = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
      this.rejectPromise = reject;
    });
    this.display();
    this.open();
    this.fileSuggester = new SilentFileSuggester(
      app2,
      this.inputComponent.inputEl
    );
    this.tagSuggester = new SilentTagSuggester(
      app2,
      this.inputComponent.inputEl
    );
  }
  static Prompt(app2, header, placeholder, value) {
    const newPromptModal = new GenericWideInputPrompt(
      app2,
      header,
      placeholder,
      value
    );
    return newPromptModal.waitForClose;
  }
  display() {
    this.containerEl.addClass("quickAddModal", "qaWideInputPrompt");
    this.contentEl.empty();
    this.titleEl.textContent = this.header;
    const mainContentContainer = this.contentEl.createDiv();
    this.inputComponent = this.createInputField(
      mainContentContainer,
      this.placeholder,
      this.input
    );
    this.createButtonBar(mainContentContainer);
  }
  createInputField(container, placeholder, value) {
    const textComponent = new import_obsidian11.TextAreaComponent(container);
    textComponent.inputEl.classList.add("wideInputPromptInputEl");
    textComponent.setPlaceholder(placeholder != null ? placeholder : "").setValue(value != null ? value : "").onChange((value2) => this.input = value2).inputEl.addEventListener("keydown", this.submitEnterCallback);
    return textComponent;
  }
  createButton(container, text2, callback) {
    const btn = new import_obsidian11.ButtonComponent(container);
    btn.setButtonText(text2).onClick(callback);
    return btn;
  }
  createButtonBar(mainContentContainer) {
    const buttonBarContainer = mainContentContainer.createDiv();
    this.createButton(
      buttonBarContainer,
      "Ok",
      this.submitClickCallback
    ).setCta().buttonEl.style.marginRight = "0";
    this.createButton(
      buttonBarContainer,
      "Cancel",
      this.cancelClickCallback
    );
    buttonBarContainer.style.display = "flex";
    buttonBarContainer.style.flexDirection = "row-reverse";
    buttonBarContainer.style.justifyContent = "flex-start";
    buttonBarContainer.style.marginTop = "1rem";
  }
  submit() {
    this.didSubmit = true;
    this.close();
  }
  cancel() {
    this.close();
  }
  resolveInput() {
    if (!this.didSubmit)
      this.rejectPromise("No input given.");
    else
      this.resolvePromise(this.input);
  }
  removeInputListener() {
    this.inputComponent.inputEl.removeEventListener(
      "keydown",
      this.submitEnterCallback
    );
  }
  onOpen() {
    super.onOpen();
    this.inputComponent.inputEl.focus();
    this.inputComponent.inputEl.select();
  }
  onClose() {
    super.onClose();
    this.resolveInput();
    this.removeInputListener();
  }
};

// src/quickAddApi.ts
var QuickAddApi = class {
  static GetApi(app2, plugin, choiceExecutor) {
    return {
      inputPrompt: (header, placeholder, value) => {
        return this.inputPrompt(app2, header, placeholder, value);
      },
      wideInputPrompt: (header, placeholder, value) => {
        return this.wideInputPrompt(app2, header, placeholder, value);
      },
      yesNoPrompt: (header, text2) => {
        return this.yesNoPrompt(app2, header, text2);
      },
      suggester: (displayItems, actualItems) => {
        return this.suggester(app2, displayItems, actualItems);
      },
      checkboxPrompt: (items, selectedItems) => {
        return this.checkboxPrompt(app2, items, selectedItems);
      },
      executeChoice: async (choiceName, variables) => {
        const choice = plugin.getChoiceByName(choiceName);
        if (!choice)
          log.logError(`choice named '${choiceName}' not found`);
        if (variables) {
          Object.keys(variables).forEach((key) => {
            choiceExecutor.variables.set(key, variables[key]);
          });
        }
        await choiceExecutor.execute(choice);
        choiceExecutor.variables.clear();
      },
      format: async (input) => {
        return new CompleteFormatter(
          app2,
          plugin,
          choiceExecutor
        ).formatFileContent(input);
      },
      utility: {
        getClipboard: async () => {
          return await navigator.clipboard.readText();
        },
        setClipboard: async (text2) => {
          return await navigator.clipboard.writeText(text2);
        },
        getSelectedText: () => {
          const activeView = app2.workspace.getActiveViewOfType(import_obsidian12.MarkdownView);
          if (!activeView) {
            log.logError(
              "no active view - could not get selected text."
            );
            return;
          }
          if (!activeView.editor.somethingSelected()) {
            log.logError("no text selected.");
            return;
          }
          return activeView.editor.getSelection();
        }
      },
      date: {
        now: (format3, offset2) => {
          return getDate({ format: format3, offset: offset2 });
        },
        tomorrow: (format3) => {
          return getDate({ format: format3, offset: 1 });
        },
        yesterday: (format3) => {
          return getDate({ format: format3, offset: -1 });
        }
      }
    };
  }
  static async inputPrompt(app2, header, placeholder, value) {
    try {
      return await GenericInputPrompt.Prompt(
        app2,
        header,
        placeholder,
        value
      );
    } catch (e) {
      return void 0;
    }
  }
  static async wideInputPrompt(app2, header, placeholder, value) {
    try {
      return await GenericWideInputPrompt.Prompt(
        app2,
        header,
        placeholder,
        value
      );
    } catch (e) {
      return void 0;
    }
  }
  static async yesNoPrompt(app2, header, text2) {
    try {
      return await GenericYesNoPrompt.Prompt(app2, header, text2);
    } catch (e) {
      return void 0;
    }
  }
  static async suggester(app2, displayItems, actualItems) {
    try {
      let displayedItems;
      if (typeof displayItems === "function") {
        displayedItems = actualItems.map(displayItems);
      } else {
        displayedItems = displayItems;
      }
      return await GenericSuggester.Suggest(
        app2,
        displayedItems,
        actualItems
      );
    } catch (e) {
      return void 0;
    }
  }
  static async checkboxPrompt(app2, items, selectedItems) {
    try {
      return await GenericCheckboxPrompt.Open(app2, items, selectedItems);
    } catch (e) {
      return void 0;
    }
  }
};

// src/engine/QuickAddChoiceEngine.ts
var QuickAddChoiceEngine = class extends QuickAddEngine {
};

// src/types/macros/Command.ts
var Command = class {
  constructor(name, type) {
    this.name = name;
    this.type = type;
    this.id = v4_default();
  }
};

// src/types/macros/EditorCommands/EditorCommand.ts
var import_obsidian13 = require("obsidian");
var EditorCommand = class extends Command {
  constructor(type) {
    super(type, "EditorCommand" /* EditorCommand */);
    this.editorCommandType = type;
  }
  static getSelectedText(app2) {
    return this.getActiveMarkdownView(app2).editor.getSelection();
  }
  static getActiveMarkdownView(app2) {
    const activeView = app2.workspace.getActiveViewOfType(import_obsidian13.MarkdownView);
    if (!activeView) {
      log.logError("no active markdown view.");
      throw new Error("no active markdown view.");
    }
    return activeView;
  }
};

// src/types/macros/EditorCommands/CutCommand.ts
var CutCommand = class extends EditorCommand {
  constructor() {
    super("Cut" /* Cut */);
  }
  static async run(app2) {
    const selectedText = EditorCommand.getSelectedText(app2);
    const activeView = EditorCommand.getActiveMarkdownView(app2);
    if (!selectedText) {
      log.logError("nothing selected.");
      return;
    }
    await navigator.clipboard.writeText(selectedText);
    activeView.editor.replaceSelection("");
  }
};

// src/types/macros/EditorCommands/CopyCommand.ts
var CopyCommand = class extends EditorCommand {
  constructor() {
    super("Copy" /* Copy */);
  }
  static async run(app2) {
    const selectedText = EditorCommand.getSelectedText(app2);
    await navigator.clipboard.writeText(selectedText);
  }
};

// src/types/macros/EditorCommands/PasteCommand.ts
var PasteCommand = class extends EditorCommand {
  constructor() {
    super("Paste" /* Paste */);
  }
  static async run(app2) {
    const clipboard = await navigator.clipboard.readText();
    const activeView = EditorCommand.getActiveMarkdownView(app2);
    if (!activeView) {
      log.logError("no active markdown view.");
      return;
    }
    activeView.editor.replaceSelection(clipboard);
  }
};

// src/types/macros/EditorCommands/SelectActiveLineCommand.ts
var SelectActiveLineCommand = class extends EditorCommand {
  constructor() {
    super("Select active line" /* SelectActiveLine */);
  }
  static run(app2) {
    const activeView = EditorCommand.getActiveMarkdownView(app2);
    const { line: lineNumber } = activeView.editor.getCursor();
    const line = activeView.editor.getLine(lineNumber);
    const lineLength = line.length;
    activeView.editor.setSelection(
      { line: lineNumber, ch: 0 },
      { line: lineNumber, ch: lineLength }
    );
  }
};

// src/types/macros/EditorCommands/SelectLinkOnActiveLineCommand.ts
var SelectLinkOnActiveLineCommand = class extends EditorCommand {
  constructor() {
    super("Select link on active line" /* SelectLinkOnActiveLine */);
  }
  static async run(app2) {
    const activeView = EditorCommand.getActiveMarkdownView(app2);
    const { line: lineNumber } = activeView.editor.getCursor();
    const line = activeView.editor.getLine(lineNumber);
    const match = WIKI_LINK_REGEX.exec(line);
    if (!match) {
      log.logError(`no internal link found on line ${lineNumber}.`);
      return;
    }
    const matchStart = match.index;
    const matchEnd = match[0].length + matchStart;
    activeView.editor.setSelection(
      { line: lineNumber, ch: matchStart },
      { line: lineNumber, ch: matchEnd }
    );
  }
};

// src/engine/MacroChoiceEngine.ts
var MacroChoiceEngine = class extends QuickAddChoiceEngine {
  constructor(app2, plugin, choice, macros, choiceExecutor, variables) {
    super(app2);
    this.choice = choice;
    this.plugin = plugin;
    this.macros = macros;
    this.choiceExecutor = choiceExecutor;
    this.params = {
      app: this.app,
      quickAddApi: QuickAddApi.GetApi(app2, plugin, choiceExecutor),
      variables: {},
      obsidian
    };
    variables == null ? void 0 : variables.forEach((value, key) => {
      this.params.variables[key] = value;
    });
  }
  async run() {
    var _a, _b, _c;
    const macroId = (_c = this.choice.macroId) != null ? _c : (_b = (_a = this.choice) == null ? void 0 : _a.macro) == null ? void 0 : _b.id;
    const macro = this.macros.find((m) => m.id === macroId);
    if (!macro || !(macro == null ? void 0 : macro.commands)) {
      log.logError(
        `No commands in the selected macro. Did you select a macro for '${this.choice.name}'?`
      );
      return;
    }
    await this.executeCommands(macro.commands);
  }
  async executeCommands(commands2) {
    for (const command of commands2) {
      if ((command == null ? void 0 : command.type) === "Obsidian" /* Obsidian */)
        await this.executeObsidianCommand(command);
      if ((command == null ? void 0 : command.type) === "UserScript" /* UserScript */)
        await this.executeUserScript(command);
      if ((command == null ? void 0 : command.type) === "Choice" /* Choice */)
        await this.executeChoice(command);
      if ((command == null ? void 0 : command.type) === "Wait" /* Wait */) {
        const waitCommand = command;
        await waitFor(waitCommand.time);
      }
      if ((command == null ? void 0 : command.type) === "NestedChoice" /* NestedChoice */) {
        await this.executeNestedChoice(command);
      }
      if ((command == null ? void 0 : command.type) === "EditorCommand" /* EditorCommand */) {
        await this.executeEditorCommand(command);
      }
      Object.keys(this.params.variables).forEach((key) => {
        this.choiceExecutor.variables.set(
          key,
          this.params.variables[key]
        );
      });
    }
  }
  async executeUserScript(command) {
    const userScript = await getUserScript(command, this.app);
    if (!userScript) {
      log.logError(`failed to load user script ${command.path}.`);
      return;
    }
    if (userScript.settings) {
      this.userScriptCommand = command;
    }
    await this.userScriptDelegator(userScript);
    if (this.userScriptCommand)
      this.userScriptCommand = null;
  }
  async runScriptWithSettings(userScript, command) {
    if (userScript.entry) {
      await this.onExportIsFunction(userScript.entry, command.settings);
    } else {
      await this.onExportIsFunction(userScript, command.settings);
    }
  }
  async userScriptDelegator(userScript) {
    switch (typeof userScript) {
      case "function":
        if (this.userScriptCommand) {
          await this.runScriptWithSettings(
            userScript,
            this.userScriptCommand
          );
        } else {
          await this.onExportIsFunction(userScript);
        }
        break;
      case "object":
        await this.onExportIsObject(userScript);
        break;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        this.output = userScript.toString();
        break;
      default:
        log.logError(
          `user script in macro for '${this.choice.name}' is invalid`
        );
    }
  }
  async onExportIsFunction(userScript, settings) {
    this.output = await userScript(this.params, settings);
  }
  async onExportIsObject(obj) {
    if (this.userScriptCommand && obj.entry !== null) {
      await this.runScriptWithSettings(obj, this.userScriptCommand);
      return;
    }
    try {
      const keys = Object.keys(obj);
      const selected = await GenericSuggester.Suggest(
        this.app,
        keys,
        keys
      );
      await this.userScriptDelegator(obj[selected]);
    } catch (e) {
      log.logMessage(e);
    }
  }
  executeObsidianCommand(command) {
    this.app.commands.executeCommandById(command.commandId);
  }
  async executeChoice(command) {
    const targetChoice = this.plugin.getChoiceById(
      command.choiceId
    );
    if (!targetChoice) {
      log.logError("choice could not be found.");
      return;
    }
    await this.choiceExecutor.execute(targetChoice);
  }
  async executeNestedChoice(command) {
    const choice = command.choice;
    if (!choice) {
      log.logError(`choice in ${command.name} is invalid`);
      return;
    }
    await this.choiceExecutor.execute(choice);
  }
  async executeEditorCommand(command) {
    switch (command.editorCommandType) {
      case "Cut" /* Cut */:
        await CutCommand.run(this.app);
        break;
      case "Copy" /* Copy */:
        await CopyCommand.run(this.app);
        break;
      case "Paste" /* Paste */:
        await PasteCommand.run(this.app);
        break;
      case "Select active line" /* SelectActiveLine */:
        await SelectActiveLineCommand.run(this.app);
        break;
      case "Select link on active line" /* SelectLinkOnActiveLine */:
        await SelectLinkOnActiveLineCommand.run(this.app);
        break;
    }
  }
};

// src/engine/SingleMacroEngine.ts
var SingleMacroEngine = class extends MacroChoiceEngine {
  constructor(app2, plugin, macros, choiceExecutor, variables) {
    super(app2, plugin, null, macros, choiceExecutor, variables);
  }
  async runAndGetOutput(macroName) {
    const { basename, memberAccess } = getUserScriptMemberAccess(macroName);
    const macro = this.macros.find((macro2) => macro2.name === basename);
    if (!macro) {
      log.logError(`macro '${macroName}' does not exist.`);
      throw new Error(`macro '${macroName}' does not exist.`);
    }
    if (memberAccess && memberAccess.length > 0) {
      this.memberAccess = memberAccess;
    }
    await this.executeCommands(macro.commands);
    return this.output;
  }
  async onExportIsObject(obj) {
    if (!this.memberAccess)
      return await super.onExportIsObject(obj);
    let newObj = obj;
    this.memberAccess.forEach((key) => {
      newObj = newObj[key];
    });
    await this.userScriptDelegator(newObj);
  }
};

// src/formatters/completeFormatter.ts
var import_obsidian16 = require("obsidian");

// src/engine/SingleInlineScriptEngine.ts
var SingleInlineScriptEngine = class extends MacroChoiceEngine {
  constructor(app2, plugin, choiceExecutor, variables) {
    super(app2, plugin, null, null, choiceExecutor, variables);
  }
  async runAndGetOutput(code) {
    const AsyncFunction = Object.getPrototypeOf(
      async function() {
      }
    ).constructor;
    const userCode = new AsyncFunction(code);
    return await userCode.bind(this.params, this).call();
  }
};

// src/gui/MathModal.ts
var import_obsidian15 = require("obsidian");

// src/LaTeXSymbols.ts
var LATEX_CURSOR_MOVE_HERE = "\u261A";
var commands = [
  "\\!",
  "\\,",
  "\\:",
  "\\>",
  "\\;",
  "\\#",
  "\\$",
  "\\%",
  "\\&",
  "\\",
  "_",
  "{ }",
  "|",
  `^{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  `[${LATEX_CURSOR_MOVE_HERE}]${LATEX_CURSOR_MOVE_HERE}`,
  "\\above",
  "\\abovewithdelims",
  "\\acute",
  "\\aleph",
  "\\alpha",
  "\\amalg",
  "\\And",
  "\\angle",
  "\\approx",
  "\\approxeq",
  "\\arccos",
  "\\arcsin",
  "\\arctan",
  "\\arg",
  "\\array",
  "\\arrowvert",
  "\\Arrowvert",
  "\\ast",
  "\\asymp",
  "\\atop",
  "\\atopwithdelims",
  "\\backepsilon",
  "\\backprime",
  "\\backsim",
  "\\backsimeq",
  "\\backslash",
  "\\bar",
  "\\barwedge",
  "\\Bbb",
  "\\Bbbk",
  "\\because",
  "\\begin",
  "\\beta",
  "\\beth",
  "\\between",
  "\\bf",
  "\\Bigg",
  "\\bigg",
  "\\Big",
  "\\big",
  "\\Biggl",
  "\\Biggm",
  "\\Biggr",
  "\\biggl",
  "\\biggm",
  "\\biggr",
  "\\Bigl",
  "\\Bigm",
  "\\Bigl",
  "\\bigl",
  "\\bigm",
  "\\bigr",
  "\\bigcap",
  "\\bigcirc",
  "\\bigcup",
  "\\bigodot",
  "\\bigoplus",
  "\\bigotimes",
  "\\bigsqcup",
  "\\bigstar",
  "\\bigtriangledown",
  "\\bigtriangleup",
  "\\biguplus",
  "\\bigvee",
  "\\bigwedge",
  "\\binom",
  "\\blacklozenge",
  "\\blacksquare",
  "\\blacktriangle",
  "\\blacktriangledown",
  "\\blacktriangleleft",
  "\\blacktriangleright",
  "\\bmod",
  "\\boldsymbol",
  "\\bot",
  "\\bowtie",
  "\\Box",
  "\\boxdot",
  "\\boxed",
  "\\boxminus",
  "\\boxplus",
  "\\boxtimes",
  "\\brace",
  "\\bracevert",
  "\\brack",
  "\\breve",
  "\\bullet",
  "\\Bumpeq",
  "\\bumpeq",
  "\\cal",
  "\\cancel",
  "\\Cap",
  "\\cap",
  "\\cases",
  "\\cdot",
  "\\cdotp",
  "\\cdots",
  "\\centerdot",
  `\\cfrac{${LATEX_CURSOR_MOVE_HERE}}{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  "\\check",
  "\\checkmark",
  "\\chi",
  "\\choose",
  "\\circ",
  "\\circeq",
  "\\circlearrowleft",
  "\\circlearrowright",
  "\\circledast",
  "\\circledcirc",
  "\\circleddash",
  "\\circledR",
  "\\circledS",
  "\\class",
  "\\clubsuit",
  "\\colon",
  "\\color",
  "\\complement",
  "\\cong",
  "\\coprod",
  "\\cos",
  "\\cosh",
  "\\cot",
  "\\coth",
  "\\cr",
  "\\csc",
  "\\cssId",
  "\\Cup",
  "\\cup",
  "\\curlyeqprec",
  "\\curlyeqsucc",
  "\\curlyvee",
  "\\curlywedge",
  "\\curvearrowleft",
  "\\curvearrowright",
  "\\dagger",
  "\\ddagger",
  "\\daleth",
  "\\dashleftarrow",
  "\\dashrightarrow",
  "\\dashv",
  "\\dbinom",
  "\\dot",
  "\\ddot",
  "\\dddot",
  "\\ddddot",
  "\\ddots",
  "\\DeclareMathOperator",
  "\\def",
  "\\deg",
  "\\Delta",
  "\\delta",
  "\\det",
  `\\dfrac{${LATEX_CURSOR_MOVE_HERE}}{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  "\\diagdown",
  "\\diagup",
  "\\Diamond",
  "\\diamond",
  "\\diamondsuit",
  "\\digamma",
  "\\dim",
  "\\displaylines",
  "\\displaystyle",
  "\\div",
  "\\divideontimes",
  "\\Doteq",
  "\\doteq",
  "\\dotplus",
  "\\dots",
  "\\dotsb",
  "\\dotsc",
  "\\dotsi",
  "\\dotsm",
  "\\dotso",
  "\\doublebarwedge",
  "\\doublecap",
  "\\doublecup",
  "\\downarrow",
  "\\Downarrow",
  "\\downdownarrows",
  "\\downharpoonleft",
  "\\downharpoonright",
  "\\ell",
  "\\emptyset",
  "\\end",
  "\\enspace",
  "\\epsilon",
  "\\eqalign",
  "\\eqalignno",
  "\\eqcirc",
  "\\eqsim",
  "\\eqslantgtr",
  "\\eqslantless",
  "\\equiv",
  "\\eta",
  "\\eth",
  "\\exists",
  "\\exp",
  "\\fallingdotseq",
  "\\fbox",
  "\\Finv",
  "\\flat",
  "\\forall",
  `\\frac{${LATEX_CURSOR_MOVE_HERE}}{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  "\\frak",
  "\\frown",
  "\\Game",
  "\\Gamma",
  "\\gamma",
  "\\gcd",
  "\\ge",
  "\\geq",
  "\\geqq",
  "\\geqslant",
  "\\genfrac",
  "\\gets",
  "\\gg",
  "\\ggg",
  "\\gggtr",
  "\\gimel",
  "\\gtrapprox",
  "\\gnapprox",
  "\\gneq",
  "\\gneqq",
  "\\gvertneqq",
  "\\gtrsim",
  "\\gnsim",
  "\\grave",
  "\\gt",
  "\\gtrdot",
  "\\gtreqless",
  "\\gtreqqless",
  "\\gtrless",
  "\\hat",
  "\\hbar",
  "\\hbox",
  "\\hdashline",
  "\\hline",
  "\\heartsuit",
  "\\hfil",
  "\\hfill",
  "\\hom",
  "\\hookleftarrow",
  "\\hookrightarrow",
  "\\hphantom",
  "\\href",
  "\\hskip",
  "\\hslash",
  "\\hspace",
  "\\Huge",
  "\\huge",
  "\\iddots",
  "\\idotsint",
  "\\iff",
  "\\iiiint",
  "\\iiint",
  "\\iint",
  "\\int",
  "\\intop",
  "\\Im",
  "\\imath",
  "\\impliedby",
  "\\implies",
  "\\in",
  "\\inf",
  "\\infty",
  "\\injlim",
  "\\intercal",
  "\\iota",
  "\\it",
  "\\jmath",
  "\\Join",
  "\\kappa",
  "\\ker",
  "\\kern",
  "\\Lambda",
  "\\lambda",
  "\\land",
  "\\langle",
  "\\LARGE",
  "\\Large",
  "\\large",
  "\\LaTeX",
  "\\lbrace",
  "\\lbrack",
  "\\lceil",
  "\\ldotp",
  "\\ldots",
  "\\le",
  "\\leq",
  "\\leqq",
  "\\leqslant",
  "\\leadsto",
  "\\left",
  "\\leftarrow",
  "\\Leftarrow",
  "\\leftarrowtail",
  "\\leftharpoondown",
  "\\leftharpoonup",
  "\\leftleftarrows",
  "\\leftrightarrow",
  "\\Leftrightarrow",
  "\\leftrightarrows",
  "\\leftrightharpoons",
  "\\leftrightsquigarrow",
  "\\leftroot",
  "\\leftthreetimes",
  "\\leqalignno",
  "\\lessapprox",
  "\\lessdot",
  "\\lesseqgtr",
  "\\lesseqqgtr",
  "\\lessgtr",
  "\\lesssim",
  "\\lfloor",
  "\\lg",
  "\\lgroup",
  "\\lhd",
  "\\lim",
  "\\liminf",
  "\\limits",
  "\\limsup",
  "\\ll",
  "\\llap",
  "\\llcorner",
  "\\lrcorner",
  "\\Lleftarrow",
  "\\lll",
  "\\llless",
  "\\lmoustache",
  "\\ln",
  "\\lnapprox",
  "\\lneq",
  "\\lneqq",
  "\\lnot",
  "\\lnsim",
  "\\log",
  "\\longleftarrow",
  "\\Longleftarrow",
  "\\longrightarrow",
  "\\Longrightarrow",
  "\\longleftrightarrow",
  "\\Longleftrightarrow",
  "\\longmapsto",
  "\\looparrowleft",
  "\\looparrowright",
  "\\lor",
  "\\lower",
  "\\lozenge",
  "\\Lsh",
  "\\lt",
  "\\ltimes",
  "\\lvert",
  "\\lVert",
  "\\lvertneqq",
  "\\maltese",
  "\\mapsto",
  "\\mathbb",
  "\\mathbf",
  "\\mathbin",
  "\\mathcal",
  "\\mathchoice",
  "\\mathclose",
  "\\mathfrak",
  "\\mathinner",
  "\\mathit",
  "\\mathop",
  "\\mathopen",
  "\\mathord",
  "\\mathpunct",
  "\\mathrel",
  "\\mathring",
  "\\mathrm",
  "\\mathscr",
  "\\mathsf",
  "\\mathstrut",
  "\\mathtt",
  "\\matrix",
  "\\max",
  "\\mbox",
  "\\measuredangle",
  "\\mho",
  "\\mid",
  "\\min",
  "\\mit",
  "\\mod",
  "\\models",
  "\\moveleft",
  "\\moveright",
  "\\mp",
  "\\mskip",
  "\\mspace",
  "\\mu",
  "\\multimap",
  "\\nabla",
  "\\natural",
  "\\ncong",
  "\\ne",
  "\\nearrow",
  "\\neg",
  "\\negthinspace",
  "\\negmedspace",
  "\\negthickspace",
  "\\neq",
  "\\newcommand",
  "\\newenvironment",
  "\\newline",
  "\\nexists",
  "\\ngeq",
  "\\ngeqq",
  "\\ngeqslant",
  "\\ngtr",
  "\\ni",
  "\\nleftarrow",
  "\\nLeftarrow",
  "\\nleftrightarrow",
  "\\nLeftrightarrow",
  "\\nleq",
  "\\nleqq",
  "\\nleqslant",
  "\\nless",
  "\\nmid",
  "\\nobreakspace",
  "\\nolimits",
  "\\normalsize",
  "\\not",
  "\\notag",
  "\\notin",
  "\\nparallel",
  "\\nprec",
  "\\npreceq",
  "\\nrightarrow",
  "\\nRightarrow",
  "\\nshortmid",
  "\\nshortparallel",
  "\\nsim",
  "\\nsubseteq",
  "\\nsubseteqq",
  "\\nsucc",
  "\\nsucceq",
  "\\nsupseteq",
  "\\nsupseteqq",
  "\\ntriangleleft",
  "\\ntrianglelefteq",
  "\\ntriangleright",
  "\\ntrianglerighteq",
  "\\nu",
  "\\nVDash",
  "\\nVdash",
  "\\nvDash",
  "\\nvdash",
  "\\nwarrow",
  "\\odot",
  "\\ominus",
  "\\oplus",
  "\\oslash",
  "\\otimes",
  "\\oint",
  "\\oldstyle",
  "\\omega",
  "\\Omega",
  "\\omicron",
  "\\operatorname",
  "\\over",
  "\\overbrace",
  "\\overleftarrow",
  "\\overrightarrow",
  "\\overleftrightarrow",
  "\\overline",
  "\\overparen",
  "\\overset",
  "\\overwithdelims",
  "\\owns",
  "\\parallel",
  "\\partial",
  "\\perp",
  "\\phantom",
  "\\phi",
  "\\Phi",
  "\\pi",
  "\\Pi",
  "\\pitchfork",
  "\\pm",
  "\\pmatrix",
  "\\pmb",
  "\\pmod",
  "\\pod",
  "\\Pr",
  "\\prec",
  "\\precapprox",
  "\\precnapprox",
  "\\preccurlyeq",
  "\\preceq",
  "\\precneqq",
  "\\precsim",
  "\\precnsim",
  "\\prime",
  "\\prod",
  "\\projlim",
  "\\propto",
  "\\psi",
  "\\Psi",
  "\\quad",
  "\\qquad",
  "\\raise",
  "\\rangle",
  "\\rbrace",
  "\\rbrack",
  "\\rceil",
  "\\Re",
  "\\renewcommand",
  "\\require (non-standard)",
  "\\restriction",
  "\\rfloor",
  "\\rgroup",
  "\\rhd",
  "\\rho",
  "\\right",
  "\\rightarrow",
  "\\Rightarrow",
  "\\rightarrowtail",
  "\\rightharpoondown",
  "\\rightharpoonup",
  "\\rightleftarrows",
  "\\rightleftharpoons",
  "\\rightrightarrows",
  "\\rightsquigarrow",
  "\\rightthreetimes",
  "\\risingdotseq",
  "\\rlap",
  "\\rm",
  "\\rmoustache",
  "\\Rrightarrow",
  "\\Rsh",
  "\\rtimes",
  "\\Rule (non-standard)",
  "\\rvert",
  "\\rVert",
  "\\S",
  "\\scr",
  "\\scriptscriptstyle",
  "\\scriptsize",
  "\\scriptstyle",
  "\\searrow",
  "\\sec",
  "\\setminus",
  "\\sf",
  "\\sharp",
  "\\shortmid",
  "\\shortparallel",
  "\\shoveleft",
  "\\shoveright",
  "\\sideset",
  "\\sigma",
  "\\Sigma",
  "\\sim",
  "\\simeq",
  "\\sin",
  "\\sinh",
  "\\skew",
  "\\small",
  "\\smallfrown",
  "\\smallint",
  "\\smallsetminus",
  "\\smallsmile",
  "\\smash",
  "\\smile",
  "\\space",
  "\\Space (non-standard)",
  "\\spadesuit",
  "\\sphericalangle",
  "\\sqcap",
  "\\sqcup",
  "\\sqrt",
  "\\sqsubset",
  "\\sqsupset",
  "\\sqsubseteq",
  "\\sqsupseteq",
  "\\square",
  "\\stackrel",
  "\\star",
  "\\strut",
  "\\style",
  "\\subset",
  "\\Subset",
  "\\subseteq",
  "\\subsetneq",
  "\\subseteqq",
  "\\subsetneqq",
  "\\substack",
  "\\succ",
  "\\succapprox",
  "\\succnapprox",
  "\\succcurlyeq",
  "\\succeq",
  "\\succneqq",
  "\\succsim",
  "\\succnsim",
  "\\sum",
  "\\sup",
  "\\supset",
  "\\Supset",
  "\\supseteq",
  "\\supsetneq",
  "\\supseteqq",
  "\\supsetneqq",
  "\\surd",
  "\\swarrow",
  "\\tag",
  "\\tan",
  "\\tanh",
  "\\tau",
  "\\tbinom",
  "\\TeX",
  `\\text{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  `\\textbf{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  `\\textit{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  `\\textrm{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  `\\textsf{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  `\\texttt{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  "\\textstyle",
  `\\tfrac{${LATEX_CURSOR_MOVE_HERE}}{${LATEX_CURSOR_MOVE_HERE}}${LATEX_CURSOR_MOVE_HERE}`,
  "\\therefore",
  "\\theta",
  "\\Theta",
  "\\thickapprox",
  "\\thicksim",
  "\\thinspace",
  "\\tilde",
  "\\times",
  "\\tiny",
  "\\Tiny",
  "\\to",
  "\\top",
  "\\triangle",
  "\\triangledown",
  "\\triangleleft",
  "\\triangleright",
  "\\trianglelefteq",
  "\\trianglerighteq",
  "\\triangleq",
  "\\tt",
  "\\twoheadleftarrow",
  "\\twoheadrightarrow",
  "\\ulcorner",
  "\\urcorner",
  "\\underbrace",
  "\\underleftarrow",
  "\\underrightarrow",
  "\\underleftrightarrow",
  "\\underline",
  "\\underparen",
  "\\underset",
  "\\unicode",
  "\\unlhd",
  "\\unrhd",
  "\\uparrow",
  "\\Uparrow",
  "\\updownarrow",
  "\\Updownarrow",
  "\\upharpoonleft",
  "\\upharpoonright",
  "\\uplus",
  "\\uproot",
  "\\upsilon",
  "\\Upsilon",
  "\\upuparrows",
  "\\varDelta",
  "\\varepsilon",
  "\\varGamma",
  "\\varinjlim",
  "\\varkappa",
  "\\varLambda",
  "\\varlimsup",
  "\\varliminf",
  "\\varnothing",
  "\\varOmega",
  "\\varphi",
  "\\varPhi",
  "\\varpi",
  "\\varPi",
  "\\varprojlim",
  "\\varpropto",
  "\\varPsi",
  "\\varrho",
  "\\varsigma",
  "\\varSigma",
  "\\varsubsetneq",
  "\\varsubsetneqq",
  "\\varsupsetneq",
  "\\varsupsetneqq",
  "\\vartheta",
  "\\varTheta",
  "\\vartriangle",
  "\\vartriangleleft",
  "\\vartriangleright",
  "\\varUpsilon",
  "\\varXi",
  "\\vcenter",
  "\\vdash",
  "\\Vdash",
  "\\vDash",
  "\\vdots",
  "\\vec",
  "\\vee",
  "\\veebar",
  "\\verb",
  "\\vert",
  "\\Vert",
  "\\vphantom",
  "\\Vvdash",
  "\\wedge",
  "\\widehat",
  "\\widetilde",
  "\\wp",
  "\\wr",
  "\\Xi",
  "\\xi",
  "\\xleftarrow",
  "\\xrightarrow",
  "\\yen",
  "\\zeta",
  "\\{%C\\}%C",
  "\\langle %C \\rangle%C"
];
var environments = [
  "align",
  "align*",
  "alignat",
  "alignat*",
  "array",
  "Bmatrix",
  "bmatrix",
  "cases",
  "eqnarray",
  "eqnarray*",
  "equation",
  "equation*",
  "gather",
  "gather*",
  "matrix",
  "pmatrix",
  "smallmatrix",
  "subarray",
  "Vmatrix",
  "vmatrix"
];
function beginEndGen(symbol) {
  return `\\begin{${symbol}}
${LATEX_CURSOR_MOVE_HERE}
\\end{${symbol}}${LATEX_CURSOR_MOVE_HERE}`;
}
var LaTeXSymbols = [...commands, ...environments.map(beginEndGen)];

// src/gui/suggesters/LaTeXSuggester.ts
var import_obsidian14 = require("obsidian");
var LATEX_REGEX = new RegExp(/\\([a-z{}A-Z0-9]*)$/);
var LaTeXSuggester = class extends TextInputSuggest {
  constructor(inputEl) {
    super(QuickAdd.instance.app, inputEl);
    this.inputEl = inputEl;
    this.lastInput = "";
    this.symbols = Object.assign([], LaTeXSymbols);
    this.elementsRendered = this.symbols.reduce((elements, symbol) => {
      try {
        elements[symbol.toString()] = (0, import_obsidian14.renderMath)(symbol, true);
      } catch (e) {
      }
      return elements;
    }, {});
  }
  getSuggestions(inputStr) {
    const cursorPosition = this.inputEl.selectionStart;
    const inputBeforeCursor = inputStr.substr(0, cursorPosition);
    const lastBackslashPos = inputBeforeCursor.lastIndexOf("\\");
    const commandText = inputBeforeCursor.substr(lastBackslashPos);
    const match = LATEX_REGEX.exec(commandText);
    let suggestions = [];
    if (match) {
      this.lastInput = match[1];
      suggestions = this.symbols.filter(
        (val) => val.toLowerCase().contains(this.lastInput)
      );
    }
    const fuse = new Fuse(suggestions, {
      findAllMatches: true,
      threshold: 0.8
    });
    const searchResults = fuse.search(this.lastInput);
    return searchResults.map((value) => value.item);
  }
  renderSuggestion(item, el) {
    if (item) {
      el.setText(item);
      el.append(this.elementsRendered[item]);
    }
  }
  selectSuggestion(item) {
    const cursorPosition = this.inputEl.selectionStart;
    const lastInputLength = this.lastInput.length;
    const currentInputValue = this.inputEl.value;
    let insertedEndPosition = 0;
    const textToInsert = item.replace(/\\\\/g, "\\");
    this.inputEl.value = `${currentInputValue.substr(
      0,
      cursorPosition - lastInputLength - 1
    )}${textToInsert}${currentInputValue.substr(cursorPosition)}`;
    insertedEndPosition = cursorPosition - lastInputLength + item.length - 1;
    this.inputEl.trigger("input");
    this.close();
    if (item.contains(LATEX_CURSOR_MOVE_HERE)) {
      const cursorPos = this.inputEl.value.indexOf(
        LATEX_CURSOR_MOVE_HERE
      );
      this.inputEl.value = this.inputEl.value.replace(
        LATEX_CURSOR_MOVE_HERE,
        ""
      );
      this.inputEl.setSelectionRange(cursorPos, cursorPos);
    } else {
      this.inputEl.setSelectionRange(
        insertedEndPosition,
        insertedEndPosition
      );
    }
  }
};

// src/gui/MathModal.ts
var MathModal = class extends import_obsidian15.Modal {
  constructor() {
    super(QuickAdd.instance.app);
    this.didSubmit = false;
    this.keybindListener = (evt) => {
      if (evt.ctrlKey && evt.key === "Enter") {
        this.submit();
      }
      if (evt.key === "Tab") {
        evt.preventDefault();
        this.cursorToGoTo();
      }
    };
    this.submitClickCallback = (evt) => this.submit();
    this.cancelClickCallback = (evt) => this.cancel();
    this.open();
    this.display();
    this.waitForClose = new Promise((resolve, reject) => {
      this.resolvePromise = resolve;
      this.rejectPromise = reject;
    });
    new LaTeXSuggester(this.inputEl);
    this.inputEl.focus();
    this.inputEl.select();
  }
  static Prompt() {
    return new MathModal().waitForClose;
  }
  display() {
    this.containerEl.addClass("quickAddModal", "qaMathModal");
    this.contentEl.empty();
    const mathDiv = this.contentEl.createDiv();
    mathDiv.className = "math math-block is-loaded";
    const tc = new import_obsidian15.TextAreaComponent(this.contentEl);
    tc.inputEl.style.width = "100%";
    tc.inputEl.style.height = "10rem";
    this.inputEl = tc.inputEl;
    tc.onChange(
      (0, import_obsidian15.debounce)(
        async (value) => await this.mathjaxLoop(mathDiv, value),
        50
      )
    );
    tc.inputEl.addEventListener("keydown", this.keybindListener);
    this.createButtonBar(this.contentEl.createDiv());
  }
  async onOpen() {
    super.onOpen();
    await (0, import_obsidian15.loadMathJax)();
  }
  async mathjaxLoop(container, value) {
    const html = (0, import_obsidian15.renderMath)(value, true);
    await (0, import_obsidian15.finishRenderMath)();
    container.empty();
    container.append(html);
  }
  cursorToGoTo() {
    if (this.inputEl.value.contains(LATEX_CURSOR_MOVE_HERE)) {
      const cursorPos = this.inputEl.value.indexOf(
        LATEX_CURSOR_MOVE_HERE
      );
      this.inputEl.value = this.inputEl.value.replace(
        LATEX_CURSOR_MOVE_HERE,
        ""
      );
      this.inputEl.setSelectionRange(cursorPos, cursorPos);
    }
  }
  createButton(container, text2, callback) {
    const btn = new import_obsidian15.ButtonComponent(container);
    btn.setButtonText(text2).onClick(callback);
    return btn;
  }
  createButtonBar(mainContentContainer) {
    const buttonBarContainer = mainContentContainer.createDiv();
    this.createButton(
      buttonBarContainer,
      "Ok",
      this.submitClickCallback
    ).setCta().buttonEl.style.marginRight = "0";
    this.createButton(
      buttonBarContainer,
      "Cancel",
      this.cancelClickCallback
    );
    buttonBarContainer.style.display = "flex";
    buttonBarContainer.style.flexDirection = "row-reverse";
    buttonBarContainer.style.justifyContent = "flex-start";
    buttonBarContainer.style.marginTop = "1rem";
  }
  removeInputListeners() {
    this.inputEl.removeEventListener("keydown", this.keybindListener);
  }
  resolveInput() {
    const output = this.inputEl.value.replace("\\n", `\\\\n`).replace(new RegExp(LATEX_CURSOR_MOVE_HERE, "g"), "");
    if (!this.didSubmit)
      this.rejectPromise("No input given.");
    else
      this.resolvePromise(output);
  }
  submit() {
    this.didSubmit = true;
    this.close();
  }
  cancel() {
    this.close();
  }
  onClose() {
    super.onClose();
    this.resolveInput();
    this.removeInputListeners();
  }
};

// src/gui/InputPrompt.ts
var InputPrompt = class {
  factory() {
    if (QuickAdd.instance.settings.inputPrompt === "multi-line") {
      return GenericWideInputPrompt;
    } else {
      return GenericInputPrompt;
    }
  }
};

// src/formatters/completeFormatter.ts
var CompleteFormatter = class extends Formatter {
  constructor(app2, plugin, choiceExecutor) {
    super();
    this.app = app2;
    this.plugin = plugin;
    this.choiceExecutor = choiceExecutor;
    this.variables = choiceExecutor == null ? void 0 : choiceExecutor.variables;
  }
  async format(input) {
    let output = input;
    output = await this.replaceInlineJavascriptInString(output);
    output = await this.replaceMacrosInString(output);
    output = await this.replaceTemplateInString(output);
    output = this.replaceDateInString(output);
    output = await this.replaceValueInString(output);
    output = await this.replaceDateVariableInString(output);
    output = await this.replaceVariableInString(output);
    output = await this.replaceMathValueInString(output);
    return output;
  }
  async formatFileName(input, valueHeader) {
    this.valueHeader = valueHeader;
    return await this.format(input);
  }
  async formatFileContent(input) {
    let output = input;
    output = await this.format(output);
    output = await this.replaceLinkToCurrentFileInString(output);
    return output;
  }
  async formatFolderPath(folderName) {
    return await this.format(folderName);
  }
  getCurrentFileLink() {
    const currentFile = this.app.workspace.getActiveFile();
    if (!currentFile)
      return null;
    return this.app.fileManager.generateMarkdownLink(currentFile, "");
  }
  getNaturalLanguageDates() {
    return getNaturalLanguageDates(this.app);
  }
  getVariableValue(variableName) {
    return this.variables.get(variableName);
  }
  async promptForValue(header) {
    var _a;
    if (!this.value) {
      const selectedText = await this.getSelectedText();
      this.value = selectedText ? selectedText : await new InputPrompt().factory().Prompt(this.app, (_a = this.valueHeader) != null ? _a : `Enter value`);
    }
    return this.value;
  }
  async promptForVariable(header) {
    return await new InputPrompt().factory().Prompt(this.app, header);
  }
  async promptForMathValue() {
    return await MathModal.Prompt();
  }
  async suggestForValue(suggestedValues) {
    return await GenericSuggester.Suggest(
      this.app,
      suggestedValues,
      suggestedValues
    );
  }
  async getMacroValue(macroName) {
    var _a;
    const macroEngine = new SingleMacroEngine(
      this.app,
      this.plugin,
      this.plugin.settings.macros,
      this.choiceExecutor,
      this.variables
    );
    const macroOutput = (_a = await macroEngine.runAndGetOutput(macroName)) != null ? _a : "";
    Object.keys(macroEngine.params.variables).forEach((key) => {
      this.variables.set(key, macroEngine.params.variables[key]);
    });
    return macroOutput;
  }
  async getTemplateContent(templatePath) {
    return await new SingleTemplateEngine(
      this.app,
      this.plugin,
      templatePath,
      this.choiceExecutor
    ).run();
  }
  async getSelectedText() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian16.MarkdownView);
    if (!activeView)
      return "";
    return activeView.editor.getSelection();
  }
  async replaceInlineJavascriptInString(input) {
    var _a;
    let output = input;
    while (INLINE_JAVASCRIPT_REGEX.test(output)) {
      const match = INLINE_JAVASCRIPT_REGEX.exec(output);
      const code = (_a = match[1]) == null ? void 0 : _a.trim();
      if (code) {
        const executor = new SingleInlineScriptEngine(
          this.app,
          this.plugin,
          this.choiceExecutor,
          this.variables
        );
        const outVal = await executor.runAndGetOutput(code);
        for (let key in executor.params.variables) {
          this.variables.set(key, executor.params.variables[key]);
        }
        output = typeof outVal === "string" ? this.replacer(output, INLINE_JAVASCRIPT_REGEX, outVal) : this.replacer(output, INLINE_JAVASCRIPT_REGEX, "");
      }
    }
    return output;
  }
};

// src/engine/TemplateEngine.ts
var import_obsidian17 = require("obsidian");
var TemplateEngine = class extends QuickAddEngine {
  constructor(app2, plugin, choiceFormatter) {
    super(app2);
    this.plugin = plugin;
    this.templater = getTemplater(app2);
    this.formatter = new CompleteFormatter(app2, plugin, choiceFormatter);
  }
  async getOrCreateFolder(folders) {
    let folderPath;
    if (folders.length > 1) {
      folderPath = await GenericSuggester.Suggest(
        this.app,
        folders,
        folders
      );
      if (!folderPath)
        throw new Error("No folder selected.");
    } else {
      folderPath = folders[0];
    }
    if (folderPath)
      await this.createFolder(folderPath);
    else
      folderPath = "";
    return folderPath;
  }
  async getFormattedFilePath(folderPath, format3, promptHeader) {
    const formattedName = await this.formatter.formatFileName(
      format3,
      promptHeader
    );
    return this.formatFilePath(folderPath, formattedName);
  }
  async incrementFileName(fileName) {
    const numStr = FILE_NUMBER_REGEX.exec(fileName)[1];
    const fileExists = await this.app.vault.adapter.exists(fileName);
    let newFileName = fileName;
    if (fileExists && numStr) {
      const number = parseInt(numStr);
      if (!number)
        throw new Error("detected numbers but couldn't get them.");
      newFileName = newFileName.replace(
        FILE_NUMBER_REGEX,
        `${number + 1}.md`
      );
    } else if (fileExists) {
      newFileName = newFileName.replace(FILE_NUMBER_REGEX, `${1}.md`);
    }
    const newFileExists = await this.app.vault.adapter.exists(newFileName);
    if (newFileExists)
      newFileName = await this.incrementFileName(newFileName);
    return newFileName;
  }
  async createFileWithTemplate(filePath, templatePath) {
    try {
      const templateContent = await this.getTemplateContent(
        templatePath
      );
      const formattedTemplateContent = await this.formatter.formatFileContent(templateContent);
      const createdFile = await this.createFileWithInput(
        filePath,
        formattedTemplateContent
      );
      await replaceTemplaterTemplatesInCreatedFile(this.app, createdFile);
      return createdFile;
    } catch (e) {
      log.logError(
        `Could not create file with template. Maybe '${templatePath}' is an invalid template path?`
      );
      return null;
    }
  }
  async overwriteFileWithTemplate(file, templatePath) {
    try {
      const templateContent = await this.getTemplateContent(
        templatePath
      );
      const formattedTemplateContent = await this.formatter.formatFileContent(templateContent);
      await this.app.vault.modify(file, formattedTemplateContent);
      await replaceTemplaterTemplatesInCreatedFile(this.app, file, true);
      return file;
    } catch (e) {
      log.logError(e);
      return null;
    }
  }
  async appendToFileWithTemplate(file, templatePath, section) {
    try {
      const templateContent = await this.getTemplateContent(
        templatePath
      );
      const formattedTemplateContent = await this.formatter.formatFileContent(templateContent);
      const fileContent = await this.app.vault.cachedRead(file);
      const newFileContent = section === "top" ? `${formattedTemplateContent}
${fileContent}` : `${fileContent}
${formattedTemplateContent}`;
      await this.app.vault.modify(file, newFileContent);
      await replaceTemplaterTemplatesInCreatedFile(this.app, file, true);
      return file;
    } catch (e) {
      log.logError(e);
      return null;
    }
  }
  async getTemplateContent(templatePath) {
    let correctTemplatePath = templatePath;
    if (!MARKDOWN_FILE_EXTENSION_REGEX.test(templatePath))
      correctTemplatePath += ".md";
    const templateFile = this.app.vault.getAbstractFileByPath(correctTemplatePath);
    if (!(templateFile instanceof import_obsidian17.TFile))
      throw new Error("Template file not found.");
    return await this.app.vault.cachedRead(templateFile);
  }
};

// src/engine/SingleTemplateEngine.ts
var SingleTemplateEngine = class extends TemplateEngine {
  constructor(app2, plugin, templatePath, choiceExecutor) {
    super(app2, plugin, choiceExecutor);
    this.templatePath = templatePath;
  }
  async run() {
    let templateContent = await this.getTemplateContent(
      this.templatePath
    );
    if (!templateContent) {
      log.logError(`Template ${this.templatePath} not found.`);
    }
    templateContent = await this.formatter.formatFileContent(
      templateContent
    );
    return templateContent;
  }
};

// src/formatters/formatDisplayFormatter.ts
var FormatDisplayFormatter = class extends Formatter {
  constructor(app2, plugin) {
    super();
    this.app = app2;
    this.plugin = plugin;
  }
  async format(input) {
    let output = input;
    output = this.replaceDateInString(output);
    output = await this.replaceValueInString(output);
    output = await this.replaceDateVariableInString(output);
    output = await this.replaceVariableInString(output);
    output = await this.replaceLinkToCurrentFileInString(output);
    output = await this.replaceMacrosInString(output);
    output = await this.replaceTemplateInString(output);
    output = this.replaceLinebreakInString(output);
    return output;
  }
  promptForValue(header) {
    return "_value_";
  }
  getVariableValue(variableName) {
    return variableName;
  }
  getCurrentFileLink() {
    var _a, _b;
    return (_b = (_a = this.app.workspace.getActiveFile()) == null ? void 0 : _a.path) != null ? _b : "_noPageOpen_";
  }
  getNaturalLanguageDates() {
    return getNaturalLanguageDates(this.app);
  }
  suggestForValue(suggestedValues) {
    return "_suggest_";
  }
  getMacroValue(macroName) {
    return `_macro: ${macroName}_`;
  }
  promptForMathValue() {
    return Promise.resolve("_math_");
  }
  promptForVariable(variableName) {
    return Promise.resolve(`${variableName}_`);
  }
  async getTemplateContent(templatePath) {
    try {
      return await new SingleTemplateEngine(
        this.app,
        this.plugin,
        templatePath,
        null
      ).run();
    } catch (e) {
      return `Template (not found): ${templatePath}`;
    }
  }
  async getSelectedText() {
    return "_selected_";
  }
};

// src/gui/ChoiceBuilder/captureChoiceBuilder.ts
var CaptureChoiceBuilder = class extends ChoiceBuilder {
  constructor(app2, choice, plugin) {
    super(app2);
    this.plugin = plugin;
    this.choice = choice;
    this.display();
  }
  display() {
    var _a, _b, _c;
    this.containerEl.addClass("captureChoiceBuilder");
    this.contentEl.empty();
    this.addCenteredChoiceNameHeader(this.choice);
    this.addCapturedToSetting();
    if (!((_a = this.choice) == null ? void 0 : _a.captureToActiveFile)) {
      this.addCreateIfNotExistsSetting();
      if ((_c = (_b = this.choice) == null ? void 0 : _b.createFileIfItDoesntExist) == null ? void 0 : _c.enabled)
        this.addCreateWithTemplateSetting();
    }
    this.addTaskSetting();
    this.addPrependSetting();
    if (!this.choice.captureToActiveFile) {
      this.addAppendLinkSetting();
      this.addInsertAfterSetting();
      this.addOpenFileSetting();
      if (this.choice.openFile)
        this.addOpenFileInNewTabSetting();
    }
    this.addFormatSetting();
  }
  addCapturedToSetting() {
    var _a, _b, _c;
    let textField;
    const captureToSetting = new import_obsidian18.Setting(this.contentEl).setName("Capture To").setDesc("File to capture to. Supports some format syntax.");
    const captureToContainer = this.contentEl.createDiv("captureToContainer");
    const captureToActiveFileContainer = captureToContainer.createDiv("captureToActiveFileContainer");
    const captureToActiveFileText = captureToActiveFileContainer.createEl("span");
    captureToActiveFileText.textContent = "Capture to active file";
    const captureToActiveFileToggle = new import_obsidian18.ToggleComponent(
      captureToActiveFileContainer
    );
    captureToActiveFileToggle.setValue((_a = this.choice) == null ? void 0 : _a.captureToActiveFile);
    captureToActiveFileToggle.onChange((value) => {
      this.choice.captureToActiveFile = value;
      this.reload();
    });
    if (!((_b = this.choice) == null ? void 0 : _b.captureToActiveFile)) {
      const captureToFileContainer = captureToContainer.createDiv("captureToFileContainer");
      const formatDisplay = captureToFileContainer.createEl("span");
      const displayFormatter = new FileNameDisplayFormatter(this.app);
      (async () => formatDisplay.textContent = await displayFormatter.format(
        this.choice.captureTo
      ))();
      const formatInput = new import_obsidian18.TextComponent(captureToFileContainer);
      formatInput.setPlaceholder("File name format");
      textField = formatInput;
      formatInput.inputEl.style.width = "100%";
      formatInput.inputEl.style.marginBottom = "8px";
      formatInput.setValue(this.choice.captureTo).setDisabled((_c = this.choice) == null ? void 0 : _c.captureToActiveFile).onChange(async (value) => {
        this.choice.captureTo = value;
        formatDisplay.textContent = await displayFormatter.format(
          value
        );
      });
      const markdownFilesAndFormatSyntax = [
        ...this.app.vault.getMarkdownFiles().map((f) => f.path),
        ...FILE_NAME_FORMAT_SYNTAX
      ];
      new GenericTextSuggester(
        this.app,
        textField.inputEl,
        markdownFilesAndFormatSyntax
      );
    }
  }
  addPrependSetting() {
    var _a;
    const prependSetting = new import_obsidian18.Setting(this.contentEl);
    prependSetting.setName("Write to bottom of file").setDesc(
      `Put value at the bottom of the file - otherwise at the ${((_a = this.choice) == null ? void 0 : _a.captureToActiveFile) ? "active cursor location" : "top"}.`
    ).addToggle((toggle) => {
      toggle.setValue(this.choice.prepend);
      toggle.onChange((value) => this.choice.prepend = value);
    });
  }
  addTaskSetting() {
    const taskSetting = new import_obsidian18.Setting(this.contentEl);
    taskSetting.setName("Task").setDesc("Formats the value as a task.").addToggle((toggle) => {
      toggle.setValue(this.choice.task);
      toggle.onChange((value) => this.choice.task = value);
    });
  }
  addAppendLinkSetting() {
    const appendLinkSetting = new import_obsidian18.Setting(this.contentEl);
    appendLinkSetting.setName("Append link").setDesc(
      "Add a link on your current cursor position, linking to the file you're capturing to."
    ).addToggle((toggle) => {
      toggle.setValue(this.choice.appendLink);
      toggle.onChange((value) => this.choice.appendLink = value);
    });
  }
  addInsertAfterSetting() {
    let insertAfterInput;
    const insertAfterSetting = new import_obsidian18.Setting(this.contentEl);
    insertAfterSetting.setName("Insert after").setDesc(
      "Insert capture after specified line. Accepts format syntax."
    ).addToggle((toggle) => {
      toggle.setValue(this.choice.insertAfter.enabled);
      toggle.onChange((value) => {
        this.choice.insertAfter.enabled = value;
        insertAfterInput.setDisabled(!value);
        this.reload();
      });
    });
    const insertAfterFormatDisplay = this.contentEl.createEl("span");
    const displayFormatter = new FormatDisplayFormatter(this.app, this.plugin);
    (async () => insertAfterFormatDisplay.innerText = await displayFormatter.format(
      this.choice.insertAfter.after
    ))();
    insertAfterInput = new import_obsidian18.TextComponent(this.contentEl);
    insertAfterInput.setPlaceholder("Insert after");
    insertAfterInput.inputEl.style.width = "100%";
    insertAfterInput.inputEl.style.marginBottom = "8px";
    insertAfterInput.setValue(this.choice.insertAfter.after).setDisabled(!this.choice.insertAfter.enabled).onChange(async (value) => {
      this.choice.insertAfter.after = value;
      insertAfterFormatDisplay.innerText = await displayFormatter.format(value);
    });
    new FormatSyntaxSuggester(
      this.app,
      insertAfterInput.inputEl,
      this.plugin
    );
    if (this.choice.insertAfter.enabled) {
      const insertAtEndSetting = new import_obsidian18.Setting(this.contentEl);
      insertAtEndSetting.setName("Insert at end of section").setDesc(
        "Insert the text at the end of the section, rather than at the top."
      ).addToggle(
        (toggle) => {
          var _a;
          return toggle.setValue((_a = this.choice.insertAfter) == null ? void 0 : _a.insertAtEnd).onChange(
            (value) => this.choice.insertAfter.insertAtEnd = value
          );
        }
      );
      const createLineIfNotFound = new import_obsidian18.Setting(this.contentEl);
      createLineIfNotFound.setName("Create line if not found").setDesc("Creates the 'insert after' line if it is not found.").addToggle((toggle) => {
        var _a, _b;
        if (!((_a = this.choice.insertAfter) == null ? void 0 : _a.createIfNotFound))
          this.choice.insertAfter.createIfNotFound = false;
        toggle.setValue((_b = this.choice.insertAfter) == null ? void 0 : _b.createIfNotFound).onChange(
          (value) => this.choice.insertAfter.createIfNotFound = value
        ).toggleEl.style.marginRight = "1em";
      }).addDropdown((dropdown) => {
        var _a, _b;
        if (!((_a = this.choice.insertAfter) == null ? void 0 : _a.createIfNotFoundLocation))
          this.choice.insertAfter.createIfNotFoundLocation = CREATE_IF_NOT_FOUND_TOP;
        dropdown.addOption(CREATE_IF_NOT_FOUND_TOP, "Top").addOption(CREATE_IF_NOT_FOUND_BOTTOM, "Bottom").setValue(
          (_b = this.choice.insertAfter) == null ? void 0 : _b.createIfNotFoundLocation
        ).onChange(
          (value) => this.choice.insertAfter.createIfNotFoundLocation = value
        );
      });
    }
  }
  addFormatSetting() {
    let textField;
    const enableSetting = new import_obsidian18.Setting(this.contentEl);
    enableSetting.setName("Capture format").setDesc("Set the format of the capture.").addToggle((toggleComponent) => {
      toggleComponent.setValue(this.choice.format.enabled).onChange((value) => {
        this.choice.format.enabled = value;
        textField.setDisabled(!value);
      });
    });
    const formatInput = new import_obsidian18.TextAreaComponent(this.contentEl);
    formatInput.setPlaceholder("Format");
    textField = formatInput;
    formatInput.inputEl.style.width = "100%";
    formatInput.inputEl.style.marginBottom = "8px";
    formatInput.inputEl.style.height = "10rem";
    formatInput.setValue(this.choice.format.format).setDisabled(!this.choice.format.enabled).onChange(async (value) => {
      this.choice.format.format = value;
      formatDisplay.innerText = await displayFormatter.format(value);
    });
    new FormatSyntaxSuggester(this.app, textField.inputEl, this.plugin);
    const formatDisplay = this.contentEl.createEl("span");
    const displayFormatter = new FormatDisplayFormatter(this.app, this.plugin);
    (async () => formatDisplay.innerText = await displayFormatter.format(
      this.choice.format.format
    ))();
  }
  addCreateIfNotExistsSetting() {
    if (!this.choice.createFileIfItDoesntExist)
      this.choice.createFileIfItDoesntExist = {
        enabled: false,
        createWithTemplate: false,
        template: ""
      };
    const createFileIfItDoesntExist = new import_obsidian18.Setting(this.contentEl);
    createFileIfItDoesntExist.setName("Create file if it doesn't exist").addToggle(
      (toggle) => {
        var _a, _b;
        return toggle.setValue((_b = (_a = this.choice) == null ? void 0 : _a.createFileIfItDoesntExist) == null ? void 0 : _b.enabled).setTooltip("Create file if it doesn't exist").onChange((value) => {
          this.choice.createFileIfItDoesntExist.enabled = value;
          this.reload();
        });
      }
    );
  }
  addCreateWithTemplateSetting() {
    var _a, _b, _c, _d, _e;
    let templateSelector;
    const createWithTemplateSetting = new import_obsidian18.Setting(this.contentEl);
    createWithTemplateSetting.setName("Create file with given template.").addToggle(
      (toggle) => {
        var _a2;
        return toggle.setValue(
          (_a2 = this.choice.createFileIfItDoesntExist) == null ? void 0 : _a2.createWithTemplate
        ).onChange((value) => {
          this.choice.createFileIfItDoesntExist.createWithTemplate = value;
          templateSelector.setDisabled(!value);
        });
      }
    );
    templateSelector = new import_obsidian18.TextComponent(this.contentEl);
    templateSelector.setValue((_c = (_b = (_a = this.choice) == null ? void 0 : _a.createFileIfItDoesntExist) == null ? void 0 : _b.template) != null ? _c : "").setPlaceholder("Template path").setDisabled(
      !((_e = (_d = this.choice) == null ? void 0 : _d.createFileIfItDoesntExist) == null ? void 0 : _e.createWithTemplate)
    );
    templateSelector.inputEl.style.width = "100%";
    templateSelector.inputEl.style.marginBottom = "8px";
    const markdownFiles = getTemplatePaths(this.app);
    new GenericTextSuggester(
      this.app,
      templateSelector.inputEl,
      markdownFiles
    );
    templateSelector.onChange((value) => {
      this.choice.createFileIfItDoesntExist.template = value;
    });
  }
  addOpenFileSetting() {
    const noOpenSetting = new import_obsidian18.Setting(this.contentEl);
    noOpenSetting.setName("Open").setDesc("Open the file that is captured to.").addToggle((toggle) => {
      toggle.setValue(this.choice.openFile);
      toggle.onChange((value) => {
        this.choice.openFile = value;
        this.reload();
      });
    }).addDropdown((dropdown) => {
      dropdown.selectEl.style.marginLeft = "10px";
      if (!this.choice.openFileInMode)
        this.choice.openFileInMode = "default";
      dropdown.addOption("source", "Source").addOption("preview", "Preview").addOption("default", "Default").setValue(this.choice.openFileInMode).onChange(
        (value) => this.choice.openFileInMode = value
      );
    });
  }
  addOpenFileInNewTabSetting() {
    const newTabSetting = new import_obsidian18.Setting(this.contentEl);
    newTabSetting.setName("New Tab").setDesc("Open the file that is captured to in a new tab.").addToggle((toggle) => {
      var _a, _b;
      toggle.setValue((_b = (_a = this.choice) == null ? void 0 : _a.openFileInNewTab) == null ? void 0 : _b.enabled);
      toggle.onChange(
        (value) => this.choice.openFileInNewTab.enabled = value
      );
    }).addDropdown((dropdown) => {
      var _a, _b, _c;
      if (!((_a = this.choice) == null ? void 0 : _a.openFileInNewTab)) {
        this.choice.openFileInNewTab = {
          enabled: false,
          direction: "vertical" /* vertical */,
          focus: true
        };
      }
      dropdown.selectEl.style.marginLeft = "10px";
      dropdown.addOption("vertical" /* vertical */, "Vertical");
      dropdown.addOption("horizontal" /* horizontal */, "Horizontal");
      dropdown.setValue((_c = (_b = this.choice) == null ? void 0 : _b.openFileInNewTab) == null ? void 0 : _c.direction);
      dropdown.onChange(
        (value) => this.choice.openFileInNewTab.direction = value
      );
    });
    new import_obsidian18.Setting(this.contentEl).setName("Focus new pane").setDesc("Focus the opened tab immediately").addToggle(
      (toggle) => toggle.setValue(this.choice.openFileInNewTab.focus).onChange(
        (value) => this.choice.openFileInNewTab.focus = value
      )
    );
  }
};

// src/gui/ChoiceBuilder/macroChoiceBuilder.ts
var import_obsidian19 = require("obsidian");
var MacroChoiceBuilder = class extends ChoiceBuilder {
  constructor(app2, choice, macros) {
    super(app2);
    this.macros = macros;
    this.choice = choice;
    this.display();
  }
  display() {
    this.containerEl.addClass("macroChoiceBuilder");
    this.addCenteredChoiceNameHeader(this.choice);
    this.addSelectMacroSearch();
  }
  addSelectMacroSearch() {
    const selectMacroDropdownContainer = this.contentEl.createDiv("selectMacroDropdownContainer");
    const dropdown = new import_obsidian19.DropdownComponent(
      selectMacroDropdownContainer
    );
    let macroOptions = {};
    this.macros.forEach((macro) => {
      macroOptions[macro.name] = macro.name;
    });
    dropdown.addOptions(macroOptions);
    dropdown.onChange((value) => {
      this.selectMacro(value);
    });
    const selectedMacro = this.macros.find(
      (m) => m.id === this.choice.macroId
    );
    if (selectedMacro) {
      dropdown.setValue(selectedMacro.name);
    } else {
      const value = dropdown.getValue();
      if (value) {
        this.selectMacro(value);
      }
    }
  }
  selectMacro(value) {
    const targetMacro = this.macros.find((m) => m.name === value);
    if (!targetMacro)
      return;
    this.choice.macroId = targetMacro.id;
  }
};

// src/MacrosManager.ts
var import_obsidian23 = require("obsidian");

// src/gui/MacroGUIs/MacroBuilder.ts
var import_obsidian22 = require("obsidian");

// src/types/macros/UserScript.ts
var UserScript = class extends Command {
  constructor(name, path) {
    super(name, "UserScript" /* UserScript */);
    this.path = path;
    this.settings = {};
  }
};

// src/types/macros/ObsidianCommand.ts
var ObsidianCommand = class extends Command {
  constructor(name, commandId) {
    super(name, "Obsidian" /* Obsidian */);
    this.generateId = () => this.id = v4_default();
    this.commandId = commandId;
  }
};

// src/gui/MacroGUIs/Components/StandardCommand.svelte
function create_fragment12(ctx) {
  let div1;
  let li;
  let t0_value = ctx[0].name + "";
  let t0;
  let t1;
  let div0;
  let span0;
  let icon0;
  let t2;
  let span1;
  let icon1;
  let span1_style_value;
  let span1_tabindex_value;
  let current;
  let mounted;
  let dispose;
  icon0 = new Icon_default({ props: { data: faTrash } });
  icon1 = new Icon_default({ props: { data: faBars } });
  return {
    c() {
      div1 = element("div");
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      span0 = element("span");
      create_component(icon0.$$.fragment);
      t2 = space();
      span1 = element("span");
      create_component(icon1.$$.fragment);
      attr(span0, "class", "clickable");
      attr(span1, "aria-label", "Drag-handle");
      attr(span1, "style", span1_style_value = (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";");
      attr(span1, "tabindex", span1_tabindex_value = ctx[2] ? 0 : -1);
      attr(div1, "class", "quickAddCommandListItem");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, li);
      append(li, t0);
      append(div1, t1);
      append(div1, div0);
      append(div0, span0);
      mount_component(icon0, span0, null);
      append(div0, t2);
      append(div0, span1);
      mount_component(icon1, span1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(span0, "click", ctx[4]),
          listen(span1, "mousedown", function() {
            if (is_function(ctx[1]))
              ctx[1].apply(this, arguments);
          }),
          listen(span1, "touchstart", function() {
            if (is_function(ctx[1]))
              ctx[1].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[0].name + ""))
        set_data(t0, t0_value);
      if (!current || dirty & 4 && span1_style_value !== (span1_style_value = (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";")) {
        attr(span1, "style", span1_style_value);
      }
      if (!current || dirty & 4 && span1_tabindex_value !== (span1_tabindex_value = ctx[2] ? 0 : -1)) {
        attr(span1, "tabindex", span1_tabindex_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(icon0);
      destroy_component(icon1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { command } = $$props;
  let { startDrag } = $$props;
  let { dragDisabled } = $$props;
  const dispatch = createEventDispatcher();
  function deleteCommand(commandId) {
    dispatch("deleteCommand", commandId);
  }
  const click_handler = () => deleteCommand(command.id);
  $$self.$$set = ($$props2) => {
    if ("command" in $$props2)
      $$invalidate(0, command = $$props2.command);
    if ("startDrag" in $$props2)
      $$invalidate(1, startDrag = $$props2.startDrag);
    if ("dragDisabled" in $$props2)
      $$invalidate(2, dragDisabled = $$props2.dragDisabled);
  };
  return [command, startDrag, dragDisabled, deleteCommand, click_handler];
}
var StandardCommand = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance12, create_fragment12, safe_not_equal, {
      command: 0,
      startDrag: 1,
      dragDisabled: 2
    });
  }
};
var StandardCommand_default = StandardCommand;

// src/gui/MacroGUIs/Components/WaitCommand.svelte
function add_css8(target) {
  append_styles(target, "svelte-1196d9p", ".dotInput.svelte-1196d9p{border:none;display:inline;font-family:inherit;font-size:inherit;padding:0;width:0;text-decoration:underline dotted;background-color:transparent}.dotInput.svelte-1196d9p:hover{background-color:transparent}");
}
function create_fragment13(ctx) {
  let div1;
  let li;
  let t0_value = ctx[0].name + "";
  let t0;
  let t1;
  let input;
  let t2;
  let t3;
  let div0;
  let span0;
  let icon0;
  let t4;
  let span1;
  let icon1;
  let span1_style_value;
  let span1_tabindex_value;
  let current;
  let mounted;
  let dispose;
  icon0 = new Icon_default({ props: { data: faTrash } });
  icon1 = new Icon_default({ props: { data: faBars } });
  return {
    c() {
      div1 = element("div");
      li = element("li");
      t0 = text(t0_value);
      t1 = text(" for ");
      input = element("input");
      t2 = text("ms");
      t3 = space();
      div0 = element("div");
      span0 = element("span");
      create_component(icon0.$$.fragment);
      t4 = space();
      span1 = element("span");
      create_component(icon1.$$.fragment);
      attr(input, "type", "number");
      attr(input, "placeholder", "   ");
      attr(input, "class", "dotInput svelte-1196d9p");
      attr(span0, "class", "clickable");
      attr(span1, "aria-label", "Drag-handle");
      attr(span1, "style", span1_style_value = (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";");
      attr(span1, "tabindex", span1_tabindex_value = ctx[2] ? 0 : -1);
      attr(div1, "class", "quickAddCommandListItem");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, li);
      append(li, t0);
      append(li, t1);
      append(li, input);
      ctx[6](input);
      set_input_value(input, ctx[0].time);
      append(li, t2);
      append(div1, t3);
      append(div1, div0);
      append(div0, span0);
      mount_component(icon0, span0, null);
      append(div0, t4);
      append(div0, span1);
      mount_component(icon1, span1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input, "keyup", ctx[5]),
          listen(input, "input", ctx[7]),
          listen(span0, "click", ctx[8]),
          listen(span1, "mousedown", function() {
            if (is_function(ctx[1]))
              ctx[1].apply(this, arguments);
          }),
          listen(span1, "touchstart", function() {
            if (is_function(ctx[1]))
              ctx[1].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[0].name + ""))
        set_data(t0, t0_value);
      if (dirty & 1 && to_number(input.value) !== ctx[0].time) {
        set_input_value(input, ctx[0].time);
      }
      if (!current || dirty & 4 && span1_style_value !== (span1_style_value = (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";")) {
        attr(span1, "style", span1_style_value);
      }
      if (!current || dirty & 4 && span1_tabindex_value !== (span1_tabindex_value = ctx[2] ? 0 : -1)) {
        attr(span1, "tabindex", span1_tabindex_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      ctx[6](null);
      destroy_component(icon0);
      destroy_component(icon1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let { command } = $$props;
  let { startDrag } = $$props;
  let { dragDisabled } = $$props;
  const dispatch = createEventDispatcher();
  let inputEl;
  function deleteCommand(commandId) {
    dispatch("deleteCommand", commandId);
  }
  function resizeInput() {
    const length = inputEl.value.length;
    $$invalidate(3, inputEl.style.width = (length === 0 ? 2 : length) + "ch", inputEl);
  }
  onMount(resizeInput);
  function input_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputEl = $$value;
      $$invalidate(3, inputEl);
    });
  }
  function input_input_handler() {
    command.time = to_number(this.value);
    $$invalidate(0, command);
  }
  const click_handler = () => deleteCommand(command.id);
  $$self.$$set = ($$props2) => {
    if ("command" in $$props2)
      $$invalidate(0, command = $$props2.command);
    if ("startDrag" in $$props2)
      $$invalidate(1, startDrag = $$props2.startDrag);
    if ("dragDisabled" in $$props2)
      $$invalidate(2, dragDisabled = $$props2.dragDisabled);
  };
  return [
    command,
    startDrag,
    dragDisabled,
    inputEl,
    deleteCommand,
    resizeInput,
    input_binding,
    input_input_handler,
    click_handler
  ];
}
var WaitCommand = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance13,
      create_fragment13,
      safe_not_equal,
      {
        command: 0,
        startDrag: 1,
        dragDisabled: 2
      },
      add_css8
    );
  }
};
var WaitCommand_default = WaitCommand;

// src/gui/MacroGUIs/Components/NestedChoiceCommand.svelte
function create_fragment14(ctx) {
  let div1;
  let li;
  let t0_value = ctx[0].name + "";
  let t0;
  let t1;
  let div0;
  let span0;
  let icon0;
  let t2;
  let span1;
  let icon1;
  let t3;
  let span2;
  let icon2;
  let span2_style_value;
  let span2_tabindex_value;
  let current;
  let mounted;
  let dispose;
  icon0 = new Icon_default({ props: { data: faCog } });
  icon1 = new Icon_default({ props: { data: faTrash } });
  icon2 = new Icon_default({ props: { data: faBars } });
  return {
    c() {
      div1 = element("div");
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      span0 = element("span");
      create_component(icon0.$$.fragment);
      t2 = space();
      span1 = element("span");
      create_component(icon1.$$.fragment);
      t3 = space();
      span2 = element("span");
      create_component(icon2.$$.fragment);
      attr(span0, "class", "clickable");
      attr(span1, "class", "clickable");
      attr(span2, "aria-label", "Drag-handle");
      attr(span2, "style", span2_style_value = (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";");
      attr(span2, "tabindex", span2_tabindex_value = ctx[2] ? 0 : -1);
      attr(div1, "class", "quickAddCommandListItem");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, li);
      append(li, t0);
      append(div1, t1);
      append(div1, div0);
      append(div0, span0);
      mount_component(icon0, span0, null);
      append(div0, t2);
      append(div0, span1);
      mount_component(icon1, span1, null);
      append(div0, t3);
      append(div0, span2);
      mount_component(icon2, span2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(span0, "click", ctx[5]),
          listen(span1, "click", ctx[6]),
          listen(span2, "mousedown", function() {
            if (is_function(ctx[1]))
              ctx[1].apply(this, arguments);
          }),
          listen(span2, "touchstart", function() {
            if (is_function(ctx[1]))
              ctx[1].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[0].name + ""))
        set_data(t0, t0_value);
      if (!current || dirty & 4 && span2_style_value !== (span2_style_value = (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";")) {
        attr(span2, "style", span2_style_value);
      }
      if (!current || dirty & 4 && span2_tabindex_value !== (span2_tabindex_value = ctx[2] ? 0 : -1)) {
        attr(span2, "tabindex", span2_tabindex_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      transition_in(icon2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      transition_out(icon2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(icon0);
      destroy_component(icon1);
      destroy_component(icon2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let { command } = $$props;
  let { startDrag } = $$props;
  let { dragDisabled } = $$props;
  const dispatch = createEventDispatcher();
  function deleteCommand() {
    dispatch("deleteCommand", command.id);
  }
  function configureChoice() {
    dispatch("configureChoice", command);
  }
  const click_handler = () => configureChoice();
  const click_handler_1 = () => deleteCommand();
  $$self.$$set = ($$props2) => {
    if ("command" in $$props2)
      $$invalidate(0, command = $$props2.command);
    if ("startDrag" in $$props2)
      $$invalidate(1, startDrag = $$props2.startDrag);
    if ("dragDisabled" in $$props2)
      $$invalidate(2, dragDisabled = $$props2.dragDisabled);
  };
  return [
    command,
    startDrag,
    dragDisabled,
    deleteCommand,
    configureChoice,
    click_handler,
    click_handler_1
  ];
}
var NestedChoiceCommand = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance14, create_fragment14, safe_not_equal, {
      command: 0,
      startDrag: 1,
      dragDisabled: 2
    });
  }
};
var NestedChoiceCommand_default = NestedChoiceCommand;

// src/gui/MacroGUIs/CommandList.svelte
var import_obsidian21 = require("obsidian");

// src/gui/MacroGUIs/Components/UserScriptCommand.svelte
function create_fragment15(ctx) {
  let div1;
  let li;
  let t0_value = ctx[0].name + "";
  let t0;
  let t1;
  let div0;
  let span0;
  let icon0;
  let t2;
  let span1;
  let icon1;
  let t3;
  let span2;
  let icon2;
  let span2_style_value;
  let span2_tabindex_value;
  let current;
  let mounted;
  let dispose;
  icon0 = new Icon_default({ props: { data: faCog } });
  icon1 = new Icon_default({ props: { data: faTrash } });
  icon2 = new Icon_default({ props: { data: faBars } });
  return {
    c() {
      div1 = element("div");
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      span0 = element("span");
      create_component(icon0.$$.fragment);
      t2 = space();
      span1 = element("span");
      create_component(icon1.$$.fragment);
      t3 = space();
      span2 = element("span");
      create_component(icon2.$$.fragment);
      attr(span0, "class", "clickable");
      attr(span1, "class", "clickable");
      attr(span2, "aria-label", "Drag-handle");
      attr(span2, "style", span2_style_value = (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";");
      attr(span2, "tabindex", span2_tabindex_value = ctx[2] ? 0 : -1);
      attr(div1, "class", "quickAddCommandListItem");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, li);
      append(li, t0);
      append(div1, t1);
      append(div1, div0);
      append(div0, span0);
      mount_component(icon0, span0, null);
      append(div0, t2);
      append(div0, span1);
      mount_component(icon1, span1, null);
      append(div0, t3);
      append(div0, span2);
      mount_component(icon2, span2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(span0, "click", ctx[5]),
          listen(span0, "keypress", ctx[6]),
          listen(span1, "click", ctx[7]),
          listen(span1, "keypress", ctx[8]),
          listen(span2, "mousedown", function() {
            if (is_function(ctx[1]))
              ctx[1].apply(this, arguments);
          }),
          listen(span2, "touchstart", function() {
            if (is_function(ctx[1]))
              ctx[1].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if ((!current || dirty & 1) && t0_value !== (t0_value = ctx[0].name + ""))
        set_data(t0, t0_value);
      if (!current || dirty & 4 && span2_style_value !== (span2_style_value = (ctx[2] ? "cursor: grab" : "cursor: grabbing") + ";")) {
        attr(span2, "style", span2_style_value);
      }
      if (!current || dirty & 4 && span2_tabindex_value !== (span2_tabindex_value = ctx[2] ? 0 : -1)) {
        attr(span2, "tabindex", span2_tabindex_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(icon0.$$.fragment, local);
      transition_in(icon1.$$.fragment, local);
      transition_in(icon2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(icon0.$$.fragment, local);
      transition_out(icon1.$$.fragment, local);
      transition_out(icon2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(icon0);
      destroy_component(icon1);
      destroy_component(icon2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  let { command } = $$props;
  let { startDrag } = $$props;
  let { dragDisabled } = $$props;
  const dispatch = createEventDispatcher();
  function deleteCommand() {
    dispatch("deleteCommand", command.id);
  }
  function configureChoice() {
    dispatch("configureScript", command);
  }
  const click_handler = () => configureChoice();
  const keypress_handler = () => configureChoice();
  const click_handler_1 = () => deleteCommand();
  const keypress_handler_1 = () => configureChoice();
  $$self.$$set = ($$props2) => {
    if ("command" in $$props2)
      $$invalidate(0, command = $$props2.command);
    if ("startDrag" in $$props2)
      $$invalidate(1, startDrag = $$props2.startDrag);
    if ("dragDisabled" in $$props2)
      $$invalidate(2, dragDisabled = $$props2.dragDisabled);
  };
  return [
    command,
    startDrag,
    dragDisabled,
    deleteCommand,
    configureChoice,
    click_handler,
    keypress_handler,
    click_handler_1,
    keypress_handler_1
  ];
}
var UserScriptCommand = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance15, create_fragment15, safe_not_equal, {
      command: 0,
      startDrag: 1,
      dragDisabled: 2
    });
  }
};
var UserScriptCommand_default = UserScriptCommand;

// src/gui/MacroGUIs/UserScriptSettingsModal.ts
var import_obsidian20 = require("obsidian");
var UserScriptSettingsModal = class extends import_obsidian20.Modal {
  constructor(app2, command, settings) {
    super(app2);
    this.command = command;
    this.settings = settings;
    this.display();
    if (!this.command.settings)
      this.command.settings = {};
    Object.keys(this.settings.options).forEach((setting) => {
      var _a;
      if (this.command.settings[setting] === void 0) {
        this.command.settings[setting] = (_a = this.settings.options[setting]) == null ? void 0 : _a.defaultValue;
      }
    });
  }
  display() {
    var _a, _b, _c;
    this.containerEl.addClass("quickAddModal", "userScriptSettingsModal");
    this.contentEl.empty();
    this.titleEl.innerText = `${(_a = this.settings) == null ? void 0 : _a.name}${((_b = this.settings) == null ? void 0 : _b.author) ? " by " + ((_c = this.settings) == null ? void 0 : _c.author) : ""}`;
    const options = this.settings.options;
    Object.keys(options).forEach((option) => {
      var _a2, _b2;
      const entry = options[option];
      let value = entry.defaultValue;
      if (this.command.settings[option] !== void 0) {
        value = this.command.settings[option];
      }
      switch ((_b2 = (_a2 = options[option]) == null ? void 0 : _a2.type) == null ? void 0 : _b2.toLowerCase()) {
        case "text":
        case "input":
          this.addInputBox(
            option,
            value,
            entry == null ? void 0 : entry.placeholder,
            entry == null ? void 0 : entry.secret
          );
          break;
        case "checkbox":
        case "toggle":
          this.addToggle(option, value);
          break;
        case "dropdown":
        case "select":
          this.addDropdown(option, entry.options, value);
          break;
        case "format":
          this.addFormatInput(option, value, entry == null ? void 0 : entry.placeholder);
          break;
        default:
          break;
      }
    });
  }
  setPasswordOnBlur(el) {
    el.addEventListener("focus", () => {
      el.type = "text";
    });
    el.addEventListener("blur", () => {
      el.type = "password";
    });
    el.type = "password";
  }
  addInputBox(name, value, placeholder, passwordOnBlur) {
    new import_obsidian20.Setting(this.contentEl).setName(name).addText((input) => {
      input.setValue(value).onChange((value2) => this.command.settings[name] = value2).setPlaceholder(placeholder != null ? placeholder : "");
      if (passwordOnBlur) {
        this.setPasswordOnBlur(input.inputEl);
      }
    });
  }
  addToggle(name, value) {
    new import_obsidian20.Setting(this.contentEl).setName(name).addToggle(
      (toggle) => toggle.setValue(value).onChange((value2) => this.command.settings[name] = value2)
    );
  }
  addDropdown(name, options, value) {
    new import_obsidian20.Setting(this.contentEl).setName(name).addDropdown((dropdown) => {
      options.forEach((item) => dropdown.addOption(item, item));
      dropdown.setValue(value);
      dropdown.onChange((value2) => this.command.settings[name] = value2);
    });
  }
  addFormatInput(name, value, placeholder) {
    new import_obsidian20.Setting(this.contentEl).setName(name);
    const formatDisplay = this.contentEl.createEl("span");
    const input = new import_obsidian20.TextComponent(this.contentEl);
    new FormatSyntaxSuggester(this.app, input.inputEl, QuickAdd.instance);
    const displayFormatter = new FormatDisplayFormatter(
      this.app,
      QuickAdd.instance
    );
    input.setValue(value).onChange(async (value2) => {
      this.command.settings[name] = value2;
      formatDisplay.innerText = await displayFormatter.format(value2);
    }).setPlaceholder(placeholder != null ? placeholder : "");
    input.inputEl.style.width = "100%";
    input.inputEl.style.marginBottom = "1em";
    (async () => formatDisplay.innerText = await displayFormatter.format(value))();
  }
};

// src/gui/MacroGUIs/CommandList.svelte
function add_css9(target) {
  append_styles(target, "svelte-1ukgrgp", ".quickAddCommandList.svelte-1ukgrgp{display:grid;grid-template-columns:auto;width:auto;border:0 solid black;overflow-y:auto;height:auto;margin-bottom:8px;padding:20px}");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[33] = list[i];
  child_ctx[34] = list;
  child_ctx[35] = i;
  return child_ctx;
}
function create_else_block2(ctx) {
  let standardcommand;
  let updating_command;
  let updating_dragDisabled;
  let updating_startDrag;
  let current;
  function standardcommand_command_binding(value) {
    ctx[27](value, ctx[33], ctx[34], ctx[35]);
  }
  function standardcommand_dragDisabled_binding(value) {
    ctx[28](value);
  }
  function standardcommand_startDrag_binding(value) {
    ctx[29](value);
  }
  let standardcommand_props = {};
  if (ctx[33] !== void 0) {
    standardcommand_props.command = ctx[33];
  }
  if (ctx[3] !== void 0) {
    standardcommand_props.dragDisabled = ctx[3];
  }
  if (ctx[4] !== void 0) {
    standardcommand_props.startDrag = ctx[4];
  }
  standardcommand = new StandardCommand_default({ props: standardcommand_props });
  binding_callbacks.push(() => bind(standardcommand, "command", standardcommand_command_binding));
  binding_callbacks.push(() => bind(standardcommand, "dragDisabled", standardcommand_dragDisabled_binding));
  binding_callbacks.push(() => bind(standardcommand, "startDrag", standardcommand_startDrag_binding));
  standardcommand.$on("deleteCommand", ctx[30]);
  standardcommand.$on("updateCommand", ctx[7]);
  return {
    c() {
      create_component(standardcommand.$$.fragment);
    },
    m(target, anchor) {
      mount_component(standardcommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const standardcommand_changes = {};
      if (!updating_command && dirty[0] & 5) {
        updating_command = true;
        standardcommand_changes.command = ctx[33];
        add_flush_callback(() => updating_command = false);
      }
      if (!updating_dragDisabled && dirty[0] & 8) {
        updating_dragDisabled = true;
        standardcommand_changes.dragDisabled = ctx[3];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      if (!updating_startDrag && dirty[0] & 16) {
        updating_startDrag = true;
        standardcommand_changes.startDrag = ctx[4];
        add_flush_callback(() => updating_startDrag = false);
      }
      standardcommand.$set(standardcommand_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(standardcommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(standardcommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(standardcommand, detaching);
    }
  };
}
function create_if_block_22(ctx) {
  let userscriptcommand;
  let updating_command;
  let updating_dragDisabled;
  let updating_startDrag;
  let current;
  function userscriptcommand_command_binding(value) {
    ctx[23](value, ctx[33], ctx[34], ctx[35]);
  }
  function userscriptcommand_dragDisabled_binding(value) {
    ctx[24](value);
  }
  function userscriptcommand_startDrag_binding(value) {
    ctx[25](value);
  }
  let userscriptcommand_props = {};
  if (ctx[33] !== void 0) {
    userscriptcommand_props.command = ctx[33];
  }
  if (ctx[3] !== void 0) {
    userscriptcommand_props.dragDisabled = ctx[3];
  }
  if (ctx[4] !== void 0) {
    userscriptcommand_props.startDrag = ctx[4];
  }
  userscriptcommand = new UserScriptCommand_default({ props: userscriptcommand_props });
  binding_callbacks.push(() => bind(userscriptcommand, "command", userscriptcommand_command_binding));
  binding_callbacks.push(() => bind(userscriptcommand, "dragDisabled", userscriptcommand_dragDisabled_binding));
  binding_callbacks.push(() => bind(userscriptcommand, "startDrag", userscriptcommand_startDrag_binding));
  userscriptcommand.$on("deleteCommand", ctx[26]);
  userscriptcommand.$on("updateCommand", ctx[7]);
  userscriptcommand.$on("configureScript", ctx[9]);
  return {
    c() {
      create_component(userscriptcommand.$$.fragment);
    },
    m(target, anchor) {
      mount_component(userscriptcommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const userscriptcommand_changes = {};
      if (!updating_command && dirty[0] & 5) {
        updating_command = true;
        userscriptcommand_changes.command = ctx[33];
        add_flush_callback(() => updating_command = false);
      }
      if (!updating_dragDisabled && dirty[0] & 8) {
        updating_dragDisabled = true;
        userscriptcommand_changes.dragDisabled = ctx[3];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      if (!updating_startDrag && dirty[0] & 16) {
        updating_startDrag = true;
        userscriptcommand_changes.startDrag = ctx[4];
        add_flush_callback(() => updating_startDrag = false);
      }
      userscriptcommand.$set(userscriptcommand_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(userscriptcommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(userscriptcommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(userscriptcommand, detaching);
    }
  };
}
function create_if_block_14(ctx) {
  let nestedchoicecommand;
  let updating_command;
  let updating_dragDisabled;
  let updating_startDrag;
  let current;
  function nestedchoicecommand_command_binding(value) {
    ctx[19](value, ctx[33], ctx[34], ctx[35]);
  }
  function nestedchoicecommand_dragDisabled_binding(value) {
    ctx[20](value);
  }
  function nestedchoicecommand_startDrag_binding(value) {
    ctx[21](value);
  }
  let nestedchoicecommand_props = {};
  if (ctx[33] !== void 0) {
    nestedchoicecommand_props.command = ctx[33];
  }
  if (ctx[3] !== void 0) {
    nestedchoicecommand_props.dragDisabled = ctx[3];
  }
  if (ctx[4] !== void 0) {
    nestedchoicecommand_props.startDrag = ctx[4];
  }
  nestedchoicecommand = new NestedChoiceCommand_default({ props: nestedchoicecommand_props });
  binding_callbacks.push(() => bind(nestedchoicecommand, "command", nestedchoicecommand_command_binding));
  binding_callbacks.push(() => bind(nestedchoicecommand, "dragDisabled", nestedchoicecommand_dragDisabled_binding));
  binding_callbacks.push(() => bind(nestedchoicecommand, "startDrag", nestedchoicecommand_startDrag_binding));
  nestedchoicecommand.$on("deleteCommand", ctx[22]);
  nestedchoicecommand.$on("updateCommand", ctx[7]);
  nestedchoicecommand.$on("configureChoice", ctx[8]);
  return {
    c() {
      create_component(nestedchoicecommand.$$.fragment);
    },
    m(target, anchor) {
      mount_component(nestedchoicecommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const nestedchoicecommand_changes = {};
      if (!updating_command && dirty[0] & 5) {
        updating_command = true;
        nestedchoicecommand_changes.command = ctx[33];
        add_flush_callback(() => updating_command = false);
      }
      if (!updating_dragDisabled && dirty[0] & 8) {
        updating_dragDisabled = true;
        nestedchoicecommand_changes.dragDisabled = ctx[3];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      if (!updating_startDrag && dirty[0] & 16) {
        updating_startDrag = true;
        nestedchoicecommand_changes.startDrag = ctx[4];
        add_flush_callback(() => updating_startDrag = false);
      }
      nestedchoicecommand.$set(nestedchoicecommand_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(nestedchoicecommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(nestedchoicecommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(nestedchoicecommand, detaching);
    }
  };
}
function create_if_block5(ctx) {
  let waitcommand;
  let updating_command;
  let updating_dragDisabled;
  let updating_startDrag;
  let current;
  function waitcommand_command_binding(value) {
    ctx[15](value, ctx[33], ctx[34], ctx[35]);
  }
  function waitcommand_dragDisabled_binding(value) {
    ctx[16](value);
  }
  function waitcommand_startDrag_binding(value) {
    ctx[17](value);
  }
  let waitcommand_props = {};
  if (ctx[33] !== void 0) {
    waitcommand_props.command = ctx[33];
  }
  if (ctx[3] !== void 0) {
    waitcommand_props.dragDisabled = ctx[3];
  }
  if (ctx[4] !== void 0) {
    waitcommand_props.startDrag = ctx[4];
  }
  waitcommand = new WaitCommand_default({ props: waitcommand_props });
  binding_callbacks.push(() => bind(waitcommand, "command", waitcommand_command_binding));
  binding_callbacks.push(() => bind(waitcommand, "dragDisabled", waitcommand_dragDisabled_binding));
  binding_callbacks.push(() => bind(waitcommand, "startDrag", waitcommand_startDrag_binding));
  waitcommand.$on("deleteCommand", ctx[18]);
  waitcommand.$on("updateCommand", ctx[7]);
  return {
    c() {
      create_component(waitcommand.$$.fragment);
    },
    m(target, anchor) {
      mount_component(waitcommand, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const waitcommand_changes = {};
      if (!updating_command && dirty[0] & 5) {
        updating_command = true;
        waitcommand_changes.command = ctx[33];
        add_flush_callback(() => updating_command = false);
      }
      if (!updating_dragDisabled && dirty[0] & 8) {
        updating_dragDisabled = true;
        waitcommand_changes.dragDisabled = ctx[3];
        add_flush_callback(() => updating_dragDisabled = false);
      }
      if (!updating_startDrag && dirty[0] & 16) {
        updating_startDrag = true;
        waitcommand_changes.startDrag = ctx[4];
        add_flush_callback(() => updating_startDrag = false);
      }
      waitcommand.$set(waitcommand_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(waitcommand.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(waitcommand.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(waitcommand, detaching);
    }
  };
}
function create_each_block4(key_1, ctx) {
  let first;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block5, create_if_block_14, create_if_block_22, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[33].type === "Wait" /* Wait */)
      return 0;
    if (ctx2[33].type === "NestedChoice" /* NestedChoice */)
      return 1;
    if (ctx2[33].type === "UserScript" /* UserScript */)
      return 2;
    return 3;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function create_fragment16(ctx) {
  let ol;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let dndzone_action;
  let current;
  let mounted;
  let dispose;
  let each_value = ctx[0].filter(ctx[14]);
  const get_key = (ctx2) => ctx2[33].id;
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context4(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block4(key, child_ctx));
  }
  return {
    c() {
      ol = element("ol");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(ol, "class", "quickAddCommandList svelte-1ukgrgp");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(ol, null);
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(dndzone_action = dndzone3.call(null, ol, {
            items: ctx[0],
            dragDisabled: ctx[3],
            dropTargetStyle: {},
            type: "command"
          })),
          listen(ol, "consider", ctx[5]),
          listen(ol, "finalize", ctx[6])
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & 927) {
        each_value = ctx2[0].filter(ctx2[14]);
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ol, outro_and_destroy_block, create_each_block4, null, get_each_context4);
        check_outros();
      }
      if (dndzone_action && is_function(dndzone_action.update) && dirty[0] & 9)
        dndzone_action.update.call(null, {
          items: ctx2[0],
          dragDisabled: ctx2[3],
          dropTargetStyle: {},
          type: "command"
        });
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ol);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance16($$self, $$props, $$invalidate) {
  let { commands: commands2 } = $$props;
  let { deleteCommand } = $$props;
  let { saveCommands } = $$props;
  let { app: app2 } = $$props;
  let { plugin } = $$props;
  let dragDisabled = true;
  const updateCommandList = (newCommands) => {
    $$invalidate(0, commands2 = newCommands);
  };
  function handleConsider(e) {
    let { items: newItems } = e.detail;
    $$invalidate(0, commands2 = newItems);
  }
  function handleSort(e) {
    let { items: newItems, info: { source } } = e.detail;
    $$invalidate(0, commands2 = newItems);
    if (source === SOURCES.POINTER) {
      $$invalidate(3, dragDisabled = true);
    }
    saveCommands(commands2);
  }
  let startDrag = (e) => {
    e.preventDefault();
    $$invalidate(3, dragDisabled = false);
  };
  function updateCommandFromEvent(e) {
    const command = e.detail;
    updateCommand(command);
  }
  function updateCommand(command) {
    const index = commands2.findIndex((c) => c.id === command.id);
    $$invalidate(0, commands2[index] = command, commands2);
    saveCommands(commands2);
  }
  function configureChoice(e) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      const command = e.detail;
      const newChoice = yield (_a = getChoiceBuilder(command.choice)) === null || _a === void 0 ? void 0 : _a.waitForClose;
      if (!newChoice)
        return;
      command.choice = newChoice;
      command.name = newChoice.name;
      updateCommand(command);
    });
  }
  function getChoiceBuilder(choice) {
    switch (choice.type) {
      case "Template" /* Template */:
        return new TemplateChoiceBuilder(app2, choice, plugin);
      case "Capture" /* Capture */:
        return new CaptureChoiceBuilder(app2, choice, plugin);
      case "Macro" /* Macro */:
      case "Multi" /* Multi */:
      default:
        break;
    }
  }
  function configureScript(e) {
    return __awaiter(this, void 0, void 0, function* () {
      const command = e.detail;
      const userScript = yield getUserScript(command, app2);
      if (!(userScript === null || userScript === void 0 ? void 0 : userScript.settings)) {
        log.logWarning(`${command.name} has no settings.`);
        return;
      }
      new UserScriptSettingsModal(app2, command, userScript.settings).open();
    });
  }
  const func = (c) => c.id !== SHADOW_PLACEHOLDER_ITEM_ID;
  function waitcommand_command_binding(value, command, each_value, command_index) {
    each_value[command_index] = value;
    $$invalidate(0, commands2);
  }
  function waitcommand_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(3, dragDisabled);
  }
  function waitcommand_startDrag_binding(value) {
    startDrag = value;
    $$invalidate(4, startDrag);
  }
  const deleteCommand_handler = async (e) => await deleteCommand(e.detail);
  function nestedchoicecommand_command_binding(value, command, each_value, command_index) {
    each_value[command_index] = value;
    $$invalidate(0, commands2);
  }
  function nestedchoicecommand_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(3, dragDisabled);
  }
  function nestedchoicecommand_startDrag_binding(value) {
    startDrag = value;
    $$invalidate(4, startDrag);
  }
  const deleteCommand_handler_1 = async (e) => await deleteCommand(e.detail);
  function userscriptcommand_command_binding(value, command, each_value, command_index) {
    each_value[command_index] = value;
    $$invalidate(0, commands2);
  }
  function userscriptcommand_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(3, dragDisabled);
  }
  function userscriptcommand_startDrag_binding(value) {
    startDrag = value;
    $$invalidate(4, startDrag);
  }
  const deleteCommand_handler_2 = async (e) => await deleteCommand(e.detail);
  function standardcommand_command_binding(value, command, each_value, command_index) {
    each_value[command_index] = value;
    $$invalidate(0, commands2);
  }
  function standardcommand_dragDisabled_binding(value) {
    dragDisabled = value;
    $$invalidate(3, dragDisabled);
  }
  function standardcommand_startDrag_binding(value) {
    startDrag = value;
    $$invalidate(4, startDrag);
  }
  const deleteCommand_handler_3 = async (e) => await deleteCommand(e.detail);
  $$self.$$set = ($$props2) => {
    if ("commands" in $$props2)
      $$invalidate(0, commands2 = $$props2.commands);
    if ("deleteCommand" in $$props2)
      $$invalidate(1, deleteCommand = $$props2.deleteCommand);
    if ("saveCommands" in $$props2)
      $$invalidate(10, saveCommands = $$props2.saveCommands);
    if ("app" in $$props2)
      $$invalidate(11, app2 = $$props2.app);
    if ("plugin" in $$props2)
      $$invalidate(12, plugin = $$props2.plugin);
  };
  return [
    commands2,
    deleteCommand,
    SHADOW_PLACEHOLDER_ITEM_ID,
    dragDisabled,
    startDrag,
    handleConsider,
    handleSort,
    updateCommandFromEvent,
    configureChoice,
    configureScript,
    saveCommands,
    app2,
    plugin,
    updateCommandList,
    func,
    waitcommand_command_binding,
    waitcommand_dragDisabled_binding,
    waitcommand_startDrag_binding,
    deleteCommand_handler,
    nestedchoicecommand_command_binding,
    nestedchoicecommand_dragDisabled_binding,
    nestedchoicecommand_startDrag_binding,
    deleteCommand_handler_1,
    userscriptcommand_command_binding,
    userscriptcommand_dragDisabled_binding,
    userscriptcommand_startDrag_binding,
    deleteCommand_handler_2,
    standardcommand_command_binding,
    standardcommand_dragDisabled_binding,
    standardcommand_startDrag_binding,
    deleteCommand_handler_3
  ];
}
var CommandList = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance16,
      create_fragment16,
      safe_not_equal,
      {
        commands: 0,
        deleteCommand: 1,
        saveCommands: 10,
        app: 11,
        plugin: 12,
        updateCommandList: 13
      },
      add_css9,
      [-1, -1]
    );
  }
  get updateCommandList() {
    return this.$$.ctx[13];
  }
};
var CommandList_default = CommandList;

// src/types/macros/ChoiceCommand.ts
var ChoiceCommand = class extends Command {
  constructor(name, choiceId) {
    super(name, "Choice" /* Choice */);
    this.choiceId = choiceId;
  }
};

// src/types/macros/QuickCommands/WaitCommand.ts
var WaitCommand2 = class extends Command {
  constructor(time) {
    super("Wait", "Wait" /* Wait */);
    this.time = time;
  }
};

// src/types/macros/QuickCommands/NestedChoiceCommand.ts
var NestedChoiceCommand2 = class extends Command {
  constructor(choice) {
    super(choice.name, "NestedChoice" /* NestedChoice */);
    this.choice = choice;
  }
};

// src/gui/MacroGUIs/MacroBuilder.ts
var MacroBuilder = class extends import_obsidian22.Modal {
  constructor(app2, plugin, macro, choices) {
    super(app2);
    this.commands = [];
    this.javascriptFiles = [];
    this.choices = [];
    this.macro = macro;
    this.svelteElements = [];
    this.choices = choices;
    this.plugin = plugin;
    this.waitForClose = new Promise(
      (resolve) => this.resolvePromise = resolve
    );
    this.getObsidianCommands();
    this.getJavascriptFiles();
    this.display();
    this.open();
  }
  onClose() {
    super.onClose();
    this.resolvePromise(this.macro);
    this.svelteElements.forEach((el) => {
      if (el && el.$destroy)
        el.$destroy();
    });
  }
  display() {
    this.containerEl.addClass("quickAddModal", "macroBuilder");
    this.contentEl.empty();
    this.addCenteredHeader(this.macro.name);
    this.addCommandList();
    this.addCommandBar();
    this.addAddObsidianCommandSetting();
    this.addAddEditorCommandsSetting();
    this.addAddUserScriptSetting();
    this.addAddChoiceSetting();
  }
  addCenteredHeader(header) {
    const headerEl = this.contentEl.createEl("h2");
    headerEl.style.textAlign = "center";
    headerEl.setText(header);
    headerEl.addClass("clickable");
    headerEl.addEventListener("click", async () => {
      const newMacroName = await GenericInputPrompt.Prompt(
        this.app,
        `Update name for ${this.macro.name}`,
        this.macro.name
      );
      if (!newMacroName)
        return;
      this.macro.name = newMacroName;
      this.reload();
    });
  }
  reload() {
    this.display();
  }
  addAddObsidianCommandSetting() {
    let input;
    const addObsidianCommandFromInput = () => {
      const value = input.getValue();
      const obsidianCommand = this.commands.find(
        (v) => v.name === value
      );
      const command = new ObsidianCommand(
        obsidianCommand.name,
        obsidianCommand.commandId
      );
      command.generateId();
      this.addCommandToMacro(command);
      input.setValue("");
    };
    new import_obsidian22.Setting(this.contentEl).setName("Obsidian command").setDesc("Add an Obsidian command").addText((textComponent) => {
      input = textComponent;
      textComponent.inputEl.style.marginRight = "1em";
      textComponent.setPlaceholder("Obsidian command");
      new GenericTextSuggester(
        this.app,
        textComponent.inputEl,
        this.commands.map((c) => c.name)
      );
      textComponent.inputEl.addEventListener(
        "keypress",
        (e) => {
          if (e.key === "Enter") {
            addObsidianCommandFromInput();
          }
        }
      );
    }).addButton(
      (button) => button.setCta().setButtonText("Add").onClick(addObsidianCommandFromInput)
    );
  }
  addAddEditorCommandsSetting() {
    let dropdownComponent;
    const addEditorCommandFromDropdown = () => {
      const type = dropdownComponent.getValue();
      let command;
      switch (type) {
        case "Copy" /* Copy */:
          command = new CopyCommand();
          break;
        case "Cut" /* Cut */:
          command = new CutCommand();
          break;
        case "Paste" /* Paste */:
          command = new PasteCommand();
          break;
        case "Select active line" /* SelectActiveLine */:
          command = new SelectActiveLineCommand();
          break;
        case "Select link on active line" /* SelectLinkOnActiveLine */:
          command = new SelectLinkOnActiveLineCommand();
          break;
        default:
          log.logError("invalid editor command type");
      }
      this.addCommandToMacro(command);
    };
    new import_obsidian22.Setting(this.contentEl).setName("Editor commands").setDesc("Add editor command").addDropdown((dropdown) => {
      dropdownComponent = dropdown;
      dropdown.selectEl.style.marginRight = "1em";
      dropdown.addOption("Copy" /* Copy */, "Copy" /* Copy */).addOption("Cut" /* Cut */, "Cut" /* Cut */).addOption("Paste" /* Paste */, "Paste" /* Paste */).addOption(
        "Select active line" /* SelectActiveLine */,
        "Select active line" /* SelectActiveLine */
      ).addOption(
        "Select link on active line" /* SelectLinkOnActiveLine */,
        "Select link on active line" /* SelectLinkOnActiveLine */
      );
    }).addButton(
      (button) => button.setCta().setButtonText("Add").onClick(addEditorCommandFromDropdown)
    );
  }
  addAddUserScriptSetting() {
    let input;
    const addUserScriptFromInput = () => {
      const value = input.getValue();
      const scriptBasename = getUserScriptMemberAccess(value).basename;
      const file = this.javascriptFiles.find(
        (f) => f.basename === scriptBasename
      );
      if (!file)
        return;
      this.addCommandToMacro(new UserScript(value, file.path));
      input.setValue("");
    };
    new import_obsidian22.Setting(this.contentEl).setName("User Scripts").setDesc("Add user script").addText((textComponent) => {
      input = textComponent;
      textComponent.inputEl.style.marginRight = "1em";
      textComponent.setPlaceholder("User script");
      new GenericTextSuggester(
        this.app,
        textComponent.inputEl,
        this.javascriptFiles.map((f) => f.basename)
      );
      textComponent.inputEl.addEventListener(
        "keypress",
        (e) => {
          if (e.key === "Enter") {
            addUserScriptFromInput();
          }
        }
      );
    }).addButton(
      (button) => button.setButtonText("Add").setCta().onClick(addUserScriptFromInput)
    );
  }
  addAddChoiceSetting() {
    let input;
    const addChoiceFromInput = () => {
      const value = input.getValue();
      const choice = this.choices.find((c) => c.name === value);
      if (!choice)
        return;
      this.addCommandToMacro(new ChoiceCommand(choice.name, choice.id));
      input.setValue("");
    };
    new import_obsidian22.Setting(this.contentEl).setName("Choices").setDesc("Add existing choice").addText((textComponent) => {
      input = textComponent;
      textComponent.inputEl.style.marginRight = "1em";
      textComponent.setPlaceholder("Choice");
      new GenericTextSuggester(
        this.app,
        textComponent.inputEl,
        this.choices.map((c) => c.name)
      );
      textComponent.inputEl.addEventListener(
        "keypress",
        (e) => {
          if (e.key === "Enter") {
            addChoiceFromInput();
          }
        }
      );
    }).addButton(
      (button) => button.setCta().setButtonText("Add").onClick(addChoiceFromInput)
    );
  }
  getObsidianCommands() {
    Object.keys(this.app.commands.commands).forEach((key) => {
      const command = this.app.commands.commands[key];
      this.commands.push(new ObsidianCommand(command.name, command.id));
    });
  }
  getJavascriptFiles() {
    this.javascriptFiles = this.app.vault.getFiles().filter((file) => JAVASCRIPT_FILE_EXTENSION_REGEX.test(file.path));
  }
  addCommandList() {
    const commandList = this.contentEl.createDiv("commandList");
    console.log(this.macro.commands);
    this.commandListEl = new CommandList_default({
      target: commandList,
      props: {
        app: this.app,
        plugin: this.plugin,
        commands: this.macro.commands,
        deleteCommand: async (commandId) => {
          const command = this.macro.commands.find(
            (c) => c.id === commandId
          );
          const promptAnswer = await GenericYesNoPrompt.Prompt(
            this.app,
            "Are you sure you wish to delete this command?",
            `If you click yes, you will delete '${command.name}'.`
          );
          if (!promptAnswer)
            return;
          this.macro.commands = this.macro.commands.filter(
            (c) => c.id !== commandId
          );
          this.commandListEl.updateCommandList(this.macro.commands);
        },
        saveCommands: (commands2) => {
          this.macro.commands = commands2;
        }
      }
    });
    this.svelteElements.push(this.commandListEl);
  }
  addCommandBar() {
    const quickCommandContainer = this.contentEl.createDiv(
      "quickCommandContainer"
    );
    this.newChoiceButton(quickCommandContainer, "Capture", CaptureChoice);
    this.newChoiceButton(quickCommandContainer, "Template", TemplateChoice);
    this.addAddWaitCommandButton(quickCommandContainer);
  }
  addAddWaitCommandButton(quickCommandContainer) {
    const button = new import_obsidian22.ButtonComponent(
      quickCommandContainer
    );
    button.setIcon("clock").setTooltip("Add wait command").onClick(() => {
      this.addCommandToMacro(new WaitCommand2(100));
    });
  }
  newChoiceButton(container, typeName, type) {
    const button = new import_obsidian22.ButtonComponent(container);
    button.setButtonText(typeName).setTooltip(`Add ${typeName} Choice`).onClick(() => {
      const captureChoice = new type(
        `Untitled ${typeName} Choice`
      );
      this.addCommandToMacro(new NestedChoiceCommand2(captureChoice));
    });
  }
  addCommandToMacro(command) {
    this.macro.commands.push(command);
    this.commandListEl.updateCommandList(this.macro.commands);
  }
};

// src/types/macros/QuickAddMacro.ts
var QuickAddMacro = class {
  constructor(name) {
    this.name = name;
    this.id = v4_default();
    this.commands = [];
    this.runOnStartup = false;
  }
};

// src/MacrosManager.ts
var MacrosManager = class extends import_obsidian23.Modal {
  constructor(app2, plugin, macros, choices) {
    super(app2);
    this.app = app2;
    this.macros = macros;
    this.choices = choices;
    this.plugin = plugin;
    this.waitForClose = new Promise((resolve, reject) => {
      this.rejectPromise = reject;
      this.resolvePromise = resolve;
    });
    this.open();
    this.display();
  }
  display() {
    this.contentEl.createEl("h2", {
      text: "Macro Manager"
    }).style.textAlign = "center";
    this.addMacroSettings();
    this.addAddMacroBar();
  }
  addMacroSettings() {
    this.macroContainer = this.contentEl.createDiv();
    this.updateMacroContainer = () => {
      if (this.macros.length <= 1)
        this.macroContainer.className = "macroContainer macroContainer1";
      if (this.macros.length === 2)
        this.macroContainer.className = "macroContainer macroContainer2";
      if (this.macros.length > 2)
        this.macroContainer.className = "macroContainer macroContainer3";
    };
    this.macros.forEach(
      (macro) => this.addMacroSetting(macro, this.macroContainer)
    );
    this.updateMacroContainer();
  }
  addMacroSetting(macro, container) {
    const configureMacroContainer = container.createDiv();
    const macroSetting = new import_obsidian23.Setting(configureMacroContainer);
    macroSetting.setName(macro.name);
    macroSetting.infoEl.style.fontWeight = "bold";
    this.addMacroConfigurationItem(
      configureMacroContainer,
      (itemContainerEl) => {
        this.addSpanWithText(itemContainerEl, "Run on plugin load");
        const toggle = new import_obsidian23.ToggleComponent(
          itemContainerEl
        );
        toggle.setValue(macro.runOnStartup);
        toggle.onChange((value) => {
          macro.runOnStartup = value;
          this.updateMacro(macro);
        });
      }
    );
    configureMacroContainer.addClass("configureMacroDiv");
    this.addMacroConfigurationItem(
      configureMacroContainer,
      (itemContainerEl) => {
        const deleteButton = new import_obsidian23.ButtonComponent(
          itemContainerEl
        );
        deleteButton.setClass("mod-warning");
        deleteButton.buttonEl.style.marginRight = "0";
        deleteButton.setButtonText("Delete").onClick((evt) => {
          this.macros = this.macros.filter((m) => m.id !== macro.id);
          const scroll = this.macroContainer.scrollTop;
          this.reload();
          this.macroContainer.scrollTop = scroll;
        });
        const configureButton = new import_obsidian23.ButtonComponent(
          itemContainerEl
        );
        configureButton.setClass("mod-cta");
        configureButton.buttonEl.style.marginRight = "0";
        configureButton.setButtonText("Configure").onClick(async (evt) => {
          const getReachableChoices = (choices) => {
            let reachableChoices2 = [];
            choices.forEach((choice) => {
              if (choice.type === "Multi" /* Multi */)
                reachableChoices2.push(
                  ...getReachableChoices(
                    choice.choices
                  )
                );
              if (choice.type !== "Multi" /* Multi */)
                reachableChoices2.push(choice);
            });
            return reachableChoices2;
          };
          const reachableChoices = getReachableChoices(
            this.choices
          );
          const newMacro = await new MacroBuilder(
            this.app,
            this.plugin,
            macro,
            reachableChoices
          ).waitForClose;
          if (newMacro) {
            this.updateMacro(newMacro);
            this.reload();
          }
        });
      }
    );
  }
  addMacroConfigurationItem(container, callback, classString = "configureMacroDivItem") {
    const item = container.createDiv();
    item.addClass(classString);
    callback(item);
  }
  addSpanWithText(container, text2) {
    const configureText = container.createEl("span");
    configureText.setText(text2);
  }
  updateMacro(macro) {
    const index = this.macros.findIndex((v) => v.id === macro.id);
    this.macros[index] = macro;
    if (this.updateMacroContainer)
      this.updateMacroContainer();
    this.reload();
  }
  reload() {
    this.contentEl.empty();
    this.display();
  }
  addAddMacroBar() {
    const addMacroBarContainer = this.contentEl.createDiv();
    addMacroBarContainer.addClass("addMacroBarContainer");
    const nameInput = new import_obsidian23.TextComponent(
      addMacroBarContainer
    );
    nameInput.setPlaceholder("Macro name");
    const addMacroButton = new import_obsidian23.ButtonComponent(
      addMacroBarContainer
    );
    addMacroButton.setButtonText("Add macro").setClass("mod-cta").onClick(() => {
      const inputValue = nameInput.getValue();
      if (inputValue !== "" && !this.macros.find((m) => m.name === inputValue)) {
        const macro = new QuickAddMacro(inputValue);
        if (!macro) {
          log.logError("macro invalid - will not be added");
          return;
        }
        this.macros.push(macro);
        this.reload();
        this.macroContainer.scrollTo(
          0,
          this.macroContainer.scrollHeight
        );
      }
    });
  }
  onClose() {
    super.onClose();
    this.resolvePromise(this.macros);
  }
};

// src/gui/choiceList/ChoiceView.svelte
function add_css10(target) {
  append_styles(target, "svelte-wcmtyt", ".choiceViewBottomBar.svelte-wcmtyt{display:flex;flex-direction:row;align-items:center;justify-content:space-between;margin-top:1rem}@media(max-width: 800px){.choiceViewBottomBar.svelte-wcmtyt{flex-direction:column}}");
}
function create_fragment17(ctx) {
  let div1;
  let choicelist;
  let updating_choices;
  let t0;
  let div0;
  let button;
  let t2;
  let addchoicebox;
  let current;
  let mounted;
  let dispose;
  function choicelist_choices_binding(value) {
    ctx[12](value);
  }
  let choicelist_props = { type: "main" };
  if (ctx[0] !== void 0) {
    choicelist_props.choices = ctx[0];
  }
  choicelist = new ChoiceList_default({ props: choicelist_props });
  binding_callbacks.push(() => bind(choicelist, "choices", choicelist_choices_binding));
  choicelist.$on("deleteChoice", ctx[3]);
  choicelist.$on("configureChoice", ctx[4]);
  choicelist.$on("toggleCommand", ctx[5]);
  choicelist.$on("duplicateChoice", ctx[6]);
  choicelist.$on("reorderChoices", ctx[13]);
  addchoicebox = new AddChoiceBox_default({});
  addchoicebox.$on("addChoice", ctx[2]);
  return {
    c() {
      div1 = element("div");
      create_component(choicelist.$$.fragment);
      t0 = space();
      div0 = element("div");
      button = element("button");
      button.textContent = "Manage Macros";
      t2 = space();
      create_component(addchoicebox.$$.fragment);
      attr(button, "class", "mod-cta");
      attr(div0, "class", "choiceViewBottomBar svelte-wcmtyt");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(choicelist, div1, null);
      append(div1, t0);
      append(div1, div0);
      append(div0, button);
      append(div0, t2);
      mount_component(addchoicebox, div0, null);
      current = true;
      if (!mounted) {
        dispose = listen(button, "click", ctx[7]);
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const choicelist_changes = {};
      if (!updating_choices && dirty & 1) {
        updating_choices = true;
        choicelist_changes.choices = ctx2[0];
        add_flush_callback(() => updating_choices = false);
      }
      choicelist.$set(choicelist_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(choicelist.$$.fragment, local);
      transition_in(addchoicebox.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(choicelist.$$.fragment, local);
      transition_out(addchoicebox.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(choicelist);
      destroy_component(addchoicebox);
      mounted = false;
      dispose();
    }
  };
}
function instance17($$self, $$props, $$invalidate) {
  let { choices = [] } = $$props;
  let { macros = [] } = $$props;
  let { saveChoices } = $$props;
  let { saveMacros } = $$props;
  let { app: app2 } = $$props;
  let { plugin } = $$props;
  function addChoiceToList(event) {
    const { name, type } = event.detail;
    switch (type) {
      case "Template" /* Template */:
        const templateChoice = new TemplateChoice(name);
        $$invalidate(0, choices = [...choices, templateChoice]);
        break;
      case "Capture" /* Capture */:
        const captureChoice = new CaptureChoice(name);
        $$invalidate(0, choices = [...choices, captureChoice]);
        break;
      case "Macro" /* Macro */:
        const macroChoice = new MacroChoice(name);
        $$invalidate(0, choices = [...choices, macroChoice]);
        break;
      case "Multi" /* Multi */:
        const multiChoice = new MultiChoice(name);
        $$invalidate(0, choices = [...choices, multiChoice]);
        break;
    }
    saveChoices(choices);
  }
  function deleteChoice(e) {
    return __awaiter(this, void 0, void 0, function* () {
      const choice = e.detail.choice;
      const userConfirmed = yield GenericYesNoPrompt.Prompt(app2, `Confirm deletion of choice`, `Please confirm that you wish to delete '${choice.name}'.
            ${choice.type === "Multi" /* Multi */ ? "Deleting this choice will delete all (" + choice.choices.length + ") choices inside it!" : ""}
            `);
      if (userConfirmed) {
        $$invalidate(0, choices = choices.filter((value) => deleteChoiceHelper(choice.id, value)));
        plugin.removeCommandForChoice(choice);
        saveChoices(choices);
      }
    });
  }
  function deleteChoiceHelper(id, value) {
    if (value.type === "Multi" /* Multi */) {
      value.choices = value.choices.filter((v) => deleteChoiceHelper(id, v));
    }
    return value.id !== id;
  }
  function configureChoice(e) {
    return __awaiter(this, void 0, void 0, function* () {
      const { choice: oldChoice } = e.detail;
      let updatedChoice;
      if (oldChoice.type === "Multi" /* Multi */) {
        updatedChoice = oldChoice;
        const name = yield GenericInputPrompt.Prompt(app2, `Rename ${oldChoice.name}`, "", oldChoice.name);
        if (!name)
          return;
        updatedChoice.name = name;
      } else {
        updatedChoice = yield getChoiceBuilder(oldChoice).waitForClose;
      }
      if (!updatedChoice)
        return;
      $$invalidate(0, choices = choices.map((choice) => updateChoiceHelper(choice, updatedChoice)));
      saveChoices(choices);
    });
  }
  function toggleCommandForChoice(e) {
    return __awaiter(this, void 0, void 0, function* () {
      const { choice: oldChoice } = e.detail;
      const updatedChoice = Object.assign(Object.assign({}, oldChoice), { command: !oldChoice.command });
      updatedChoice.command ? plugin.addCommandForChoice(updatedChoice) : plugin.removeCommandForChoice(updatedChoice);
      $$invalidate(0, choices = choices.map((choice) => updateChoiceHelper(choice, updatedChoice)));
      saveChoices(choices);
    });
  }
  function handleDuplicateChoice(e) {
    return __awaiter(this, void 0, void 0, function* () {
      const { choice: sourceChoice } = e.detail;
      const newChoice = duplicateChoice(sourceChoice);
      $$invalidate(0, choices = [...choices, newChoice]);
      saveChoices(choices);
    });
  }
  function duplicateChoice(choice) {
    if (!getChoiceType(choice))
      throw new Error("Invalid choice type");
    let newChoice;
    switch (choice.type) {
      case "Template" /* Template */:
        newChoice = new TemplateChoice(`${choice.name} (copy)`);
        break;
      case "Capture" /* Capture */:
        newChoice = new CaptureChoice(`${choice.name} (copy)`);
        break;
      case "Macro" /* Macro */:
        newChoice = new MacroChoice(`${choice.name} (copy)`);
        break;
      case "Multi" /* Multi */:
        newChoice = new MultiChoice(`${choice.name} (copy)`);
        break;
    }
    if (choice.type !== "Multi" /* Multi */) {
      Object.assign(newChoice, excludeKeys(choice, ["id", "name"]));
    } else {
      newChoice.choices = choice.choices.map((c) => duplicateChoice(c));
    }
    return newChoice;
  }
  function updateChoiceHelper(oldChoice, newChoice) {
    if (oldChoice.id === newChoice.id) {
      oldChoice = Object.assign(Object.assign({}, oldChoice), newChoice);
      return oldChoice;
    }
    if (oldChoice.type === "Multi" /* Multi */) {
      const multiChoice = oldChoice;
      const multiChoiceChoices = multiChoice.choices.map((c) => updateChoiceHelper(c, newChoice));
      return Object.assign(Object.assign({}, multiChoice), { choices: multiChoiceChoices });
    }
    return oldChoice;
  }
  function getChoiceBuilder(choice) {
    switch (choice.type) {
      case "Template" /* Template */:
        return new TemplateChoiceBuilder(app2, choice, plugin);
      case "Capture" /* Capture */:
        return new CaptureChoiceBuilder(app2, choice, plugin);
      case "Macro" /* Macro */:
        return new MacroChoiceBuilder(app2, choice, macros);
      case "Multi" /* Multi */:
      default:
        break;
    }
  }
  function openMacroManager() {
    return __awaiter(this, void 0, void 0, function* () {
      const newMacros = yield new MacrosManager(app2, plugin, macros, choices).waitForClose;
      if (newMacros) {
        saveMacros(newMacros);
        $$invalidate(8, macros = newMacros);
      }
    });
  }
  function choicelist_choices_binding(value) {
    choices = value;
    $$invalidate(0, choices);
  }
  const reorderChoices_handler = (e) => saveChoices(e.detail.choices);
  $$self.$$set = ($$props2) => {
    if ("choices" in $$props2)
      $$invalidate(0, choices = $$props2.choices);
    if ("macros" in $$props2)
      $$invalidate(8, macros = $$props2.macros);
    if ("saveChoices" in $$props2)
      $$invalidate(1, saveChoices = $$props2.saveChoices);
    if ("saveMacros" in $$props2)
      $$invalidate(9, saveMacros = $$props2.saveMacros);
    if ("app" in $$props2)
      $$invalidate(10, app2 = $$props2.app);
    if ("plugin" in $$props2)
      $$invalidate(11, plugin = $$props2.plugin);
  };
  return [
    choices,
    saveChoices,
    addChoiceToList,
    deleteChoice,
    configureChoice,
    toggleCommandForChoice,
    handleDuplicateChoice,
    openMacroManager,
    macros,
    saveMacros,
    app2,
    plugin,
    choicelist_choices_binding,
    reorderChoices_handler
  ];
}
var ChoiceView = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance17,
      create_fragment17,
      safe_not_equal,
      {
        choices: 0,
        macros: 8,
        saveChoices: 1,
        saveMacros: 9,
        app: 10,
        plugin: 11
      },
      add_css10
    );
  }
};
var ChoiceView_default = ChoiceView;

// src/quickAddSettingsTab.ts
var DEFAULT_SETTINGS = {
  choices: [],
  macros: [],
  inputPrompt: "single-line",
  devMode: false
};
var QuickAddSettingsTab = class extends import_obsidian25.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "QuickAdd Settings" });
    this.addChoicesSetting();
    new import_obsidian25.Setting(this.containerEl).setName("Use Multi-line Input Prompt").setDesc(
      "Use multi-line input prompt instead of single-line input prompt"
    ).addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.inputPrompt === "multi-line").setTooltip("Use multi-line input prompt").onChange((value) => {
        if (value) {
          this.plugin.settings.inputPrompt = "multi-line";
        } else {
          this.plugin.settings.inputPrompt = "single-line";
        }
        this.plugin.saveSettings();
      })
    );
  }
  hide() {
    if (this.choiceView)
      this.choiceView.$destroy();
  }
  addChoicesSetting() {
    const setting = new import_obsidian25.Setting(this.containerEl);
    setting.infoEl.remove();
    setting.settingEl.style.display = "block";
    this.choiceView = new ChoiceView_default({
      target: setting.settingEl,
      props: {
        app: this.app,
        plugin: this.plugin,
        choices: this.plugin.settings.choices,
        saveChoices: async (choices) => {
          this.plugin.settings.choices = choices;
          await this.plugin.saveSettings();
        },
        macros: this.plugin.settings.macros,
        saveMacros: async (macros) => {
          this.plugin.settings.macros = macros;
          await this.plugin.saveSettings();
        }
      }
    });
  }
};

// src/logger/quickAddLogger.ts
var QuickAddLogger = class {
  formatOutputString(error) {
    return `QuickAdd: (${error.level}) ${error.message}`;
  }
  getQuickAddError(message, level) {
    return { message, level, time: Date.now() };
  }
};

// src/logger/consoleErrorLogger.ts
var ConsoleErrorLogger = class extends QuickAddLogger {
  constructor() {
    super(...arguments);
    this.ErrorLog = [];
  }
  logError(errorMsg) {
    const error = this.getQuickAddError(errorMsg, "ERROR" /* Error */);
    this.addMessageToErrorLog(error);
    console.error(this.formatOutputString(error));
  }
  logWarning(warningMsg) {
    const warning = this.getQuickAddError(warningMsg, "WARNING" /* Warning */);
    this.addMessageToErrorLog(warning);
    console.warn(this.formatOutputString(warning));
  }
  logMessage(logMsg) {
    const log2 = this.getQuickAddError(logMsg, "LOG" /* Log */);
    this.addMessageToErrorLog(log2);
    console.log(this.formatOutputString(log2));
  }
  addMessageToErrorLog(error) {
    this.ErrorLog.push(error);
  }
};

// src/logger/guiLogger.ts
var import_obsidian26 = require("obsidian");
var GuiLogger = class extends QuickAddLogger {
  constructor(plugin) {
    super();
    this.plugin = plugin;
  }
  logError(msg) {
    const error = this.getQuickAddError(msg, "ERROR" /* Error */);
    new import_obsidian26.Notice(this.formatOutputString(error));
  }
  logWarning(msg) {
    const warning = this.getQuickAddError(msg, "WARNING" /* Warning */);
    new import_obsidian26.Notice(this.formatOutputString(warning));
  }
  logMessage(msg) {
  }
};

// src/engine/StartupMacroEngine.ts
var StartupMacroEngine = class extends MacroChoiceEngine {
  constructor(app2, plugin, macros, choiceExecutor) {
    super(app2, plugin, null, macros, choiceExecutor, null);
  }
  async run() {
    this.macros.forEach((macro) => {
      if (macro.runOnStartup) {
        this.executeCommands(macro.commands);
      }
    });
  }
};

// src/engine/TemplateChoiceEngine.ts
var import_obsidian27 = require("obsidian");
var TemplateChoiceEngine = class extends TemplateEngine {
  constructor(app2, plugin, choice, choiceExecutor) {
    super(app2, plugin, choiceExecutor);
    this.choice = choice;
  }
  async run() {
    let folderPath = "";
    if (this.choice.folder.enabled) {
      folderPath = await this.getFolderPath();
    }
    let filePath;
    if (this.choice.fileNameFormat.enabled) {
      filePath = await this.getFormattedFilePath(
        folderPath,
        this.choice.fileNameFormat.format,
        this.choice.name
      );
    } else {
      filePath = await this.getFormattedFilePath(
        folderPath,
        VALUE_SYNTAX,
        this.choice.name
      );
    }
    if (this.choice.incrementFileName)
      filePath = await this.incrementFileName(filePath);
    let createdFile;
    if (await this.app.vault.adapter.exists(filePath)) {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!(file instanceof import_obsidian27.TFile) || file.extension !== "md") {
        log.logError(
          `'${filePath}' already exists and is not a valid markdown file.`
        );
        return;
      }
      await this.app.workspace.getLeaf("tab").openFile(file);
      const userChoice = await GenericSuggester.Suggest(
        this.app,
        fileExistsChoices,
        fileExistsChoices
      );
      switch (userChoice) {
        case fileExistsAppendToTop:
          createdFile = await this.appendToFileWithTemplate(
            file,
            this.choice.templatePath,
            "top"
          );
          break;
        case fileExistsAppendToBottom:
          createdFile = await this.appendToFileWithTemplate(
            file,
            this.choice.templatePath,
            "bottom"
          );
          break;
        case fileExistsOverwriteFile:
          createdFile = await this.overwriteFileWithTemplate(
            file,
            this.choice.templatePath
          );
          break;
        case fileExistsDoNothing:
        default:
          log.logWarning("File not written to.");
          return;
      }
    } else {
      createdFile = await this.createFileWithTemplate(
        filePath,
        this.choice.templatePath
      );
      if (!createdFile) {
        log.logWarning(`Could not create file '${filePath}'.`);
        return;
      }
    }
    if (this.choice.appendLink) {
      appendToCurrentLine(
        this.app.fileManager.generateMarkdownLink(createdFile, ""),
        this.app
      );
    }
    if (this.choice.openFile) {
      await openFile(this.app, createdFile, {
        openInNewTab: this.choice.openFileInNewTab.enabled,
        direction: this.choice.openFileInNewTab.direction,
        focus: this.choice.openFileInNewTab.focus,
        mode: this.choice.openFileInMode
      });
    }
  }
  async formatFolderPaths(folders) {
    const folderPaths = await Promise.all(
      folders.map(async (folder) => {
        return await this.formatter.formatFolderPath(folder);
      })
    );
    return folderPaths;
  }
  async getFolderPath() {
    var _a, _b, _c, _d, _e;
    let folders = await this.formatFolderPaths([
      ...this.choice.folder.folders
    ]);
    if (((_a = this.choice.folder) == null ? void 0 : _a.chooseFromSubfolders) && !(((_b = this.choice.folder) == null ? void 0 : _b.chooseWhenCreatingNote) || ((_c = this.choice.folder) == null ? void 0 : _c.createInSameFolderAsActiveFile))) {
      const allFoldersInVault = getAllFolderPathsInVault(
        this.app
      );
      const subfolders = allFoldersInVault.filter((folder) => {
        return folders.some((f) => folder.startsWith(f));
      });
      return await this.getOrCreateFolder(subfolders);
    }
    if ((_d = this.choice.folder) == null ? void 0 : _d.chooseWhenCreatingNote) {
      const allFoldersInVault = getAllFolderPathsInVault(
        this.app
      );
      return await this.getOrCreateFolder(allFoldersInVault);
    }
    if ((_e = this.choice.folder) == null ? void 0 : _e.createInSameFolderAsActiveFile) {
      const activeFile = this.app.workspace.getActiveFile();
      if (!activeFile) {
        log.logWarning(
          "No active file. Cannot create file in same folder as active file. Creating in root folder."
        );
        return "";
      }
      return this.getOrCreateFolder([activeFile.parent.path]);
    }
    return await this.getOrCreateFolder(folders);
  }
};

// src/formatters/captureChoiceFormatter.ts
var CaptureChoiceFormatter = class extends CompleteFormatter {
  constructor(app2, plugin, choiceExecutor) {
    super(app2, plugin, choiceExecutor);
    this.file = null;
    this.fileContent = "";
  }
  async formatContentWithFile(input, choice, fileContent, file) {
    this.choice = choice;
    this.file = file;
    this.fileContent = fileContent;
    if (!choice || !file || fileContent === null)
      return input;
    const formatted = await this.formatFileContent(input);
    const templaterFormatted = templaterParseTemplate(
      this.app,
      formatted,
      this.file
    );
    if (!templaterFormatted)
      return formatted;
    return templaterFormatted;
  }
  async formatContent(input, choice) {
    this.choice = choice;
    if (!choice)
      return input;
    return await this.formatFileContent(input);
  }
  async formatFileContent(input) {
    let formatted = await super.formatFileContent(input);
    formatted = this.replaceLinebreakInString(formatted);
    const formattedContentIsEmpty = formatted.trim() === "";
    if (formattedContentIsEmpty)
      return this.fileContent;
    if (this.choice.prepend) {
      const shouldInsertLinebreak = !this.choice.task;
      return `${this.fileContent}${shouldInsertLinebreak ? "\n" : ""}${formatted}`;
    }
    if (this.choice.insertAfter.enabled) {
      return await this.insertAfterHandler(formatted);
    }
    const frontmatterEndPosition = this.file ? await this.getFrontmatterEndPosition(this.file) : null;
    if (!frontmatterEndPosition)
      return `${formatted}${this.fileContent}`;
    return this.insertTextAfterPositionInBody(
      formatted,
      this.fileContent,
      frontmatterEndPosition
    );
  }
  async insertAfterHandler(formatted) {
    var _a, _b;
    const targetString = await this.format(
      this.choice.insertAfter.after
    );
    const targetRegex = new RegExp(
      `s*${escapeRegExp(targetString.replace("\\n", ""))}s*`
    );
    let fileContentLines = getLinesInString(this.fileContent);
    const targetPosition = fileContentLines.findIndex(
      (line) => targetRegex.test(line)
    );
    const targetNotFound = targetPosition === -1;
    if (targetNotFound) {
      if ((_a = this.choice.insertAfter) == null ? void 0 : _a.createIfNotFound) {
        return await this.createInsertAfterIfNotFound(formatted);
      }
      log.logError("unable to find insert after line in file.");
    }
    if ((_b = this.choice.insertAfter) == null ? void 0 : _b.insertAtEnd) {
      const nextHeaderPositionAfterTargetPosition = fileContentLines.slice(targetPosition + 1).findIndex((line) => /^#+ |---/.test(line));
      const foundNextHeader = nextHeaderPositionAfterTargetPosition !== -1;
      if (foundNextHeader) {
        let endOfSectionIndex;
        for (let i = nextHeaderPositionAfterTargetPosition + targetPosition; i > targetPosition; i--) {
          const lineIsNewline = /^[\s\n ]*$/.test(
            fileContentLines[i]
          );
          if (!lineIsNewline) {
            endOfSectionIndex = i;
            break;
          }
        }
        if (!endOfSectionIndex)
          endOfSectionIndex = targetPosition;
        return this.insertTextAfterPositionInBody(
          formatted,
          this.fileContent,
          endOfSectionIndex
        );
      } else {
        return this.insertTextAfterPositionInBody(
          formatted,
          this.fileContent,
          fileContentLines.length - 1
        );
      }
    }
    return this.insertTextAfterPositionInBody(
      formatted,
      this.fileContent,
      targetPosition
    );
  }
  async createInsertAfterIfNotFound(formatted) {
    var _a, _b;
    const insertAfterLine = this.replaceLinebreakInString(
      await this.format(this.choice.insertAfter.after)
    );
    const insertAfterLineAndFormatted = `${insertAfterLine}
${formatted}`;
    if (((_a = this.choice.insertAfter) == null ? void 0 : _a.createIfNotFoundLocation) === CREATE_IF_NOT_FOUND_TOP) {
      const frontmatterEndPosition = this.file ? await this.getFrontmatterEndPosition(this.file) : -1;
      return this.insertTextAfterPositionInBody(
        insertAfterLineAndFormatted,
        this.fileContent,
        frontmatterEndPosition
      );
    }
    if (((_b = this.choice.insertAfter) == null ? void 0 : _b.createIfNotFoundLocation) === CREATE_IF_NOT_FOUND_BOTTOM) {
      return `${this.fileContent}
${insertAfterLineAndFormatted}`;
    }
  }
  async getFrontmatterEndPosition(file) {
    const fileCache = await this.app.metadataCache.getFileCache(file);
    if (!fileCache || !fileCache.frontmatter) {
      log.logMessage("could not get frontmatter. Maybe there isn't any.");
      return -1;
    }
    if (fileCache.frontmatter.position)
      return fileCache.frontmatter.position.end.line;
    return -1;
  }
  insertTextAfterPositionInBody(text2, body, pos) {
    if (pos === -1) {
      const shouldAddLinebreak = !this.choice.task;
      return `${text2}${shouldAddLinebreak ? "\n" : ""}${body}`;
    }
    const splitContent = body.split("\n");
    const pre = splitContent.slice(0, pos + 1).join("\n");
    const post = splitContent.slice(pos + 1).join("\n");
    return `${pre}
${text2}${post}`;
  }
};

// src/engine/CaptureChoiceEngine.ts
var CaptureChoiceEngine = class extends QuickAddChoiceEngine {
  constructor(app2, plugin, choice, choiceExecutor) {
    super(app2);
    this.choiceExecutor = choiceExecutor;
    this.choice = choice;
    this.plugin = plugin;
    this.formatter = new CaptureChoiceFormatter(
      app2,
      plugin,
      choiceExecutor
    );
  }
  async run() {
    var _a, _b, _c, _d;
    try {
      if ((_a = this.choice) == null ? void 0 : _a.captureToActiveFile) {
        await this.captureToActiveFile();
        return;
      }
      const captureTo = this.choice.captureTo;
      if (!captureTo) {
        log.logError(`Invalid capture to for ${this.choice.name}`);
        return;
      }
      const filePath = await this.getFilePath(captureTo);
      const content = await this.getCaptureContent();
      let getFileAndAddContentFn;
      if (await this.fileExists(filePath)) {
        getFileAndAddContentFn = this.onFileExists;
      } else if ((_c = (_b = this.choice) == null ? void 0 : _b.createFileIfItDoesntExist) == null ? void 0 : _c.enabled) {
        getFileAndAddContentFn = this.onCreateFileIfItDoesntExist;
      } else {
        log.logWarning(
          `The file ${filePath} does not exist and "Create file if it doesn't exist" is disabled.`
        );
        return;
      }
      const { file, content: newFileContent } = await getFileAndAddContentFn.bind(this)(filePath, content);
      if (this.choice.appendLink) {
        const markdownLink = this.app.fileManager.generateMarkdownLink(
          file,
          ""
        );
        appendToCurrentLine(markdownLink, this.app);
      }
      if ((_d = this.choice) == null ? void 0 : _d.openFile) {
        await openFile(this.app, file, {
          openInNewTab: this.choice.openFileInNewTab.enabled,
          direction: this.choice.openFileInNewTab.direction,
          focus: this.choice.openFileInNewTab.focus,
          mode: this.choice.openFileInMode
        });
      }
      await this.app.vault.modify(file, newFileContent);
    } catch (e) {
      log.logMessage(e);
    }
  }
  async getCaptureContent() {
    let content;
    if (!this.choice.format.enabled)
      content = VALUE_SYNTAX;
    else
      content = this.choice.format.format;
    if (this.choice.task)
      content = `- [ ] ${content}
`;
    return content;
  }
  async onFileExists(filePath, content) {
    const file = await this.getFileByPath(filePath);
    if (!file)
      throw new Error("File not found");
    const fileContent = await this.app.vault.read(file);
    const newFileContent = await this.formatter.formatContentWithFile(
      content,
      this.choice,
      fileContent,
      file
    );
    return { file, content: newFileContent };
  }
  async onCreateFileIfItDoesntExist(filePath, content) {
    let fileContent = "";
    if (this.choice.createFileIfItDoesntExist.createWithTemplate) {
      const singleTemplateEngine = new SingleTemplateEngine(
        this.app,
        this.plugin,
        this.choice.createFileIfItDoesntExist.template,
        this.choiceExecutor
      );
      fileContent = await singleTemplateEngine.run();
    }
    const file = await this.createFileWithInput(
      filePath,
      fileContent
    );
    await replaceTemplaterTemplatesInCreatedFile(this.app, file);
    const updatedFileContent = await this.app.vault.cachedRead(
      file
    );
    const newFileContent = await this.formatter.formatContentWithFile(
      content,
      this.choice,
      updatedFileContent,
      file
    );
    return { file, content: newFileContent };
  }
  async getFilePath(captureTo) {
    const formattedCaptureTo = await this.formatter.formatFileName(
      captureTo,
      this.choice.name
    );
    return this.formatFilePath("", formattedCaptureTo);
  }
  async captureToActiveFile() {
    const activeFile = this.app.workspace.getActiveFile();
    if (!activeFile) {
      log.logError("Cannot capture to active file - no active file.");
      return;
    }
    let content = await this.getCaptureContent();
    content = await this.formatter.formatContent(content, this.choice);
    if (this.choice.format.enabled) {
      content = await templaterParseTemplate(
        this.app,
        content,
        activeFile
      );
    }
    if (!content)
      return;
    if (this.choice.prepend) {
      const fileContent = await this.app.vault.cachedRead(
        activeFile
      );
      const newFileContent = `${fileContent}${content}`;
      await this.app.vault.modify(activeFile, newFileContent);
    } else {
      appendToCurrentLine(content, this.app);
    }
  }
};

// src/gui/suggesters/choiceSuggester.ts
var import_obsidian28 = require("obsidian");
var ChoiceSuggester = class extends import_obsidian28.FuzzySuggestModal {
  constructor(plugin, choices, choiceExecutor) {
    super(plugin.app);
    this.plugin = plugin;
    this.choices = choices;
    this.choiceExecutor = new ChoiceExecutor(
      this.app,
      this.plugin
    );
    if (choiceExecutor)
      this.choiceExecutor = choiceExecutor;
  }
  static Open(plugin, choices, choiceExecutor) {
    new ChoiceSuggester(plugin, choices, choiceExecutor).open();
  }
  getItemText(item) {
    return item.name;
  }
  getItems() {
    return this.choices;
  }
  async onChooseItem(item, evt) {
    if (item.type === "Multi" /* Multi */)
      this.onChooseMultiType(item);
    else
      await this.choiceExecutor.execute(item);
  }
  onChooseMultiType(multi) {
    const choices = [...multi.choices];
    if (multi.name != "\u2190 Back")
      choices.push(new MultiChoice("\u2190 Back").addChoices(this.choices));
    ChoiceSuggester.Open(this.plugin, choices);
  }
};

// src/choiceExecutor.ts
var ChoiceExecutor = class {
  constructor(app2, plugin) {
    this.app = app2;
    this.plugin = plugin;
    this.variables = /* @__PURE__ */ new Map();
  }
  async execute(choice) {
    switch (choice.type) {
      case "Template" /* Template */:
        const templateChoice = choice;
        await this.onChooseTemplateType(templateChoice);
        break;
      case "Capture" /* Capture */:
        const captureChoice = choice;
        await this.onChooseCaptureType(captureChoice);
        break;
      case "Macro" /* Macro */:
        const macroChoice = choice;
        await this.onChooseMacroType(macroChoice);
        break;
      case "Multi" /* Multi */:
        const multiChoice = choice;
        await this.onChooseMultiType(multiChoice);
        break;
      default:
        break;
    }
  }
  async onChooseTemplateType(templateChoice) {
    if (!templateChoice.templatePath) {
      log.logError(
        `please provide a template path for ${templateChoice.name}`
      );
      return;
    }
    await new TemplateChoiceEngine(
      this.app,
      this.plugin,
      templateChoice,
      this
    ).run();
  }
  async onChooseCaptureType(captureChoice) {
    if (!captureChoice.captureTo && !(captureChoice == null ? void 0 : captureChoice.captureToActiveFile)) {
      log.logError(
        `please provide a capture path for ${captureChoice.name}`
      );
      return;
    }
    await new CaptureChoiceEngine(
      this.app,
      this.plugin,
      captureChoice,
      this
    ).run();
  }
  async onChooseMacroType(macroChoice) {
    const macroEngine = await new MacroChoiceEngine(
      this.app,
      this.plugin,
      macroChoice,
      this.plugin.settings.macros,
      this,
      this.variables
    );
    await macroEngine.run();
    Object.entries(macroEngine.params.variables).forEach(([key, value]) => {
      this.variables.set(key, value);
    });
  }
  async onChooseMultiType(multiChoice) {
    ChoiceSuggester.Open(this.plugin, multiChoice.choices, this);
  }
};

// src/main.ts
var QuickAdd = class extends import_obsidian29.Plugin {
  get api() {
    return QuickAddApi.GetApi(app, this, new ChoiceExecutor(app, this));
  }
  async onload() {
    console.log("Loading QuickAdd");
    QuickAdd.instance = this;
    await this.loadSettings();
    this.addCommand({
      id: "runQuickAdd",
      name: "Run QuickAdd",
      callback: () => {
        ChoiceSuggester.Open(this, this.settings.choices);
      }
    });
    this.addCommand({
      id: "reloadQuickAdd",
      name: "Reload QuickAdd (dev)",
      checkCallback: (checking) => {
        if (checking) {
          return this.settings.devMode;
        }
        const id = this.manifest.id, plugins = this.app.plugins;
        plugins.disablePlugin(id).then(() => plugins.enablePlugin(id));
      }
    });
    this.addCommand({
      id: "testQuickAdd",
      name: "Test QuickAdd (dev)",
      checkCallback: (checking) => {
        if (checking) {
          return this.settings.devMode;
        }
        console.log(`Test QuickAdd (dev)`);
        const fn2 = async () => {
          const activeView = await this.app.workspace.getActiveViewOfType(
            import_obsidian29.MarkdownView
          );
          if (!activeView)
            return false;
          const x = this.app.workspace.getLeaf("tab");
          x.openFile(activeView.file);
        };
        fn2();
      }
    });
    log.register(new ConsoleErrorLogger()).register(new GuiLogger(this));
    this.addSettingTab(new QuickAddSettingsTab(this.app, this));
    this.app.workspace.onLayoutReady(
      () => new StartupMacroEngine(
        this.app,
        this,
        this.settings.macros,
        new ChoiceExecutor(this.app, this)
      ).run()
    );
    this.addCommandsForChoices(this.settings.choices);
    await this.convertMacroChoicesMacroToId();
  }
  onunload() {
    console.log("Unloading QuickAdd");
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  addCommandsForChoices(choices) {
    choices.forEach((choice) => this.addCommandForChoice(choice));
  }
  addCommandForChoice(choice) {
    if (choice.type === "Multi" /* Multi */) {
      this.addCommandsForChoices(choice.choices);
    }
    if (choice.command) {
      this.addCommand({
        id: `choice:${choice.id}`,
        name: choice.name,
        callback: async () => {
          await new ChoiceExecutor(this.app, this).execute(choice);
        }
      });
    }
  }
  getChoiceById(choiceId) {
    return this.getChoice("id", choiceId);
  }
  getChoiceByName(choiceName) {
    return this.getChoice("name", choiceName);
  }
  getChoice(by, targetPropertyValue, choices = this.settings.choices) {
    for (const choice of choices) {
      if (choice[by] === targetPropertyValue) {
        return choice;
      }
      if (choice.type === "Multi" /* Multi */) {
        const subChoice = this.getChoice(
          by,
          targetPropertyValue,
          choice.choices
        );
        if (subChoice) {
          return subChoice;
        }
      }
    }
    throw new Error("Choice not found");
  }
  removeCommandForChoice(choice) {
    deleteObsidianCommand(this.app, `quickadd:choice:${choice.id}`);
  }
  async convertMacroChoicesMacroToId() {
    function convertMacroChoiceMacroToIdHelper(choice) {
      if (choice.type === "Multi" /* Multi */) {
        let multiChoice = choice;
        const multiChoices = multiChoice.choices.map(
          convertMacroChoiceMacroToIdHelper
        );
        multiChoice = { ...multiChoice, choices: multiChoices };
        return multiChoice;
      }
      if (choice.type !== "Macro" /* Macro */)
        return choice;
      const macroChoice = choice;
      if (macroChoice.macro) {
        macroChoice.macroId = macroChoice.macro.id;
        delete macroChoice.macro;
      }
      return macroChoice;
    }
    this.settings.choices = this.settings.choices.map(
      convertMacroChoiceMacroToIdHelper
    );
    await this.saveSettings();
  }
};
